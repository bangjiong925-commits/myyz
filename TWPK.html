<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <title>台湾PK数据分析工具</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
  
  <!-- 安全防护脚本 -->
  <script>
    (function() {
      'use strict';
      
      // 域名和协议检测
      function checkDomainAndProtocol() {
        const currentDomain = window.location.hostname;
        const currentProtocol = window.location.protocol;
        
        // 允许的域名列表（根据实际部署域名修改）
        const allowedDomains = [
          'localhost',
          '127.0.0.1',
          'myyz-git-main-a1234s-projects.vercel.app',
          'myyz.vercel.app',
          // 添加其他允许的域名
        ];
        
        // 检查协议（允许https、http和file协议）
        if (currentProtocol !== 'https:' && currentProtocol !== 'http:' && currentProtocol !== 'file:') {
          console.error('非法协议访问:', currentProtocol);
          document.body.innerHTML = '<div style="text-align:center;margin-top:50px;font-size:24px;color:red;">访问协议不正确</div>';
          return false;
        }
        
        // 检查域名（file协议允许空hostname）
        const isDomainAllowed = currentProtocol === 'file:' || allowedDomains.some(domain => 
          currentDomain === domain || currentDomain.endsWith('.' + domain)
        );
        
        if (!isDomainAllowed) {
          console.error('非法域名访问:', currentDomain);
          document.body.innerHTML = '<div style="text-align:center;margin-top:50px;font-size:24px;color:red;">域名访问受限</div>';
          return false;
        }
        
        return true;
      }
      
      // 环境检测
      function checkEnvironment() {
        // 检查是否为file协议（本地文件）
        if (window.location.protocol === 'file:') {
          console.log('本地文件访问模式 - 开发测试环境');
          // 在开发环境中允许本地文件访问
          return true;
        }
        
        // 检查Referer（防止直接访问）
        if (document.referrer === '' && window.location.search === '') {
          // 允许直接访问，但记录日志
          console.log('直接访问检测');
        }
        
        return true;
      }
      
      // 时间戳验证
      function checkTimestamp() {
        const now = new Date();
        const isLocal = location.hostname === 'localhost' || location.hostname === '127.0.0.1';
        // 本地开发环境不提示版本过旧
        if (isLocal) return true;
        const buildTime = new Date('2025-07-01T00:00:00Z'); // 构建时间戳（更新）
        const maxAge = 180 * 24 * 60 * 60 * 1000; // 180天有效期（放宽）
        
        if (now.getTime() - buildTime.getTime() > maxAge) {
          console.warn('页面版本较旧，建议刷新获取最新版本');
          // 不再阻止访问，只显示警告
          const warningDiv = document.createElement('div');
          warningDiv.style.cssText = 'position:fixed;top:0;left:0;right:0;background:#fbbf24;color:#92400e;text-align:center;padding:8px;z-index:9999;font-size:14px;';
          warningDiv.innerHTML = '页面版本较旧，建议刷新获取最新版本 <button onclick="location.reload()" style="margin-left:10px;padding:2px 8px;background:#92400e;color:white;border:none;border-radius:3px;cursor:pointer;">刷新</button>';
          document.body.insertBefore(warningDiv, document.body.firstChild);
          // 5秒后自动隐藏警告
          setTimeout(() => {
            if (warningDiv.parentNode) {
              warningDiv.parentNode.removeChild(warningDiv);
            }
          }, 5000);
        }
        
        return true;
      }
      

      
      // 页面访问频率限制
      function checkAccessFrequency() {
        const storageKey = 'page_access_log';
        const now = Date.now();
        const timeWindow = 60 * 1000; // 1分钟时间窗口
        const maxAccess = 30; // 最大访问次数（放宽限制）
        
        try {
          let accessLog = JSON.parse(localStorage.getItem(storageKey) || '[]');
          
          // 清理过期记录
          accessLog = accessLog.filter(time => now - time < timeWindow);
          
          // 检查访问频率
          if (accessLog.length >= maxAccess) {
            console.warn('访问频率较高，显示友好提示');
            // 不阻止访问，只显示友好提示
            const warningDiv = document.createElement('div');
            warningDiv.style.cssText = 'position:fixed;top:60px;left:0;right:0;background:#f59e0b;color:white;text-align:center;padding:8px;z-index:9997;font-size:14px;';
            warningDiv.innerHTML = '访问频率较高，建议适当休息 <button onclick="this.parentNode.remove()" style="margin-left:10px;padding:2px 8px;background:white;color:#f59e0b;border:none;border-radius:3px;cursor:pointer;">知道了</button>';
            document.body.insertBefore(warningDiv, document.body.firstChild);
            // 8秒后自动隐藏
            setTimeout(() => {
              if (warningDiv.parentNode) {
                warningDiv.parentNode.removeChild(warningDiv);
              }
            }, 8000);
            
            // 清理部分访问记录，避免持续提示
            accessLog = accessLog.slice(-Math.floor(maxAccess * 0.7));
            localStorage.setItem(storageKey, JSON.stringify(accessLog));
          }
          
          // 记录本次访问
          accessLog.push(now);
          localStorage.setItem(storageKey, JSON.stringify(accessLog));
          
        } catch (error) {
          console.warn('访问频率检查失败:', error);
        }
        
        return true;
      }
      
      // 执行所有检查
      function performSecurityChecks() {
        if (!checkEnvironment()) return;
        if (!checkDomainAndProtocol()) return;
        if (!checkTimestamp()) return;
        if (!checkAccessFrequency()) return;
        
        console.log('安全检查通过');
      }
      
      // 页面加载时执行检查
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', performSecurityChecks);
      } else {
        performSecurityChecks();
      }
      
      // 开发者工具检测
      function detectDevTools() {
        let devtools = {
          open: false,
          orientation: null
        };
        
        const threshold = 160;
        
        setInterval(function() {
          if (window.outerHeight - window.innerHeight > threshold || 
              window.outerWidth - window.innerWidth > threshold) {
            if (!devtools.open) {
              devtools.open = true;
              console.clear();
              console.log('%c警告：检测到开发者工具', 'color: red; font-size: 30px; font-weight: bold;');
              console.log('%c此页面受到保护，请关闭开发者工具', 'color: red; font-size: 16px;');
              
              // 可选：阻止页面功能
              // document.body.style.display = 'none';
              // alert('请关闭开发者工具后刷新页面');
            }
          } else {
            devtools.open = false;
          }
        }, 500);
        
        // 检测右键菜单
        document.addEventListener('contextmenu', function(e) {
          e.preventDefault();
          console.log('右键菜单已禁用');
          return false;
        });
        
        // 检测常用快捷键
        document.addEventListener('keydown', function(e) {
          // F12
          if (e.keyCode === 123) {
            e.preventDefault();
            return false;
          }
          // Ctrl+Shift+I
          if (e.ctrlKey && e.shiftKey && e.keyCode === 73) {
            e.preventDefault();
            return false;
          }
          // Ctrl+Shift+C
          if (e.ctrlKey && e.shiftKey && e.keyCode === 67) {
            e.preventDefault();
            return false;
          }
          // Ctrl+U
          if (e.ctrlKey && e.keyCode === 85) {
            e.preventDefault();
            return false;
          }
        });
      }
      
      // 反调试保护
      function antiDebug() {
        // 检测调试器
        let start = new Date();
        debugger;
        let end = new Date();
        if (end - start > 100) {
          console.log('检测到调试器');
          // 可选择的反应
          // window.location.href = 'about:blank';
        }
        
        // 定期执行反调试检查
        setTimeout(antiDebug, 1000);
      }
      
      // 代码完整性检查
      function checkCodeIntegrity() {
        // 检查关键函数是否被修改
        const originalFetch = window.fetch.toString();
        const originalXHR = window.XMLHttpRequest.prototype.open.toString();
        
        setInterval(function() {
          if (window.fetch.toString() !== originalFetch) {
            console.error('检测到fetch函数被修改');
            // 可选择重新加载页面
            // window.location.reload();
          }
          if (window.XMLHttpRequest.prototype.open.toString() !== originalXHR) {
            console.error('检测到XMLHttpRequest被修改');
            // 可选择重新加载页面
            // window.location.reload();
          }
        }, 3000);
      }
      
      // 定期检查（防止运行时修改）
      setInterval(function() {
        if (!checkDomainAndProtocol()) {
          window.location.href = 'about:blank';
        }
      }, 5000);
      
      // 启动所有保护功能
      detectDevTools();
      setTimeout(antiDebug, 1000);
      checkCodeIntegrity();
      
    })();
  </script>
  
  <!-- Tailwind配置 -->
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            primary: '#3b82f6',
            secondary: '#10b981'
          }
        }
      }
    }
  </script>
  
  
  <style type="text/tailwindcss">
    @layer utilities {
      .content-auto {
        content-visibility: auto;
      }
      .sticky-header {
    position: sticky;
    top: 0;
    z-index: 100;
  }
  .sticky-col {
    position: sticky;
    z-index: 50;
  }
  .header-title {
    transition: transform 0.3s ease, opacity 0.3s ease, height 0.3s ease, padding 0.3s ease;
    overflow: hidden;
  }
  .header-title.hidden-on-scroll {
    transform: translateY(-100%);
    opacity: 0;
    height: 0;
    padding: 0;
    pointer-events: none;
  }
  .toolbar-sticky {
    position: sticky;
    top: 0;
    z-index: 100;
    transition: all 0.3s ease;
  }
      .scrollbar-hide::-webkit-scrollbar {
        display: none;
      }
      .scrollbar-hide {
        -ms-overflow-style: none;
        scrollbar-width: none;
      }
      .hit-cell {
        @apply bg-primary/20 text-primary font-bold;
      }
      .miss-cell {
        @apply text-gray-400;
      }
      .btn-active {
        @apply bg-primary text-white;
      }
      .btn-hover {
        @apply hover:bg-primary/80 hover:text-white transition-colors duration-200;
      }
      
      /* 按钮悬停变色为FF7373 - 仅在支持hover的设备上生效，但排除特殊按钮 */
      @media (hover: hover) {
        button:hover:not(.position-btn):not(.hit-number-btn):not(.dama-btn):not(.btn-active) {
          background-color: #FF7373 !important;
          transition: background-color 0.2s ease;
        }
      }
      
      /* 移动端触摸反馈 - 避免保持hover状态，但排除特殊按钮 */
      @media (hover: none) {
        button:active:not(.position-btn):not(.hit-number-btn):not(.dama-btn):not(.btn-active) {
          background-color: #FF7373 !important;
          transition: background-color 0.1s ease;
        }
      }
      
      /* 防止移动端双击放大和意外缩放 */
      * {
        touch-action: manipulation;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
      }
      
      /* 允许输入框和文本区域选择文本 */
      input, textarea, [contenteditable] {
        -webkit-user-select: text;
        -moz-user-select: text;
        -ms-user-select: text;
        user-select: text;
      }
      
      /* 胆码按钮特殊处理 - 确保触摸反馈正常 */
      .dama-btn {
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent;
      }
      
      /* 胆码按钮未选中状态 - 覆盖全局hover样式 */
      @media (hover: hover) {
        .dama-btn:not(.bg-primary):hover {
          background-color: #e5e7eb !important; /* gray-200 */
          color: #374151 !important; /* gray-700 */
        }
      }
      
      /* 胆码按钮选中状态保持红色 */
      .dama-btn.bg-primary {
        background-color: #d62828 !important;
        color: white !important;
      }
      
      @media (hover: hover) {
        .dama-btn.bg-primary:hover {
          background-color: #b91c1c !important; /* 稍深的红色 */
          color: white !important;
        }
      }
      
      /* 位置选择按钮样式 */
      .position-btn {
        cursor: pointer !important;
        pointer-events: auto !important;
        user-select: none !important;
        transition: all 0.2s ease !important;
      }
      
      .position-btn:not(.btn-active) {
        background-color: #e5e7eb !important; /* gray-200 */
        color: #374151 !important; /* gray-700 */
      }
      
      .position-btn.btn-active,
      .position-btn.bg-primary {
        background-color: #3b82f6 !important; /* blue-500 */
        color: white !important;
      }
      
      @media (hover: hover) {
        .position-btn:not(.btn-active):hover {
          background-color: #d1d5db !important; /* gray-300 */
          color: #374151 !important;
        }
        
        .position-btn.btn-active:hover,
        .position-btn.bg-primary:hover {
          background-color: #2563eb !important; /* blue-600 */
          color: white !important;
        }
      }
      
      /* 移动端位置按钮触摸反馈 */
      @media (hover: none) {
        .position-btn:active {
          transform: scale(0.95) !important;
          transition: transform 0.1s ease !important;
        }
      }
      
      /* 命中数字按钮样式 */
      .hit-number-btn.bg-primary {
        background-color: #10b981 !important; /* emerald-500 */
        color: white !important;
      }
      
      @media (hover: hover) {
        .hit-number-btn.bg-primary:hover {
          background-color: #059669 !important; /* emerald-600 */
          color: white !important;
        }
      }
      
      /* 防止页面缩放 */
      html {
        -ms-touch-action: manipulation;
        touch-action: manipulation;
      }
      .number-row {
        @apply flex justify-center space-x-1 mb-1;
      }
      
      /* 手机端五星做号页面优化 */
      @media (max-width: 768px) {
        /* 移除主容器的左右边距 */
        #fiveStarPage .container {
          padding-left: 0 !important;
          padding-right: 0 !important;
          margin-left: 0 !important;
          margin-right: 0 !important;
          max-width: 100% !important;
        }
        
        /* 移除模块容器的边距和圆角 */
        #fiveStarPage .bg-white {
          border-radius: 0 !important;
          padding: 8px !important;
          margin: 0 !important;
        }
        
        /* 移除模块间距 */
        #modules-container {
          gap: 8px !important;
          padding: 0 !important;
        }
        
        /* 移除模块边框和圆角 */
        .five-star-module {
          border: none !important;
          border-radius: 0 !important;
          padding: 8px !important;
          margin: 0 !important;
        }
        
        /* 优化数字按钮尺寸 - 确保一行放10个 */
        .number-btn {
          width: calc(10% - 2px) !important;
          height: 32px !important;
          min-width: 28px !important;
          font-size: 13px !important;
          padding: 0 !important;
          margin: 1px !important;
          flex-shrink: 0 !important; /* 防止按钮收缩 */
        }
      }
      
      /* 交集拼接页面专用样式 */
      .intersection-page-title {
        @apply text-2xl font-bold text-gray-800 text-center mb-6;
      }
      
      .function-switch-area {
        @apply flex justify-center mb-6;
      }
      
      .function-switch-btn {
        @apply px-6 py-2 mx-2 rounded-md font-medium transition-colors duration-200;
      }
      
      .function-switch-btn.active {
        @apply bg-blue-500 text-white;
      }
      
      .function-switch-btn:not(.active) {
        @apply bg-gray-200 text-gray-700 hover:bg-gray-300;
      }
      
      /* 拼接类型按钮样式 */
      .concat-type-btn {
        @apply px-6 py-2 mx-2 rounded-md font-medium transition-colors duration-200;
      }
      
      .concat-type-btn.active {
        @apply bg-blue-500 text-white;
      }
      
      .concat-type-btn:not(.active) {
        @apply bg-gray-200 text-gray-700 hover:bg-gray-300;
      }
      
      .management-functions {
        @apply flex justify-center gap-4 mb-6;
      }
      
      .management-btn {
        @apply px-4 py-2 bg-gray-500 text-white rounded-md hover:bg-gray-600 transition-colors;
      }
      
      .main-input-area {
        @apply bg-blue-50 border-2 border-blue-200 rounded-lg p-4 mb-6;
      }
      
      .main-input-title {
        @apply text-lg font-medium text-gray-800 mb-3;
      }
      
      .main-input-textarea {
        @apply w-full h-24 px-3 py-2 border border-gray-300 rounded-md resize-none text-sm bg-white;
      }
      
      .main-input-actions {
        @apply flex justify-end gap-2 mt-3;
      }
      
      .input-action-btn {
        @apply px-4 py-2 rounded-md text-white font-medium transition-colors;
      }
      
      .input-action-btn.copy {
        @apply bg-green-500 hover:bg-green-600;
      }
      
      .input-action-btn.clear {
        @apply bg-red-500 hover:bg-red-600;
      }
      
      .input-action-btn.paste {
        @apply bg-blue-500 hover:bg-blue-600;
      }
      
      .input-modules-area {
        @apply mb-6;
      }
      
      .input-modules-title {
        @apply text-lg font-medium text-gray-800 mb-4;
      }
      
      .modules-grid {
        @apply grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4;
      }
      
      .input-module {
        @apply bg-white border border-gray-200 rounded-lg p-4 shadow-sm;
      }
      
      .module-header {
        @apply flex items-center justify-between mb-3;
      }
      
      .module-title {
        @apply text-base font-medium text-gray-800;
      }
      
      .module-actions {
        @apply flex gap-2;
      }
      
      .module-btn {
        @apply px-3 py-1 text-sm rounded transition-colors;
      }
      
      .module-btn.paste {
        @apply bg-blue-500 text-white hover:bg-blue-600;
      }
      
      .module-btn.clear {
        @apply bg-gray-500 text-white hover:bg-gray-600;
      }
      
      .module-textarea {
        @apply w-full px-3 py-2 border border-gray-300 rounded-md resize-none text-sm bg-white;
      }

      /* 号码交集功能专用样式 */
      .tolerance-btn {
        @apply px-4 py-2 bg-gray-200 text-gray-700 rounded-md hover:bg-gray-300 transition-colors font-medium min-w-[40px] text-center;
      }

      .tolerance-btn.active {
        @apply bg-blue-500 text-white hover:bg-blue-600;
      }

      .modules-container {
        @apply border border-gray-200 rounded-lg bg-gray-50;
      }

      .modules-container::-webkit-scrollbar {
        width: 8px;
      }

      .modules-container::-webkit-scrollbar-track {
        @apply bg-gray-100 rounded;
      }

      .modules-container::-webkit-scrollbar-thumb {
        @apply bg-gray-300 rounded hover:bg-gray-400;
      }

      .module-count {
        @apply text-xs text-gray-500 ml-2;
      }

      .clear-btn {
        @apply bg-red-500 text-white hover:bg-red-600;
      }

      .paste-btn {
        @apply bg-blue-500 text-white hover:bg-blue-600;
      }
      
      /* 移动端优化 */
      @media (max-width: 768px) {
        .intersection-page-title {
          @apply text-xl mb-4;
        }
        
        .function-switch-btn {
          @apply px-4 py-2 mx-1 text-sm;
        }
        
        .management-functions {
          @apply flex-wrap gap-2 mb-4;
        }
        
        .management-btn {
          @apply px-3 py-1 text-sm;
        }
        
        .main-input-area {
          @apply p-3 mb-4;
        }
        
        .main-input-title {
          @apply text-base mb-2;
        }
        
        .main-input-textarea {
          @apply h-20 text-sm;
        }
        
        .input-modules-title {
          @apply text-base mb-3;
        }
        
        .modules-grid {
          @apply grid-cols-1 gap-3;
        }
        
        .input-module {
          @apply p-3;
        }
        
        .module-title {
          @apply text-sm;
        }
        
        .module-btn {
          @apply px-2 py-1 text-xs;
        }
        
        .module-textarea {
          @apply text-sm;
        }
        
        /* 优化数字按钮容器 - 确保不换行 */
        .number-buttons {
          gap: 0 !important;
          margin-bottom: 8px !important;
          flex-wrap: nowrap !important; /* 强制不换行 */
          overflow-x: auto !important; /* 如果内容过宽则允许横向滚动 */
        }
        
        /* 优化胆码按钮 */
        .dama-btn {
          font-size: 13px !important;
          padding: 4px 8px !important;
          margin: 1px !important;
        }
        
        /* 优化胆码按钮容器 */
        .dama-buttons {
          gap: 2px !important;
          margin-bottom: 8px !important;
        }
        
        /* 优化筛选组间距 */
        .filter-group {
          margin-bottom: 8px !important;
          padding-bottom: 8px !important;
        }
        
        /* 优化模块总容错区域 */
        .module-tolerance {
          margin-bottom: 8px !important;
          padding: 8px !important;
        }
      }
      
      /* 手机端黄金切割页面优化 */
      @media (max-width: 768px) {
        /* 移除黄金切割页面主容器的左右边距 */
        #goldenRatioPage .container {
          padding-left: 0 !important;
          padding-right: 0 !important;
          margin-left: 0 !important;
          margin-right: 0 !important;
          max-width: 100% !important;
        }
        
        /* 移除主模块的边距和圆角 */
        #goldenRatioPage .bg-white {
          border-radius: 0 !important;
          padding: 12px !important;
          margin: 0 !important;
          box-shadow: none !important;
        }
        
        /* 优化模式选择按钮 */
        #goldenRatioPage .flex.justify-center.gap-3 {
          gap: 8px !important;
        }
        
        #goldenRatioPage button[data-mode] {
          padding: 8px 16px !important;
          font-size: 14px !important;
        }
        
        /* 优化输入区域 */
        #goldenInputData {
          padding: 8px !important;
          font-size: 14px !important;
        }
        
        /* 优化操作按钮 */
        #goldenRatioPage .flex.justify-center.gap-3.mb-6 {
          gap: 6px !important;
          flex-wrap: wrap !important;
        }
        
        #goldenRatioPage .flex.justify-center.gap-3.mb-6 button {
          padding: 8px 12px !important;
          font-size: 13px !important;
          flex: 1 !important;
          min-width: 80px !important;
        }
        
        /* 优化结果显示区域 */
        #goldenRatioPage .grid.grid-cols-1.sm\:grid-cols-2.md\:grid-cols-3.lg\:grid-cols-5 {
          grid-template-columns: 1fr 1fr !important;
          gap: 4px !important;
        }
        
        /* 优化验证结果区域 */
        #validationResults {
          padding: 8px !important;
          margin-top: 12px !important;
        }
        
        /* 优化标题和摘要 */
        #goldenRatioPage h3 {
          font-size: 16px !important;
        }
        
        #goldenRatioPage .text-sm {
          font-size: 12px !important;
        }
      }
      
      /* 手机端黄金切割页面优化 */
      @media (max-width: 768px) {
        /* 移除黄金切割页面主容器的左右边距 */
        #goldenRatioPage .container {
          padding-left: 0 !important;
          padding-right: 0 !important;
          margin-left: 0 !important;
          margin-right: 0 !important;
          max-width: 100% !important;
        }
        
        /* 移除主模块的边框、圆角和阴影 */
        #goldenRatioPage .bg-white {
          border-radius: 0 !important;
          box-shadow: none !important;
          padding: 8px !important;
          margin: 0 !important;
        }
        
        /* 优化模式选择按钮 */
        #goldenRatioPage .flex.justify-center.gap-3 button {
          padding: 8px 16px !important;
          font-size: 14px !important;
          margin: 2px !important;
        }
        
        /* 优化输入区域 */
        #goldenRatioPage textarea {
          padding: 8px !important;
          font-size: 14px !important;
          border-radius: 4px !important;
        }
        
        /* 优化操作按钮 */
        #goldenRatioPage .flex.justify-center.gap-3.mb-6 button {
          padding: 8px 12px !important;
          font-size: 13px !important;
          margin: 2px !important;
        }
        
        /* 优化结果显示区域 */
        #goldenRatioPage .grid.gap-2 {
          gap: 4px !important;
        }
        
        /* 优化验证结果区域 */
        #goldenRatioPage #validationResults {
          padding: 8px !important;
          margin-top: 8px !important;
          border-radius: 4px !important;
        }
        
        /* 减少各区域的边距 */
        #goldenRatioPage .mb-6 {
          margin-bottom: 12px !important;
        }
        
        #goldenRatioPage .mb-4 {
          margin-bottom: 8px !important;
        }
        
        #goldenRatioPage .mb-2 {
          margin-bottom: 4px !important;
        }
      }
      .fixed-width-period {
        width: 120px;
        transition: opacity 0.3s ease;
      }
      .fixed-width-data {
        width: 150px;
        transition: left 0.3s ease;
      }
      .table-header-sticky {
        position: sticky;
        top: 0;
        z-index: 1002;
        background-color: #f9fafb;
      }
      .sticky-bg-white {
        background-color: white !important;
      }
      .sticky-bg-gray-100 {
        background-color: #f3f4f6 !important;
      }
      
      /* 自定义滚动条样式 */
      .scrollbar-thin {
        scrollbar-width: thin;
      }
      
      .scrollbar-thin::-webkit-scrollbar {
        width: 6px;
        height: 6px;
      }
      
      .scrollbar-thumb-gray-300::-webkit-scrollbar-thumb {
        background-color: #d1d5db;
        border-radius: 3px;
      }
      
      .scrollbar-thumb-gray-300::-webkit-scrollbar-thumb:hover {
        background-color: #9ca3af;
      }
      
      .scrollbar-track-gray-100::-webkit-scrollbar-track {
        background-color: #f3f4f6;
        border-radius: 3px;
      }
      
      /* 黄金切割结果容器样式 */
      #goldenResults {
        scroll-behavior: smooth;
      }
      
      #goldenResults::-webkit-scrollbar {
        height: 8px;
      }
      
      #goldenResults::-webkit-scrollbar-track {
        background: #f1f5f9;
        border-radius: 4px;
      }
      
      #goldenResults::-webkit-scrollbar-thumb {
        background: #cbd5e1;
        border-radius: 4px;
      }
      
      #goldenResults::-webkit-scrollbar-thumb:hover {
        background: #94a3b8;
      }
      
      /* 模式切换按钮样式 */
      .active-mode {
        background-color: #3b82f6 !important;
        color: white !important;
      }
      
      .inactive-mode {
        background-color: #d1d5db !important;
        color: #374151 !important;
      }
      .sticky-bg-gray-50 {
        background-color: #f9fafb !important;
      }
      .slider-container {
        @apply relative h-6 mt-2 mb-4;
      }
      .slider-track {
        @apply absolute h-2 w-full bg-gray-200 rounded-full;
      }
      .slider-thumb {
        @apply absolute w-5 h-5 bg-primary rounded-full cursor-pointer -mt-1.5 -ml-2.5;
      }
      .slider-fill {
        @apply absolute h-2 bg-primary rounded-full;
      }
      .vertical-slider-container {
        @apply absolute right-0 top-0 h-full w-4 flex items-center justify-center z-10;
      }
      .vertical-slider-track {
        @apply absolute h-full w-1 bg-gray-200 rounded-full;
      }
      .vertical-slider-thumb {
        @apply absolute w-4 h-6 bg-primary rounded-md cursor-pointer -ml-1.5;
      }
      .vertical-slider-fill {
        @apply absolute w-1 bg-primary rounded-full;
      }
      /* 限制表格容器高度，最多显示50行 */
      .table-container {
        max-height: calc(100vh - 400px); /* 页面一屏高度减去其他元素高度 */
        overflow-y: auto;
        position: relative;
      }
      
      /* 手机端全屏模式样式 */
      @media (max-width: 768px) {
        /* 全屏模式下的工具栏样式 */
        .fullscreen-toolbar {
          position: fixed !important;
          top: 0 !important;
          left: 0 !important;
          right: 0 !important;
          z-index: 1000 !important;
          box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15) !important;
        }
        
        /* 全屏模式下隐藏的元素 */
        .fullscreen-hidden {
          transform: translateY(-100%) !important;
          transition: transform 0.3s ease-in-out !important;
        }
        
        /* 全屏模式下主内容区域的调整 */
        .fullscreen-main {
          padding-top: 50px !important;
          transition: padding-top 0.3s ease-in-out !important;
        }
        
        /* 优化手机端滚动性能 */
        body {
          -webkit-overflow-scrolling: touch;
        }
        
        /* 全屏模式下的工具栏按钮优化 */
        .fullscreen-toolbar .container {
          padding-left: 1rem !important;
          padding-right: 1rem !important;
        }
        
        .fullscreen-toolbar button {
          font-size: 14px !important;
          padding: 0.5rem 1rem !important;
        }
        
        /* 防止全屏切换时的闪烁 */
        header * {
          backface-visibility: hidden;
          -webkit-backface-visibility: hidden;
        }
        
        /* 全屏模式下的阴影效果 */
        .fullscreen-toolbar::after {
          content: '';
          position: absolute;
          bottom: -8px;
          left: 0;
          right: 0;
          height: 8px;
          background: linear-gradient(to bottom, rgba(0,0,0,0.1), transparent);
          pointer-events: none;
        }
      }
    }
  </style>
  
  <script>
    // 滚动时隐藏标题，保留工具栏
    let lastScrollTop = 0;
    let isScrolling = false;
    let isPageSwitching = false; // 页面切换标志
    let scrollTimeout = null; // 滚动防抖定时器
    
    function handleScroll() {
      if (isScrolling || isPageSwitching) return;
      
      // 清除之前的定时器
      if (scrollTimeout) {
        clearTimeout(scrollTimeout);
      }
      
      isScrolling = true;
      
      // 添加防抖延迟，避免频繁触发
      scrollTimeout = setTimeout(() => {
        requestAnimationFrame(() => {
          const currentScroll = window.pageYOffset || document.documentElement.scrollTop;
          const headerTitle = document.querySelector('.header-title');
          const keyCountdown = document.getElementById('keyCountdown');
          const scrollDirection = currentScroll > lastScrollTop ? 'down' : 'up';
          
          // 增加滚动阈值和方向检测，减少闪动
          if (currentScroll > 80 && scrollDirection === 'down') {
            // 向下滚动超过80px时隐藏标题
            headerTitle.classList.add('hidden-on-scroll');
            // 同时隐藏密钥倒计时栏（完全隐藏并释放空间）
            if (keyCountdown && !keyCountdown.classList.contains('hidden')) {
              keyCountdown.style.height = '0';
              keyCountdown.style.opacity = '0';
              keyCountdown.style.paddingTop = '0';
              keyCountdown.style.paddingBottom = '0';
              keyCountdown.style.overflow = 'hidden';
              keyCountdown.style.transition = 'all 0.3s ease-in-out';
            }
          } else if (currentScroll < 40 && scrollDirection === 'up') {
            // 向上滚动到40px以下时显示标题
            headerTitle.classList.remove('hidden-on-scroll');
            // 同时显示密钥倒计时栏（恢复原始高度和样式）
            if (keyCountdown && !keyCountdown.classList.contains('hidden')) {
              keyCountdown.style.height = 'auto';
              keyCountdown.style.opacity = '1';
              keyCountdown.style.paddingTop = '0.5rem';
              keyCountdown.style.paddingBottom = '0.5rem';
              keyCountdown.style.overflow = 'visible';
              keyCountdown.style.transition = 'all 0.3s ease-in-out';
            }
          }
          
          lastScrollTop = currentScroll <= 0 ? 0 : currentScroll;
          isScrolling = false;
        });
      }, 50); // 50ms防抖延迟
    }
    
    // 页面切换时禁用滚动监听
    function disableScrollListener() {
      isPageSwitching = true;
      setTimeout(() => {
        isPageSwitching = false;
      }, 300); // 300ms后重新启用
    }
    
    // 页面加载完成后添加滚动监听
    document.addEventListener('DOMContentLoaded', function() {
      window.addEventListener('scroll', handleScroll, { passive: true });
    });
  </script>
</head>
<body class="bg-gray-50 font-sans text-dark min-h-screen flex flex-col">
  <!-- 密钥倒计时通知栏 -->
  <div id="keyCountdown" class="bg-primary text-white py-2 px-4 text-center hidden">
    <span>密钥有效期剩余: <strong id="timeRemaining">0天 0小时 0分钟 0秒</strong></span>
  </div>
  
  <!-- 顶部导航 -->
  <!-- 标题区域 - 独立模块 -->
  <div class="header-title bg-white shadow-sm">
    <div class="container mx-auto px-4 py-3 flex flex-wrap items-center justify-between">
        <h1 class="text-xl md:text-2xl font-bold text-primary flex items-center">
          <i class="fa fa-line-chart mr-2"></i>台湾PK数据分析工具
        </h1>

      </div>
  </div>
    
  <!-- 工具栏区域 - 独立粘性模块 -->
  <nav class="bg-gray-800 text-white py-2 sticky-header toolbar-sticky" style="top: 0; z-index: 100;">
    <div class="container mx-auto px-4">
      <div class="flex justify-between items-center">
        <div class="flex space-x-4">
          <button id="dataAnalysisBtn" class="px-4 py-1 rounded bg-primary text-white font-medium">数据分析</button>
          <button id="fiveStarBtn" class="px-4 py-1 rounded bg-gray-600 text-white font-medium hover:bg-primary transition-colors">做号拼接</button>
          <button id="verifyPlanBtn" class="px-4 py-1 rounded bg-gray-600 text-white font-medium hover:bg-primary transition-colors">验证计划</button>
          <button id="goldenRatioBtn" class="px-4 py-1 rounded bg-gray-600 text-white font-medium hover:bg-primary transition-colors">黄金切割</button>
          <button id="intersectionCutBtn" class="px-4 py-1 rounded bg-gray-600 text-white font-medium hover:bg-primary transition-colors">号码交集</button>
        </div>
        <!-- 数据源指示器 -->
        <div id="dataSourceIndicator" class="flex items-center space-x-2 text-sm">
          <span class="text-gray-300">数据源:</span>
          <span id="dataSourceStatus" class="px-2 py-1 rounded text-xs font-medium bg-green-600 text-white">自动获取</span>
        </div>
      </div>
    </div>
  </nav>

  <!-- 主要内容 -->
  <main class="flex-1 container mx-auto px-4 py-6">
    <!-- 数据分析页面 -->
    <div id="dataAnalysisPage">
      <!-- 数据输入区域 -->
      <section class="bg-white rounded-lg shadow-md p-5 mb-6">
        <div class="flex flex-col md:flex-row md:items-center gap-4">
          <div class="flex-1">
            <label for="numbersInput" class="block text-sm font-medium text-gray-700 mb-1">手动输入数据（支持格式：期数 数据，如：202504181232 02,05,01,04,07,10,09,03,06,08 ）</label>
            <textarea id="numbersInput" rows="4" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary transition-all duration-200" placeholder="202504181232 02,05,01,04,07,10,09,03,06,08"></textarea>
          </div>
          <div class="flex flex-col gap-3 w-full md:w-auto">
            <button id="calcBtn" class="px-4 py-2 bg-primary text-white rounded-md flex items-center justify-center btn-hover">
              <i class="fa fa-calculator mr-2"></i>计算分析
            </button>
            <button id="autoFetchBtn" class="px-4 py-2 bg-green-500 hover:bg-green-600 text-white rounded-md flex items-center justify-center btn-hover" style="display: none;">
              <i class="fa fa-play mr-2"></i>开始自动获取
            </button>
            <button id="fetchApiBtn" class="px-4 py-2 bg-green-600 text-white rounded-md flex items-center justify-center btn-hover" style="display: none;">
        <i class="fa fa-download mr-2"></i>获取最新数据
    </button>
            <button id="uploadDataBtn" class="px-4 py-2 bg-gray-600 text-white rounded-md flex items-center justify-center btn-hover">
              <i class="fa fa-upload mr-2"></i>上传数据文件
            </button>
          </div>
        </div>
        <div id="output" class="mt-3 text-sm text-primary"></div>
      </section>

      <!-- 筛选和统计控制区域 -->
      <section class="bg-white rounded-lg shadow-md p-5 mb-6">
        <div class="grid grid-cols-1 gap-4">
          <!-- 自定义组合 -->
          <div>
            <label for="customCombos" class="block text-sm font-medium text-gray-700 mb-1">自定义组合（用空格分隔不同组合，每个组合内的数字用逗号分隔）：</label>
            <div class="flex gap-3 items-start">
              <textarea id="customCombos" rows="2" class="flex-1 px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary transition-all duration-200" placeholder="1,2,3 1,2,4"></textarea>
              <div class="flex flex-col gap-2">
                <button id="statBtn" class="px-4 py-2 bg-gray-700 text-white rounded-md flex items-center btn-hover whitespace-nowrap">
                  <i class="fa fa-bar-chart mr-2"></i>加入统计
                </button>
                <button id="clearBtn" class="px-4 py-2 bg-gray-700 text-white rounded-md flex items-center btn-hover whitespace-nowrap">
                  <i class="fa fa-trash mr-2"></i>清空数据
                </button>
              </div>
            </div>
          </div>
          
          <!-- 筛选模块 -->
          <div class="flex flex-wrap items-start gap-4">
            <!-- 胆码数筛选 -->
            <div class="flex-shrink-0 bg-blue-50 p-3 rounded-lg border border-blue-100">
              <label class="block text-sm font-medium text-gray-700 mb-2">选择码数</label>
              <select id="numSelect" class="px-3 py-1 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary">
                <option value="1">1码</option>
                <option value="2">2码</option>
                <option value="3" selected>3码</option>
                <option value="4">4码</option>
                <option value="5">5码</option>
                <option value="6">6码</option>
                <option value="7">7码</option>
                <option value="8">8码</option>
                <option value="9">9码</option>
                <option value="10">10码</option>
              </select>
            </div>
            
            <!-- 位置选择 -->
            <div class="flex-shrink-0 bg-blue-50 p-3 rounded-lg border border-blue-100">
              <label class="block text-sm font-medium text-gray-700 mb-2">位置选择：</label>
              <div id="positionButtons" class="flex flex-wrap gap-2">
                <button class="position-btn px-3 py-1 rounded-md" data-position="1">1名</button>
                <button class="position-btn px-3 py-1 rounded-md" data-position="2">2名</button>
                <button class="position-btn px-3 py-1 rounded-md" data-position="3">3名</button>
                <button class="position-btn px-3 py-1 rounded-md" data-position="4">4名</button>
                <button class="position-btn px-3 py-1 rounded-md" data-position="5">5名</button>
                <button class="position-btn px-3 py-1 rounded-md" data-position="6">6名</button>
                <button class="position-btn px-3 py-1 rounded-md" data-position="7">7名</button>
                <button class="position-btn px-3 py-1 rounded-md" data-position="8">8名</button>
              </div>
            </div>
            
            <!-- 中出筛选 -->
            <div class="flex-shrink-0 bg-blue-50 p-3 rounded-lg border border-blue-100">
              <label class="block text-sm font-medium text-gray-700 mb-2">命中码数：</label>
              <div id="hitButtons" class="flex flex-wrap gap-2"></div>
            </div>
            
            <!-- 命中数字选择 -->
            <div class="flex-shrink-0 bg-blue-50 p-3 rounded-lg border border-blue-100">
              <label class="block text-sm font-medium text-gray-700 mb-2">命中数字：</label>
              <div id="hitNumberButtons" class="flex flex-wrap gap-2">
                <button class="hit-number-btn px-3 py-1 rounded-md bg-gray-200 btn-hover" data-number="1">1</button>
                <button class="hit-number-btn px-3 py-1 rounded-md bg-gray-200 btn-hover" data-number="2">2</button>
                <button class="hit-number-btn px-3 py-1 rounded-md bg-gray-200 btn-hover" data-number="3">3</button>
                <button class="hit-number-btn px-3 py-1 rounded-md bg-gray-200 btn-hover" data-number="4">4</button>
                <button class="hit-number-btn px-3 py-1 rounded-md bg-gray-200 btn-hover" data-number="5">5</button>
                <button class="hit-number-btn px-3 py-1 rounded-md bg-gray-200 btn-hover" data-number="6">6</button>
                <button class="hit-number-btn px-3 py-1 rounded-md bg-gray-200 btn-hover" data-number="7">7</button>
                <button class="hit-number-btn px-3 py-1 rounded-md bg-gray-200 btn-hover" data-number="8">8</button>
                <button class="hit-number-btn px-3 py-1 rounded-md bg-gray-200 btn-hover" data-number="9">9</button>
                <button class="hit-number-btn px-3 py-1 rounded-md bg-gray-200 btn-hover" data-number="10">10</button>
              </div>
            </div>
            
            <!-- 确认按钮 -->
            <div class="flex-shrink-0 bg-blue-50 p-3 rounded-lg border border-blue-100">
              <button id="confirmFilterBtn" class="w-full px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 transition-colors duration-200 font-medium">
                确认筛选
              </button>
            </div>
          </div>
        </div>
        
        <!-- 操作按钮 -->
        <div class="flex flex-wrap gap-3 mt-5">
          <button id="sortToggle" class="px-4 py-2 bg-gray-700 text-white rounded-md flex items-center btn-hover hidden">
            <i class="fa fa-sort mr-2"></i><span id="sortText">按连中次数排序</span>
          </button>
        </div>
      </section>

      <!-- 结果表格 -->
      <section class="bg-white rounded-lg shadow-md p-5 overflow-x-auto relative">
        <div class="flex flex-wrap justify-between items-center mb-4 gap-3">
          <div class="flex items-center gap-3">
            <h2 class="text-lg font-semibold">数据分析结果</h2>
            <!-- 统一的按钮组 -->
            <div class="flex gap-1">
              <!-- 当前遗漏/当前连中切换 -->
              <div class="flex rounded-md overflow-hidden border border-gray-300">
                <button id="currentMissBtn" class="px-3 py-1 bg-blue-600 text-white btn-hover text-sm btn-active">当前遗漏</button>
                <button id="currentHitBtn" class="px-3 py-1 bg-gray-200 text-gray-700 btn-hover text-sm">当前连中</button>
              </div>
              <!-- 命中率排序按钮 -->
              <button id="hitRateSortBtn" class="px-3 py-1 bg-orange-500 text-white rounded-md btn-hover text-sm">命中率排序</button>
            </div>
          </div>
          <div class="flex flex-wrap gap-2">
            <button class="period-btn px-3 py-1 rounded-md bg-gray-200 btn-hover btn-active" data-period="15">15期</button>
            <button class="period-btn px-3 py-1 rounded-md bg-gray-200 btn-hover" data-period="30">30期</button>
            <button class="period-btn px-3 py-1 rounded-md bg-gray-200 btn-hover" data-period="50">50期</button>
            <button class="period-btn px-3 py-1 rounded-md bg-gray-200 btn-hover" data-period="100">100期</button>
            <div class="flex items-center gap-1">
              <input type="number" id="customPeriod" min="1" max="10000" value="15" class="w-16 px-2 py-1 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary">
              <button id="customPeriodBtn" class="px-3 py-1 rounded-md bg-gray-200 btn-hover">自定义</button>
            </div>
          </div>
          <div class="text-sm text-gray-500">
            <span id="periodCount">0</span> 期数据
          </div>
        </div>
        
        <!-- 水平滑块 -->
        <div class="slider-container">
          <div class="slider-track"></div>
          <div class="slider-fill" id="horizontalFill"></div>
          <div class="slider-thumb" id="horizontalThumb"></div>
        </div>
        
        <div class="relative">
          <div class="overflow-x-auto table-container scrollbar-thin scrollbar-thumb-gray-300 scrollbar-track-gray-100" id="tableContainer">
            <table id="resultTable" class="min-w-full divide-y divide-gray-200">
              <thead></thead>
              <tbody></tbody>
            </table>
          </div>
          
          <!-- 垂直滑块 -->
          <div class="vertical-slider-container" id="verticalSlider">
            <div class="vertical-slider-track"></div>
            <div class="vertical-slider-fill" id="verticalFill"></div>
            <div class="vertical-slider-thumb" id="verticalThumb"></div>
          </div>
        </div>
        
        <!-- 统计摘要 -->
        <div id="summary" class="mt-4 p-3 bg-gray-50 rounded-md text-sm font-medium"></div>
      </section>
    </div>
    
    <!-- 五星做号页面（按图片布局） -->
    <div id="fiveStarPage" class="hidden">
      <div class="container mx-auto py-8">
        <div class="bg-white rounded-lg shadow-md p-6">
          <!-- 号码显示区域 -->
          <div class="mb-6 border border-gray-200 rounded-lg p-4 bg-gray-50">
            <!-- 星级选择器在左上角 -->
            <div class="flex items-center justify-between mb-4">
              <div class="flex items-center space-x-3">
                <span class="text-sm font-semibold text-gray-800">拼接星级：</span>
                <div class="flex space-x-2">
                  <button id="star3Btn" class="star-btn px-3 py-1 rounded border border-gray-200 text-gray-600 hover:bg-blue-100 transition-colors text-sm" data-star="3">3星</button>
                  <button id="star4Btn" class="star-btn px-3 py-1 rounded border border-gray-200 text-gray-600 hover:bg-blue-100 transition-colors text-sm" data-star="4">4星</button>
                  <button id="star5Btn" class="star-btn px-3 py-1 rounded border-2 border-green-500 bg-green-500 text-white active text-sm" data-star="5">5星</button>
                </div>
              </div>
              <div class="flex space-x-2">
                <button id="concatBtn" class="px-3 py-1 bg-blue-500 text-white rounded text-sm hover:bg-blue-600 transition-colors">拼接</button>
                <button id="copyAllBtn" class="px-3 py-1 bg-green-500 text-white rounded text-sm hover:bg-green-600 transition-colors">复制</button>
                <button id="verifyBtn" class="px-3 py-1 bg-orange-500 text-white rounded text-sm hover:bg-orange-600 transition-colors">验证</button>
              </div>
            </div>
            <div class="bg-white border rounded p-3 min-h-[120px] max-h-[200px] overflow-y-auto text-sm font-mono" id="numberDisplay">
              <div class="text-gray-500 text-center py-8">请先生成号码</div>
            </div>
            <div id="numberCount" class="text-xs text-gray-500 mt-2">共 0 注</div>
          </div>
           <!-- 下方添加区域 - 所有模块统一容器 -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6" id="modules-container">
            <!-- 左侧卡片 - 模块1 (5组筛选条件) -->
        <div id="module1" class="border border-gray-200 rounded-lg p-4 five-star-module">
          <!-- 做号星级选择器 -->
          <div class="module-star-selector mb-4 p-3 bg-green-50 rounded border border-green-200">
            <div class="flex items-center space-x-3 mb-3">
              <span class="text-sm font-semibold text-green-800">做号星级：</span>
              <div class="flex space-x-1">
                <button class="module-star-btn px-3 py-1 rounded border border-gray-200 text-gray-600 hover:bg-green-100 transition-colors text-sm" data-star="2" data-module="1">2星</button>
                <button class="module-star-btn px-3 py-1 rounded border border-gray-200 text-gray-600 hover:bg-green-100 transition-colors text-sm" data-star="3" data-module="1">3星</button>
                <button class="module-star-btn px-3 py-1 rounded border border-gray-200 text-gray-600 hover:bg-green-100 transition-colors text-sm" data-star="4" data-module="1">4星</button>
                <button class="module-star-btn px-3 py-1 rounded border-2 border-green-500 bg-green-500 text-white active text-sm" data-star="5" data-module="1">5星</button>
              </div>
              <span class="text-sm font-semibold text-green-800 ml-6">拼接位置：</span>
              <div class="flex gap-1">
                <button class="position-btn px-2 py-1 border border-gray-300 rounded text-xs hover:bg-gray-100" data-position="1" data-module="1">1名</button>
                <button class="position-btn px-2 py-1 border border-gray-300 rounded text-xs hover:bg-gray-100" data-position="2" data-module="1">2名</button>
                <button class="position-btn px-2 py-1 border border-gray-300 rounded text-xs hover:bg-gray-100" data-position="3" data-module="1">3名</button>
                <button class="position-btn px-2 py-1 border border-gray-300 rounded text-xs hover:bg-gray-100" data-position="4" data-module="1">4名</button>
                <button class="position-btn px-2 py-1 border border-gray-300 rounded text-xs hover:bg-gray-100" data-position="5" data-module="1">5名</button>
              </div>
            </div>
          </div>
          
          <!-- 模块总容错设置 -->
          <div class="module-tolerance mb-4 p-3 bg-gray-50 rounded border">
            <div class="flex items-center text-sm">
              <span class="text-gray-700 font-medium mr-3">总容错：</span>
              <select class="module-tolerance-min border border-gray-300 rounded px-2 py-1 text-xs" data-module="1">
                <option value="0">0</option>
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4">4</option>
                <option value="5">5</option>
              </select>
              <span class="mx-1">-</span>
              <select class="module-tolerance-max border border-gray-300 rounded px-2 py-1 text-xs" data-module="1">
                <option value="0" selected>0</option>
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4">4</option>
                <option value="5">5</option>
              </select>
            </div>
          </div>
          
          <!-- 第1组筛选条件 -->
          <div class="filter-group mb-2 pb-2 border-b">
            <!-- 条件1容错选择器 -->
            <div class="flex items-center mb-2 text-sm">
              <span class="text-gray-600 mr-2">条件1容错</span>
              <select class="condition-tolerance-min border border-gray-300 rounded px-2 py-1 text-xs" data-module="1" data-group="1">
                <option value="0">0</option>
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4">4</option>
                <option value="5">5</option>
              </select>
              <span class="mx-1">至</span>
              <select class="condition-tolerance-max border border-gray-300 rounded px-2 py-1 text-xs" data-module="1" data-group="1">
                <option value="0">0</option>
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4">4</option>
                <option value="5">5</option>
              </select>
            </div>
            <div class="flex flex-wrap gap-2 mb-2 number-buttons">
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="1" data-module="1" data-group="1">01</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="2" data-module="1" data-group="1">02</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="3" data-module="1" data-group="1">03</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="4" data-module="1" data-group="1">04</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="5" data-module="1" data-group="1">05</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="6" data-module="1" data-group="1">06</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="7" data-module="1" data-group="1">07</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="8" data-module="1" data-group="1">08</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="9" data-module="1" data-group="1">09</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="10" data-module="1" data-group="1">10</button>
            </div>
            
            <div class="flex flex-wrap gap-2 mb-0 dama-buttons">
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="0" data-module="1" data-group="1">0胆</button>
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="1" data-module="1" data-group="1">1胆</button>
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="2" data-module="1" data-group="1">2胆</button>
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="3" data-module="1" data-group="1">3胆</button>
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="4" data-module="1" data-group="1">4胆</button>
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="5" data-module="1" data-group="1">5胆</button>
            </div>
          </div>
          
          <!-- 第2组筛选条件 -->
          <div class="filter-group mb-2 pb-2 border-b">
            <!-- 条件2容错选择器 -->
            <div class="flex items-center mb-2 text-sm">
              <span class="text-gray-600 mr-2">条件2容错</span>
              <select class="condition-tolerance-min border border-gray-300 rounded px-2 py-1 text-xs" data-module="1" data-group="2">
                <option value="0">0</option>
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4">4</option>
                <option value="5">5</option>
              </select>
              <span class="mx-1">至</span>
              <select class="condition-tolerance-max border border-gray-300 rounded px-2 py-1 text-xs" data-module="1" data-group="2">
                <option value="0">0</option>
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4">4</option>
                <option value="5">5</option>
              </select>
            </div>
            <div class="flex flex-wrap gap-2 mb-2 number-buttons">
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="1" data-module="1" data-group="2">01</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="2" data-module="1" data-group="2">02</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="3" data-module="1" data-group="2">03</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="4" data-module="1" data-group="2">04</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="5" data-module="1" data-group="2">05</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="6" data-module="1" data-group="2">06</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="7" data-module="1" data-group="2">07</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="8" data-module="1" data-group="2">08</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="9" data-module="1" data-group="2">09</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="10" data-module="1" data-group="2">10</button>
            </div>
            
            <div class="flex flex-wrap gap-2 mb-0 dama-buttons">
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="0" data-module="1" data-group="2">0胆</button>
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="1" data-module="1" data-group="2">1胆</button>
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="2" data-module="1" data-group="2">2胆</button>
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="3" data-module="1" data-group="2">3胆</button>
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="4" data-module="1" data-group="2">4胆</button>
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="5" data-module="1" data-group="2">5胆</button>
            </div>
          </div>
          
          <!-- 第3组筛选条件 -->
          <div class="filter-group mb-2 pb-2 border-b">
            <!-- 条件3容错选择器 -->
            <div class="flex items-center mb-2 text-sm">
              <span class="text-gray-600 mr-2">条件3容错</span>
              <select class="condition-tolerance-min border border-gray-300 rounded px-2 py-1 text-xs" data-module="1" data-group="3">
                <option value="0">0</option>
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4">4</option>
                <option value="5">5</option>
              </select>
              <span class="mx-1">至</span>
              <select class="condition-tolerance-max border border-gray-300 rounded px-2 py-1 text-xs" data-module="1" data-group="3">
                <option value="0">0</option>
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4">4</option>
                <option value="5">5</option>
              </select>
            </div>
            <div class="flex flex-wrap gap-2 mb-2 number-buttons">
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="1" data-module="1" data-group="3">01</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="2" data-module="1" data-group="3">02</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="3" data-module="1" data-group="3">03</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="4" data-module="1" data-group="3">04</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="5" data-module="1" data-group="3">05</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="6" data-module="1" data-group="3">06</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="7" data-module="1" data-group="3">07</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="8" data-module="1" data-group="3">08</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="9" data-module="1" data-group="3">09</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="10" data-module="1" data-group="3">10</button>
            </div>
            
            <div class="flex flex-wrap gap-2 mb-0 dama-buttons">
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="0" data-module="1" data-group="3">0胆</button>
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="1" data-module="1" data-group="3">1胆</button>
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="2" data-module="1" data-group="3">2胆</button>
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="3" data-module="1" data-group="3">3胆</button>
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="4" data-module="1" data-group="3">4胆</button>
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="5" data-module="1" data-group="3">5胆</button>
            </div>
          </div>
          
          <!-- 第4组筛选条件 -->
          <div class="filter-group mb-2 pb-2 border-b">
            <!-- 条件4容错选择器 -->
            <div class="flex items-center mb-2 text-sm">
              <span class="text-gray-600 mr-2">条件4容错</span>
              <select class="condition-tolerance-min border border-gray-300 rounded px-2 py-1 text-xs" data-module="1" data-group="4">
                <option value="0">0</option>
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4">4</option>
                <option value="5">5</option>
              </select>
              <span class="mx-1">至</span>
              <select class="condition-tolerance-max border border-gray-300 rounded px-2 py-1 text-xs" data-module="1" data-group="4">
                <option value="0">0</option>
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4">4</option>
                <option value="5">5</option>
              </select>
            </div>
            <div class="flex flex-wrap gap-2 mb-2 number-buttons">
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="1" data-module="1" data-group="4">01</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="2" data-module="1" data-group="4">02</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="3" data-module="1" data-group="4">03</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="4" data-module="1" data-group="4">04</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="5" data-module="1" data-group="4">05</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="6" data-module="1" data-group="4">06</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="7" data-module="1" data-group="4">07</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="8" data-module="1" data-group="4">08</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="9" data-module="1" data-group="4">09</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="10" data-module="1" data-group="4">10</button>
            </div>
            
            <div class="flex flex-wrap gap-2 mb-0 dama-buttons">
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="0" data-module="1" data-group="4">0胆</button>
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="1" data-module="1" data-group="4">1胆</button>
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="2" data-module="1" data-group="4">2胆</button>
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="3" data-module="1" data-group="4">3胆</button>
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="4" data-module="1" data-group="4">4胆</button>
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="5" data-module="1" data-group="4">5胆</button>
            </div>
          </div>
          
          <!-- 第5组筛选条件 -->
          <div class="filter-group mb-2 pb-2">
            <!-- 条件5容错选择器 -->
            <div class="flex items-center mb-2 text-sm">
              <span class="text-gray-600 mr-2">条件5容错</span>
              <select class="condition-tolerance-min border border-gray-300 rounded px-2 py-1 text-xs" data-module="1" data-group="5">
                <option value="0">0</option>
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4">4</option>
                <option value="5">5</option>
              </select>
              <span class="mx-1">至</span>
              <select class="condition-tolerance-max border border-gray-300 rounded px-2 py-1 text-xs" data-module="1" data-group="5">
                <option value="0">0</option>
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4">4</option>
                <option value="5">5</option>
              </select>
            </div>
            <div class="flex flex-wrap gap-2 mb-2 number-buttons">
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="1" data-module="1" data-group="5">01</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="2" data-module="1" data-group="5">02</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="3" data-module="1" data-group="5">03</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="4" data-module="1" data-group="5">04</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="5" data-module="1" data-group="5">05</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="6" data-module="1" data-group="5">06</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="7" data-module="1" data-group="5">07</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="8" data-module="1" data-group="5">08</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="9" data-module="1" data-group="5">09</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="10" data-module="1" data-group="5">10</button>
            </div>
            
            <div class="flex flex-wrap gap-2 mb-0 dama-buttons">
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="0" data-module="1" data-group="5">0胆</button>
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="1" data-module="1" data-group="5">1胆</button>
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="2" data-module="1" data-group="5">2胆</button>
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="3" data-module="1" data-group="5">3胆</button>
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="4" data-module="1" data-group="5">4胆</button>
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="5" data-module="1" data-group="5">5胆</button>
            </div>
          </div>
          
          <!-- 输入区域 -->
          <div class="mb-2 flex gap-2">
            <textarea placeholder="输入结果" class="result-input flex-1 border border-gray-300 rounded px-3 py-2 text-sm focus:outline-none focus:ring-1 focus:ring-primary" data-module="1" rows="3"></textarea>
            <div class="flex flex-col gap-1">
              <button class="clear-btn px-3 py-1 border border-gray-300 bg-gray-100 hover:bg-gray-200 text-sm rounded" data-module="1">清</button>
              <button class="reverse-btn px-3 py-1 border border-gray-300 bg-gray-100 hover:bg-gray-200 text-sm rounded" data-module="1">反</button>
            </div>
          </div>
          <div class="text-red-500 text-sm mb-4 result-count" data-module="1">共0注</div>
          
          <!-- 操作按钮区域 -->
          <div class="flex gap-2">
            <button class="generate-btn flex-1 bg-blue-600 text-white py-2 rounded hover:bg-blue-700" data-module="1">做号</button>
            <button class="copy-btn flex-1 bg-blue-600 text-white py-2 rounded hover:bg-blue-700" data-module="1">复制</button>
            <button class="verify-btn flex-1 bg-orange-600 text-white py-2 rounded hover:bg-orange-700" data-module="1">验证</button>
            <button onclick="addModule(1)" class="add-btn w-10 bg-green-600 text-white py-2 rounded hover:bg-green-700" data-module="1">+</button>
            <button onclick="removeModule(1)" class="remove-btn w-10 bg-red-600 text-white py-2 rounded hover:bg-red-700" data-module="1">-</button>
          </div>
        </div>
            
            <!-- 右侧卡片 - 模块2 (结构与模块1相同，data-module="2") -->
        <div id="module2" class="border border-gray-200 rounded-lg p-4 five-star-module">
          <!-- 做号星级选择器 -->
          <div class="module-star-selector mb-4 p-3 bg-green-50 rounded border border-green-200">
            <div class="flex items-center space-x-3 mb-3">
              <span class="text-sm font-semibold text-green-800">做号星级：</span>
              <div class="flex space-x-1">
                <button class="module-star-btn px-3 py-1 rounded border border-gray-200 text-gray-600 hover:bg-green-100 transition-colors text-sm" data-star="2" data-module="2">2星</button>
                <button class="module-star-btn px-3 py-1 rounded border border-gray-200 text-gray-600 hover:bg-green-100 transition-colors text-sm" data-star="3" data-module="2">3星</button>
                <button class="module-star-btn px-3 py-1 rounded border border-gray-200 text-gray-600 hover:bg-green-100 transition-colors text-sm" data-star="4" data-module="2">4星</button>
                <button class="module-star-btn px-3 py-1 rounded border-2 border-green-500 bg-green-500 text-white active text-sm" data-star="5" data-module="2">5星</button>
              </div>
              <span class="text-sm font-semibold text-green-800 ml-6">拼接位置：</span>
              <div class="flex gap-1">
                <button class="position-btn px-2 py-1 border border-gray-300 rounded text-xs hover:bg-gray-100" data-position="1" data-module="2">1名</button>
                <button class="position-btn px-2 py-1 border border-gray-300 rounded text-xs hover:bg-gray-100" data-position="2" data-module="2">2名</button>
                <button class="position-btn px-2 py-1 border border-gray-300 rounded text-xs hover:bg-gray-100" data-position="3" data-module="2">3名</button>
                <button class="position-btn px-2 py-1 border border-gray-300 rounded text-xs hover:bg-gray-100" data-position="4" data-module="2">4名</button>
                <button class="position-btn px-2 py-1 border border-gray-300 rounded text-xs hover:bg-gray-100" data-position="5" data-module="2">5名</button>
              </div>
            </div>
          </div>
          
          <!-- 模块总容错设置 -->
          <div class="module-tolerance mb-4 p-3 bg-gray-50 rounded border">
            <div class="flex items-center text-sm">
              <span class="text-gray-700 font-medium mr-3">总容错：</span>
              <select class="module-tolerance-min border border-gray-300 rounded px-2 py-1 text-xs" data-module="2">
                <option value="0">0</option>
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4">4</option>
                <option value="5">5</option>
              </select>
              <span class="mx-1">-</span>
              <select class="module-tolerance-max border border-gray-300 rounded px-2 py-1 text-xs" data-module="2">
                <option value="0" selected>0</option>
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4">4</option>
                <option value="5">5</option>
              </select>
            </div>
          </div>
          
          <!-- 第1组筛选条件 -->
          <div class="filter-group mb-2 pb-2 border-b">
            <!-- 条件1容错选择器 -->
            <div class="flex items-center mb-2 text-sm">
              <span class="text-gray-600 mr-2">条件1容错</span>
              <select class="condition-tolerance-min border border-gray-300 rounded px-2 py-1 text-xs" data-module="2" data-group="1">
                <option value="0">0</option>
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4">4</option>
                <option value="5">5</option>
              </select>
              <span class="mx-1">至</span>
              <select class="condition-tolerance-max border border-gray-300 rounded px-2 py-1 text-xs" data-module="2" data-group="1">
                <option value="0">0</option>
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4">4</option>
                <option value="5">5</option>
              </select>
            </div>
            <div class="flex flex-wrap gap-2 mb-2 number-buttons">
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="1" data-module="2" data-group="1">01</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="2" data-module="2" data-group="1">02</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="3" data-module="2" data-group="1">03</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="4" data-module="2" data-group="1">04</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="5" data-module="2" data-group="1">05</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="6" data-module="2" data-group="1">06</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="7" data-module="2" data-group="1">07</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="8" data-module="2" data-group="1">08</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="9" data-module="2" data-group="1">09</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="10" data-module="2" data-group="1">10</button>
            </div>
            
            <div class="flex flex-wrap gap-2 mb-0 dama-buttons">
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="0" data-module="2" data-group="1">0胆</button>
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="1" data-module="2" data-group="1">1胆</button>
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="2" data-module="2" data-group="1">2胆</button>
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="3" data-module="2" data-group="1">3胆</button>
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="4" data-module="2" data-group="1">4胆</button>
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="5" data-module="2" data-group="1">5胆</button>
            </div>
          </div>
          
          <!-- 第2组筛选条件 -->
          <div class="filter-group mb-2 pb-2 border-b">
            <!-- 条件2容错选择器 -->
            <div class="flex items-center mb-2 text-sm">
              <span class="text-gray-600 mr-2">条件2容错</span>
              <select class="condition-tolerance-min border border-gray-300 rounded px-2 py-1 text-xs" data-module="2" data-group="2">
                <option value="0">0</option>
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4">4</option>
                <option value="5">5</option>
              </select>
              <span class="mx-1">至</span>
              <select class="condition-tolerance-max border border-gray-300 rounded px-2 py-1 text-xs" data-module="2" data-group="2">
                <option value="0">0</option>
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4">4</option>
                <option value="5">5</option>
              </select>
            </div>
            <div class="flex flex-wrap gap-2 mb-2 number-buttons">
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="1" data-module="2" data-group="2">01</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="2" data-module="2" data-group="2">02</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="3" data-module="2" data-group="2">03</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="4" data-module="2" data-group="2">04</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="5" data-module="2" data-group="2">05</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="6" data-module="2" data-group="2">06</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="7" data-module="2" data-group="2">07</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="8" data-module="2" data-group="2">08</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="9" data-module="2" data-group="2">09</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="10" data-module="2" data-group="2">10</button>
            </div>
            
            <div class="flex flex-wrap gap-2 mb-0 dama-buttons">
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="0" data-module="2" data-group="2">0胆</button>
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="1" data-module="2" data-group="2">1胆</button>
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="2" data-module="2" data-group="2">2胆</button>
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="3" data-module="2" data-group="2">3胆</button>
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="4" data-module="2" data-group="2">4胆</button>
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="5" data-module="2" data-group="2">5胆</button>
            </div>
          </div>
          
          <!-- 第3组筛选条件 -->
          <div class="filter-group mb-2 pb-2 border-b">
            <!-- 条件3容错选择器 -->
            <div class="flex items-center mb-2 text-sm">
              <span class="text-gray-600 mr-2">条件3容错</span>
              <select class="condition-tolerance-min border border-gray-300 rounded px-2 py-1 text-xs" data-module="2" data-group="3">
                <option value="0">0</option>
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4">4</option>
                <option value="5">5</option>
              </select>
              <span class="mx-1">至</span>
              <select class="condition-tolerance-max border border-gray-300 rounded px-2 py-1 text-xs" data-module="2" data-group="3">
                <option value="0">0</option>
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4">4</option>
                <option value="5">5</option>
              </select>
            </div>
            <div class="flex flex-wrap gap-2 mb-2 number-buttons">
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="1" data-module="2" data-group="3">01</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="2" data-module="2" data-group="3">02</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="3" data-module="2" data-group="3">03</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="4" data-module="2" data-group="3">04</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="5" data-module="2" data-group="3">05</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="6" data-module="2" data-group="3">06</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="7" data-module="2" data-group="3">07</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="8" data-module="2" data-group="3">08</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="9" data-module="2" data-group="3">09</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="10" data-module="2" data-group="3">10</button>
            </div>
            
            <div class="flex flex-wrap gap-2 mb-0 dama-buttons">
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="0" data-module="2" data-group="3">0胆</button>
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="1" data-module="2" data-group="3">1胆</button>
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="2" data-module="2" data-group="3">2胆</button>
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="3" data-module="2" data-group="3">3胆</button>
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="4" data-module="2" data-group="3">4胆</button>
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="5" data-module="2" data-group="3">5胆</button>
            </div>
          </div>
          
          <!-- 第4组筛选条件 -->
          <div class="filter-group mb-2 pb-2 border-b">
            <!-- 条件4容错选择器 -->
            <div class="flex items-center mb-2 text-sm">
              <span class="text-gray-600 mr-2">条件4容错</span>
              <select class="condition-tolerance-min border border-gray-300 rounded px-2 py-1 text-xs" data-module="2" data-group="4">
                <option value="0">0</option>
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4">4</option>
                <option value="5">5</option>
              </select>
              <span class="mx-1">至</span>
              <select class="condition-tolerance-max border border-gray-300 rounded px-2 py-1 text-xs" data-module="2" data-group="4">
                <option value="0">0</option>
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4">4</option>
                <option value="5">5</option>
              </select>
            </div>
            <div class="flex flex-wrap gap-2 mb-2 number-buttons">
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="1" data-module="2" data-group="4">01</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="2" data-module="2" data-group="4">02</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="3" data-module="2" data-group="4">03</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="4" data-module="2" data-group="4">04</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="5" data-module="2" data-group="4">05</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="6" data-module="2" data-group="4">06</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="7" data-module="2" data-group="4">07</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="8" data-module="2" data-group="4">08</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="9" data-module="2" data-group="4">09</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="10" data-module="2" data-group="4">10</button>
            </div>
            
            <div class="flex flex-wrap gap-2 mb-0 dama-buttons">
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="0" data-module="2" data-group="4">0胆</button>
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="1" data-module="2" data-group="4">1胆</button>
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="2" data-module="2" data-group="4">2胆</button>
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="3" data-module="2" data-group="4">3胆</button>
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="4" data-module="2" data-group="4">4胆</button>
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="5" data-module="2" data-group="4">5胆</button>
            </div>
          </div>
          
          <!-- 第5组筛选条件 -->
          <div class="filter-group mb-2 pb-0">
            <!-- 条件5容错选择器 -->
            <div class="flex items-center mb-2 text-sm">
              <span class="text-gray-600 mr-2">条件5容错</span>
              <select class="condition-tolerance-min border border-gray-300 rounded px-2 py-1 text-xs" data-module="2" data-group="5">
                <option value="0">0</option>
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4">4</option>
                <option value="5">5</option>
              </select>
              <span class="mx-1">至</span>
              <select class="condition-tolerance-max border border-gray-300 rounded px-2 py-1 text-xs" data-module="2" data-group="5">
                <option value="0">0</option>
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4">4</option>
                <option value="5">5</option>
              </select>
            </div>
            <div class="flex flex-wrap gap-2 mb-2 number-buttons">
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="1" data-module="2" data-group="5">01</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="2" data-module="2" data-group="5">02</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="3" data-module="2" data-group="5">03</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="4" data-module="2" data-group="5">04</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="5" data-module="2" data-group="5">05</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="6" data-module="2" data-group="5">06</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="7" data-module="2" data-group="5">07</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="8" data-module="2" data-group="5">08</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="9" data-module="2" data-group="5">09</button>
              <button class="number-btn w-10 h-10 border border-gray-300 rounded flex items-center justify-center text-sm" data-number="10" data-module="2" data-group="5">10</button>
            </div>
            
            <div class="flex flex-wrap gap-2 mb-0 dama-buttons">
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="0" data-module="2" data-group="5">0胆</button>
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="1" data-module="2" data-group="5">1胆</button>
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="2" data-module="2" data-group="5">2胆</button>
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="3" data-module="2" data-group="5">3胆</button>
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="4" data-module="2" data-group="5">4胆</button>
              <button class="dama-btn px-3 py-1 border border-gray-300 rounded text-sm" data-dama="5" data-module="2" data-group="5">5胆</button>
            </div>
          </div>
          
          <!-- module2 输入区域和操作按钮区域与module1相同 -->
          <div class="mb-2 flex gap-2">
            <textarea placeholder="输入结果" class="result-input flex-1 border border-gray-300 rounded px-3 py-2 text-sm focus:outline-none focus:ring-1 focus:ring-primary" data-module="2" rows="3"></textarea>
            <div class="flex flex-col gap-1">
              <button class="clear-btn px-3 py-1 border border-gray-300 bg-gray-100 hover:bg-gray-200 text-sm rounded" data-module="2">清</button>
              <button class="reverse-btn px-3 py-1 border border-gray-300 bg-gray-100 hover:bg-gray-200 text-sm rounded" data-module="2">反</button>
            </div>
          </div>
          <div class="text-red-500 text-sm mb-4 result-count" data-module="2">共0注</div>
          
          <div class="flex gap-2">
            <button class="generate-btn flex-1 bg-blue-600 text-white py-2 rounded hover:bg-blue-700" data-module="2">做号</button>
            <button class="copy-btn flex-1 bg-blue-600 text-white py-2 rounded hover:bg-blue-700" data-module="2">复制</button>
            <button class="verify-btn flex-1 bg-orange-600 text-white py-2 rounded hover:bg-orange-700" data-module="2">验证</button>
            <button onclick="addModule(2)" class="add-btn w-10 bg-green-600 text-white py-2 rounded hover:bg-green-700" data-module="2">+</button>
            <button onclick="removeModule(2)" class="remove-btn w-10 bg-red-600 text-white py-2 rounded hover:bg-red-700" data-module="2">-</button>
          </div>
        </div>
          </div>
        </div>
      </div>
    </div>

    <!-- 黄金分割页面 -->
    <div id="goldenRatioPage" class="hidden">
      <div class="container mx-auto px-4 py-6">
        <div class="bg-white rounded-lg shadow-lg p-6">
          <!-- 切割模式选择 -->
          <div class="mb-6">
            <div class="flex justify-center gap-3 mb-4">
              <button 
                id="modeUniformBtn" 
                class="px-6 py-2 bg-blue-500 text-white font-medium rounded-md hover:bg-blue-600 transition-colors active-mode"
                data-mode="uniform"
              >均匀</button>
              <button 
                id="modeStableBtn" 
                class="px-6 py-2 bg-gray-300 text-gray-700 font-medium rounded-md hover:bg-gray-400 transition-colors"
                data-mode="stable"
              >稳定</button>
            </div>
            <div class="text-center text-sm text-gray-600 mb-4">
              <span id="modeDescription">均匀模式：一次性分完就用，不保持历史分组</span>
            </div>
          </div>
          
          <!-- 输入区域 -->
          <div class="mb-6">
            <label for="goldenInputData" class="block text-sm font-medium text-gray-700 mb-2">请输入数据 <span id="goldenInputCount" class="text-red-500 text-sm font-medium hidden">共 0 项</span></label>
            <textarea 
              id="goldenInputData" 
              rows="6" 
              placeholder="示例：01,02,03,04,05,06,07,08,09,10" 
              class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent resize-none overflow-auto whitespace-pre-wrap"
            ></textarea>
          </div>
          
          <!-- 操作按钮 -->
          <div class="flex justify-center gap-3 mb-6">
            <button 
              id="goldenSplitBtn" 
              class="px-6 py-2 bg-primary text-white font-medium rounded-md hover:bg-primary/80 transition-colors"
            >开始分割</button>
            <button 
              id="goldenPasteBtn" 
              class="px-6 py-2 bg-green-500 text-white font-medium rounded-md hover:bg-green-600 transition-colors"
            >粘贴数据</button>
            <button 
              id="goldenClearBtn" 
              class="px-6 py-2 bg-gray-500 text-white font-medium rounded-md hover:bg-gray-600 transition-colors"
            >清空</button>
          </div>
          
          <!-- 结果显示区域 -->
          <div class="mb-6">
            <div class="flex items-center justify-between mb-4">
              <h3 class="text-lg font-semibold text-gray-800">分割结果</h3>
              <div class="text-sm text-gray-500" id="resultSummary"></div>
            </div>
            
            <!-- 5个紧凑排列的框 -->
            <div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-5 gap-2">
              <div id="goldenResults" class="col-span-full grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-5 gap-2">
                <!-- 5个分组结果将在这里动态生成 -->
              </div>
            </div>
          </div>
          
          <!-- 验证结果显示 -->
          <div id="validationResults" class="mt-6 p-4 bg-gray-50 rounded-md hidden">
            <h3 class="text-lg font-semibold mb-2">5in4验证结果</h3>
            <div id="validationContent"></div>
          </div>
        </div>
      </div>
    </div>

    <!-- 交集拼接页面 -->
    <div id="intersectionCutPage" class="hidden">
      <div class="container mx-auto px-4 py-6 max-w-6xl">




        <!-- 号码交集功能区域 -->
        <div id="intersectionContent" class="intersection-content">
          <!-- 容错功能区域 -->
          <div class="bg-white rounded-lg shadow-sm p-4 mb-4">
            <h3 class="text-lg font-medium text-gray-800 mb-3">容错设置</h3>
            <div class="flex flex-wrap gap-2">
              <button class="tolerance-btn" data-tolerance="1">1</button>
              <button class="tolerance-btn" data-tolerance="2">2</button>
              <button class="tolerance-btn" data-tolerance="3">3</button>
              <button class="tolerance-btn" data-tolerance="4">4</button>
              <button class="tolerance-btn" data-tolerance="5">5</button>
              <button class="tolerance-btn" data-tolerance="6">6</button>
              <button class="tolerance-btn" data-tolerance="7">7</button>
              <button class="tolerance-btn" data-tolerance="8">8</button>
            </div>
          </div>

          <!-- 结果显示区域 -->
          <div class="bg-white rounded-lg shadow-sm p-4 mb-4">
            <h3 class="text-lg font-medium text-gray-800 mb-3">结果显示</h3>
            <div class="flex gap-3 items-start">
              <div class="flex-1">
                <textarea id="resultDisplay" rows="4" 
                  class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 resize-none"
                  placeholder="交集结果将显示在这里..." readonly></textarea>
              </div>
              <div class="flex flex-col gap-2">
                <button id="generateIntersectionBtn" class="px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 transition-colors font-medium">
                  做号
                </button>
                <button id="copyResultBtn" class="px-4 py-2 bg-green-500 text-white rounded-md hover:bg-green-600 transition-colors font-medium">
                  复制
                </button>
              </div>
            </div>
            <div class="mt-2 text-sm text-gray-600">
              <span id="resultCount">共0注</span>
            </div>
          </div>

          <!-- 输入模块区域 -->
          <div class="bg-white rounded-lg shadow-sm p-4">
            <h3 class="text-lg font-medium text-gray-800 mb-3">输入模块</h3>
            
            <!-- 8个输入模块的可滚动容器 -->
            <div class="modules-container max-h-96 overflow-y-auto border border-gray-200 rounded-lg p-4">
              <div class="modules-grid grid grid-cols-1 md:grid-cols-2 gap-4">
                <!-- 模块1 -->
                <div class="input-module">
                  <div class="module-header">
                    <div class="module-info">
                      <h4 class="module-title">模块1</h4>
                      <span class="module-count" data-module="1">0注</span>
                    </div>
                    <div class="module-actions">
                      <button class="module-btn paste-btn" data-module="1">
                        粘贴
                      </button>
                      <button class="module-btn clear-btn" data-module="1">
                        清除
                      </button>
                    </div>
                  </div>
                  <textarea class="module-textarea" 
                    rows="3" placeholder="请输入多组号码，每行一组，如：01,02,03" data-module="1"></textarea>
                </div>

                <!-- 模块2 -->
                <div class="input-module">
                  <div class="module-header">
                    <div class="module-info">
                      <h4 class="module-title">模块2</h4>
                      <span class="module-count" data-module="2">0注</span>
                    </div>
                    <div class="module-actions">
                      <button class="module-btn paste-btn" data-module="2">
                        粘贴
                      </button>
                      <button class="module-btn clear-btn" data-module="2">
                        清除
                      </button>
                    </div>
                  </div>
                  <textarea class="module-textarea" 
                    rows="3" placeholder="请输入多组号码，每行一组，如：01,02,03" data-module="2"></textarea>
                </div>

                <!-- 模块3 -->
                <div class="input-module">
                  <div class="module-header">
                    <div class="module-info">
                      <h4 class="module-title">模块3</h4>
                      <span class="module-count" data-module="3">0注</span>
                    </div>
                    <div class="module-actions">
                      <button class="module-btn paste-btn" data-module="3">
                        粘贴
                      </button>
                      <button class="module-btn clear-btn" data-module="3">
                        清除
                      </button>
                    </div>
                  </div>
                  <textarea class="module-textarea" 
                    rows="3" placeholder="请输入多组号码，每行一组，如：01,02,03" data-module="3"></textarea>
                </div>

                <!-- 模块4 -->
                <div class="input-module">
                  <div class="module-header">
                    <div class="module-info">
                      <h4 class="module-title">模块4</h4>
                      <span class="module-count" data-module="4">0注</span>
                    </div>
                    <div class="module-actions">
                      <button class="module-btn paste-btn" data-module="4">
                        粘贴
                      </button>
                      <button class="module-btn clear-btn" data-module="4">
                        清除
                      </button>
                    </div>
                  </div>
                  <textarea class="module-textarea" 
                    rows="3" placeholder="请输入多组号码，每行一组，如：01,02,03" data-module="4"></textarea>
                </div>

                <!-- 模块5 -->
                <div class="input-module">
                  <div class="module-header">
                    <div class="module-info">
                      <h4 class="module-title">模块5</h4>
                      <span class="module-count" data-module="5">0注</span>
                    </div>
                    <div class="module-actions">
                      <button class="module-btn paste-btn" data-module="5">
                        粘贴
                      </button>
                      <button class="module-btn clear-btn" data-module="5">
                        清除
                      </button>
                    </div>
                  </div>
                  <textarea class="module-textarea" 
                    rows="3" placeholder="请输入多组号码，每行一组，如：01,02,03" data-module="5"></textarea>
                </div>

                <!-- 模块6 -->
                <div class="input-module">
                  <div class="module-header">
                    <div class="module-info">
                      <h4 class="module-title">模块6</h4>
                      <span class="module-count" data-module="6">0注</span>
                    </div>
                    <div class="module-actions">
                      <button class="module-btn paste-btn" data-module="6">
                        粘贴
                      </button>
                      <button class="module-btn clear-btn" data-module="6">
                        清除
                      </button>
                    </div>
                  </div>
                  <textarea class="module-textarea" 
                    rows="3" placeholder="请输入多组号码，每行一组，如：01,02,03" data-module="6"></textarea>
                </div>

                <!-- 模块7 -->
                <div class="input-module">
                  <div class="module-header">
                    <div class="module-info">
                      <h4 class="module-title">模块7</h4>
                      <span class="module-count" data-module="7">0注</span>
                    </div>
                    <div class="module-actions">
                      <button class="module-btn paste-btn" data-module="7">
                        粘贴
                      </button>
                      <button class="module-btn clear-btn" data-module="7">
                        清除
                      </button>
                    </div>
                  </div>
                  <textarea class="module-textarea" 
                    rows="3" placeholder="请输入多组号码，每行一组，如：01,02,03" data-module="7"></textarea>
                </div>

                <!-- 模块8 -->
                <div class="input-module">
                  <div class="module-header">
                    <div class="module-info">
                      <h4 class="module-title">模块8</h4>
                      <span class="module-count" data-module="8">0注</span>
                    </div>
                    <div class="module-actions">
                      <button class="module-btn paste-btn" data-module="8">
                        粘贴
                      </button>
                      <button class="module-btn clear-btn" data-module="8">
                        清除
                      </button>
                    </div>
                  </div>
                  <textarea class="module-textarea" 
                    rows="3" placeholder="请输入多组号码，每行一组，如：01,02,03" data-module="8"></textarea>
                </div>
              </div>
            </div>
          </div>
        </div>


      </div>
    </div>

    <!-- 验证计划页面 -->
    <div id="verifyPlanPage" class="hidden">
      <div class="container mx-auto px-4 py-6">
        <div class="bg-white rounded-lg shadow-lg p-6">
          <h2 class="text-2xl font-bold text-gray-800 mb-6">验证计划</h2>
          

          
          <!-- 验证模式切换按钮组 -->
          <div class="mb-4 p-4 bg-gray-50 rounded-lg">
            <div class="flex items-center justify-between">
              <div class="flex items-center gap-4">
                <span class="text-sm font-medium text-gray-700">验证模式:</span>
                <div class="flex bg-white rounded-lg border border-gray-300 overflow-hidden">
                  <button id="multiPeriodModeBtn" class="px-4 py-2 bg-gray-100 text-gray-700 text-sm font-medium transition-colors hover:bg-gray-200">
                    多期验证
                  </button>
                  <button id="singlePeriodModeBtn" class="px-4 py-2 bg-blue-500 text-white text-sm font-medium transition-colors hover:bg-blue-600">
                              单期验证
                  </button>
                </div>
              </div>
              <div class="flex items-center gap-3">
                <button id="pasteAndVerifyBtn" class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors">
                  粘贴并验证
                </button>
                <div class="text-sm text-gray-500">
                  <span id="verifyDataCount">共 0 条记录</span>
                </div>
              </div>
            </div>
          </div>

          <!-- 计划验证历史管理 -->
          <div id="planHistoryControls" class="mb-4 p-4 bg-blue-50 rounded-lg border border-blue-200" style="display: none;">
            <div class="flex flex-wrap items-center gap-4 justify-between">
              <div class="flex items-center gap-2">
                <span class="text-sm font-medium text-blue-700">计划验证历史:</span>
                <span id="historyCount" class="text-sm text-blue-600">已保存 0 条记录</span>
              </div>
              <div class="flex items-center gap-2">
                <button id="exportHistoryBtn" class="px-3 py-1 bg-green-500 text-white text-sm rounded hover:bg-green-600 transition-colors">
                  导出历史
                </button>
                <button id="importHistoryBtn" class="px-3 py-1 bg-blue-500 text-white text-sm rounded hover:bg-blue-600 transition-colors">
                  导入历史
                </button>
                <button id="clearHistoryBtn" class="px-3 py-1 bg-red-500 text-white text-sm rounded hover:bg-red-600 transition-colors">
                  清空历史
                </button>
                <input type="file" id="importFileInput" accept=".json" style="display: none;">
              </div>
            </div>
          </div>

          <!-- 期数选择控件 -->
          <div class="mb-6 p-4 bg-gray-50 rounded-lg">
            <div class="flex flex-wrap items-center gap-4 justify-between">
              <div class="flex flex-wrap items-center gap-4">
                <span class="text-sm font-medium text-gray-700">显示期数:</span>
                <div class="flex gap-2">
                  <button id="periods15Btn" class="periods-btn px-3 py-1 bg-blue-500 text-white text-sm rounded hover:bg-blue-600 transition-colors" data-periods="15" onclick="selectPeriods(15)">
                    15期
                  </button>
                  <button id="periods30Btn" class="periods-btn px-3 py-1 bg-gray-300 text-gray-700 text-sm rounded hover:bg-gray-400 transition-colors" data-periods="30" onclick="selectPeriods(30)">
                    30期
                  </button>
                  <button id="periods50Btn" class="periods-btn px-3 py-1 bg-gray-300 text-gray-700 text-sm rounded hover:bg-gray-400 transition-colors" data-periods="50" onclick="selectPeriods(50)">
                    50期
                  </button>
                </div>
                <div class="flex items-center gap-2">
                  <span class="text-sm text-gray-600">自定义:</span>
                  <input type="number" id="customPeriodsInput" class="w-20 px-2 py-1 text-sm border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500" min="1" max="200" placeholder="期数">
                  <button id="customPeriodsBtn" class="px-3 py-1 bg-green-500 text-white text-sm rounded hover:bg-green-600 transition-colors" onclick="setCustomPeriods()">
                    确定
                  </button>
                </div>
              </div>
              <div class="text-sm text-gray-500" id="verifyLastUpdate">
                最后更新: --
              </div>
            </div>
          </div>

          <!-- 验证计划表格 -->
          <div class="overflow-x-auto">
            <!-- 多期验证模式表格 -->
            <div id="multiPeriodTable" class="table-container hidden" style="max-height: 600px; overflow-y: auto; border: 1px solid #e5e7eb;">
              <table id="verifyPlanTable" class="w-full border-collapse">
                <thead>
                  <!-- 表头将由JavaScript动态生成 -->
                </thead>
                <tbody id="verifyPlanTableBody">
                  <!-- 数据行将在这里动态生成 -->
                  <tr>
                    <td colspan="100" class="py-4 text-center text-gray-500">
                      暂无数据，请先在数据分析页面加载数据
                    </td>
                  </tr>
                </tbody>
              </table>
            </div>
            
            <!-- 下一期验证模式表格 -->
            <div id="singlePeriodTable" class="table-container" style="max-height: 600px; overflow-y: auto; border: 1px solid #e5e7eb;">
              <table id="singlePeriodVerifyTable" class="w-full border-collapse">
                <thead id="singlePeriodTableHead">
                  <tr class="bg-gray-50">
                    <th class="border border-gray-300 px-2 py-2 text-center text-sm font-medium text-gray-700" style="width: 130px;">期号</th>
                    <th class="border border-gray-300 px-3 py-2 text-center text-sm font-medium text-gray-700" style="width: 260px;">开奖号码</th>
                    <th class="border border-gray-300 px-3 py-2 text-center text-sm font-medium text-gray-700" style="width: 104px;">注数</th>
                    <th class="border border-gray-300 px-3 py-2 text-center text-sm font-medium text-gray-700" style="width: 80px;">状态</th>
                    <th class="border border-gray-300 px-3 py-2 text-center text-sm font-medium text-gray-700">计划规则</th>
                    <th class="border border-gray-300 px-3 py-2 text-center text-sm font-medium text-gray-700" style="width: 104px;">操作</th>
                  </tr>
                </thead>
                <tbody id="singlePeriodTableBody">
                  <tr>
                    <td colspan="6" class="py-4 text-center text-gray-500">
                      暂无数据，请先在数据分析页面加载数据
                    </td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>

          <!-- 分页控件 -->
          <div id="paginationControls" class="flex items-center justify-between mt-4 p-4 bg-gray-50 rounded-lg">
            <div class="flex items-center gap-2">
              <button id="prevPageBtn" class="px-3 py-1 bg-gray-300 text-gray-700 text-sm rounded hover:bg-gray-400 transition-colors disabled:opacity-50 disabled:cursor-not-allowed" onclick="previousPage()" disabled>
                上一页
              </button>
              <span id="paginationInfo" class="text-sm text-gray-600">第 1 页，共 1 页</span>
              <button id="nextPageBtn" class="px-3 py-1 bg-gray-300 text-gray-700 text-sm rounded hover:bg-gray-400 transition-colors disabled:opacity-50 disabled:cursor-not-allowed" onclick="nextPage()" disabled>
                下一页
              </button>
            </div>
            <div class="text-sm text-gray-500">
              <span id="displayInfo">显示第 1-0 条，共 0 条记录</span>
            </div>
          </div>

        </div>
      </div>
    </div>

  </main>

  <!-- 页脚 -->
  <footer class="bg-white border-t border-gray-200 py-4">
    <div class="container mx-auto px-4 text-center text-gray-500 text-sm">
      <p>台湾PK数据分析工具 © 2025，联系✈️@suibian925</p>
    </div>
  </footer>



  <!-- 密钥验证模态框 -->
  <div id="keyModal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center" style="z-index: 9999;">
    <div class="bg-white rounded-lg shadow-xl w-full max-w-md p-6">
      <div class="text-center mb-6">
        <h3 class="text-2xl font-bold text-gray-800 mb-2">请输入访问密钥</h3>
        <p class="text-gray-600">该功能需要有效的访问密钥才能使用</p>
      </div>
      
      <div class="mb-4">
        <input type="text" id="keyInput" placeholder="请输入32位访问密钥" class="w-full px-4 py-3 rounded-md border border-gray-300 focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary transition-all duration-200">
      </div>
      
      <div class="flex gap-3">
        <button id="verifyKeyBtn" class="w-full px-4 py-3 bg-primary text-white rounded-md font-medium hover:bg-primary/80 transition-colors">验证密钥</button>
        <!-- 移除取消按钮 -->
      </div>
    </div>
  </div>

  

<script>
// 全局模块状态存储
window.moduleStates = {};

// 添加模块功能
function addModule(currentModuleId) {
  const modulesContainer = document.getElementById('modules-container');
  const moduleElements = modulesContainer.querySelectorAll('.five-star-module');

  // 检查模块数量上限（最多14个）
  if (moduleElements.length >= 14) {
    alert('最多只能添加14个模块');
    return;
  }

  // 获取最后一个模块ID并递增
  const lastModuleId = parseInt(moduleElements[moduleElements.length - 1].id.replace('module', ''));
  const newModuleId = lastModuleId + 1;

  // 克隆当前模块
  const currentModule = document.getElementById(`module${currentModuleId}`);
  const newModule = currentModule.cloneNode(true);
  newModule.id = `module${newModuleId}`;
  newModule.querySelectorAll('[data-module]').forEach(el => {
    el.dataset.module = newModuleId;
  });
  resetModuleState(newModule);

  // 克隆当前模块后添加以下代码
  const newAddBtn = newModule.querySelector('.add-btn');
  newAddBtn.setAttribute('onclick', `addModule(${newModuleId})`);

  const newRemoveBtn = newModule.querySelector('.remove-btn');
  newRemoveBtn.setAttribute('onclick', `removeModule(${newModuleId})`);

  // 直接添加到模块容器末尾
  modulesContainer.appendChild(newModule);

  // 初始化新模块
  initFiveStarModule(newModuleId);
}

// 移除单个模块 - 确保最少保留2个
function removeModule(moduleId) {
  const modulesContainer = document.getElementById('modules-container');
  const moduleElements = modulesContainer.querySelectorAll('.five-star-module');
  const moduleToRemove = document.getElementById(`module${moduleId}`);

  // 确保至少保留2个模块
  if (moduleElements.length <= 2) {
    alert('至少保留2个模块');
    return;
  }

  // 移除模块
  moduleToRemove.remove();
}

// 重置模块状态的辅助函数
function resetModuleState(module) {
  // 清除克隆模块的选中状态和结果
  module.querySelectorAll('.number-btn, .dama-btn').forEach(btn => {
    btn.classList.remove('bg-primary', 'text-white');
  });
  module.querySelector('.result-input').value = '';
  module.querySelector('.result-count').textContent = '共0注';
}

// 生成排列组合的函数 - 迭代版本避免栈溢出
function permute(arr, k) {
  if (k === 0) return [[]];
  if (k === 1) return arr.map(x => [x]);
  
  const result = [];
  const stack = [{ current: [], remaining: arr, depth: 0 }];
  
  while (stack.length > 0) {
    const { current, remaining, depth } = stack.pop();
    
    if (depth === k) {
      result.push([...current]);
      continue;
    }
    
    for (let i = 0; i < remaining.length; i++) {
      const newCurrent = [...current, remaining[i]];
      const newRemaining = remaining.slice(0, i).concat(remaining.slice(i + 1));
      stack.push({ current: newCurrent, remaining: newRemaining, depth: depth + 1 });
    }
  }
  
  return result;
}

// 生成数组的所有排列
function generatePermutations(arr) {
  if (arr.length <= 1) return [arr];
  
  const result = [];
  for (let i = 0; i < arr.length; i++) {
    const current = arr[i];
    const remaining = arr.slice(0, i).concat(arr.slice(i + 1));
    const perms = generatePermutations(remaining);
    
    for (const perm of perms) {
      result.push([current, ...perm]);
    }
  }
  
  return result;
}

// 生成指定长度的排列
function generatePermutationsWithLength(arr, length) {
  if (length === 0) return [[]];
  if (length > arr.length) return [];
  if (length === 1) return arr.map(item => [item]);
  
  const result = [];
  for (let i = 0; i < arr.length; i++) {
    const current = arr[i];
    const remaining = arr.slice(0, i).concat(arr.slice(i + 1));
    const perms = generatePermutationsWithLength(remaining, length - 1);
    
    for (const perm of perms) {
      result.push([current, ...perm]);
    }
  }
  
  return result;
}

// 初始化五星模块
function initFiveStarModule(moduleId) {
  // 防止重复初始化
  if (window.moduleStates && window.moduleStates[moduleId]) {
    console.log(`模块${moduleId}已经初始化过，跳过重复初始化`);
    return;
  }
  
  // 确保全局状态对象存在
  if (!window.moduleStates) {
    window.moduleStates = {};
  }
  
  // 模块状态存储 - 修改为按组存储条件，每个条件组有独立的容错设置
  const moduleState = window.moduleStates[moduleId] = {
    groups: [
        { selectedNumbers: [], selectedDamas: [], toleranceMin: 0, toleranceMax: 0 }, // 组1
        { selectedNumbers: [], selectedDamas: [], toleranceMin: 0, toleranceMax: 0 }, // 组2
        { selectedNumbers: [], selectedDamas: [], toleranceMin: 0, toleranceMax: 0 }, // 组3
        { selectedNumbers: [], selectedDamas: [], toleranceMin: 0, toleranceMax: 0 }, // 组4
        { selectedNumbers: [], selectedDamas: [], toleranceMin: 0, toleranceMax: 0 }  // 组5
    ],
    // 模块总容错设置
    moduleToleranceMin: 0,  // 允许最少多少个条件不成立
    moduleToleranceMax: 0,  // 允许最多多少个条件不成立
    starLevel: 5,        // 当前选择的星级，默认5星
    selectedPositions: [], // 选中的位置（1名-5名）
    results: [],         // 当前显示结果
    allPermutations: [], // 所有排列组合
    originalResults: [], // 原始筛选结果
    isReversed: false    // 是否显示反向结果
  };

  // 获取模块元素
  const module = document.getElementById(`module${moduleId}`);
  const numberButtons = module.querySelectorAll('.number-btn');
  const damaButtons = module.querySelectorAll('.dama-btn');
  const generateBtn = module.querySelector('.generate-btn');
  const copyBtn = module.querySelector('.copy-btn');
  const verifyBtn = module.querySelector('.verify-btn');
  const clearBtn = module.querySelector('.clear-btn');
  const reverseBtn = module.querySelector('.reverse-btn');
  const resultInput = module.querySelector('.result-input');
  const resultCount = module.querySelector('.result-count');
  const conditionToleranceMinSelects = module.querySelectorAll('.condition-tolerance-min');
  const conditionToleranceMaxSelects = module.querySelectorAll('.condition-tolerance-max');
  const moduleToleranceMinSelect = module.querySelector('.module-tolerance-min');
  const moduleToleranceMaxSelect = module.querySelector('.module-tolerance-max');
  const moduleStarButtons = module.querySelectorAll('.module-star-btn');
  const moduleStarDescription = module.querySelector(`#moduleStarDescription${moduleId}`);

  // 做号星级按钮点击事件
  moduleStarButtons.forEach(button => {
    button.addEventListener('click', function() {
      const selectedStar = parseInt(this.dataset.star);
      
      // 更新当前模块内所有星级按钮的样式
      moduleStarButtons.forEach(btn => {
        btn.classList.remove('bg-green-500', 'text-white', 'active', 'border-green-500');
        btn.classList.add('border-gray-200', 'text-gray-600');
      });
      
      // 设置当前选中按钮的样式
      this.classList.remove('border-gray-200', 'text-gray-600');
      this.classList.add('bg-green-500', 'text-white', 'active', 'border-green-500');
      
      // 更新模块状态
      moduleState.starLevel = selectedStar;
      
      // 更新星级描述
      if (moduleStarDescription) {
        moduleStarDescription.textContent = `当前：${selectedStar}星 - 从10个号码中选择${selectedStar}个号码组成一注`;
      }
      
      console.log(`模块${moduleId}星级已切换到: ${selectedStar}星`);
    });
  });

  // 数字按钮点击事件
  numberButtons.forEach(button => {
      button.addEventListener('click', function() {
          const number = parseInt(this.dataset.number);
          const groupIndex = parseInt(this.dataset.group) - 1;
          const groupState = moduleState.groups[groupIndex];
          const index = groupState.selectedNumbers.indexOf(number);
          
          if (index === -1) {
              groupState.selectedNumbers.push(number);
              this.classList.add('bg-primary', 'text-white');
          } else {
              groupState.selectedNumbers.splice(index, 1);
              this.classList.remove('bg-primary', 'text-white');
          }
      });
  });

  // 命中数字按钮点击事件已在DOMContentLoaded中统一处理

  // 胆码按钮点击事件
  damaButtons.forEach(button => {
      // 处理胆码按钮状态切换的函数
      function toggleDamaButton() {
          const dama = parseInt(button.dataset.dama);
          const groupIndex = parseInt(button.dataset.group) - 1;
          const groupState = moduleState.groups[groupIndex];
          const index = groupState.selectedDamas.indexOf(dama);
          
          if (index === -1) {
              groupState.selectedDamas.push(dama);
              button.classList.add('bg-primary', 'text-white');
          } else {
              groupState.selectedDamas.splice(index, 1);
              button.classList.remove('bg-primary', 'text-white');
          }
      }
      
      // 移动端触摸事件处理变量
      let touchStartTime = 0;
      let touchMoved = false;
      let touchHandled = false;
      
      // 添加点击事件（仅在非触摸设备上生效）
      button.addEventListener('click', function(e) {
          // 如果触摸事件已处理，则跳过click事件
          if (touchHandled) {
              touchHandled = false;
              return;
          }
          toggleDamaButton();
      });
      
      // 添加移动端触摸事件处理
      button.addEventListener('touchstart', function(e) {
          touchStartTime = Date.now();
          touchMoved = false;
          touchHandled = false;
          // 添加触摸开始的视觉反馈
          this.style.opacity = '0.7';
      }, { passive: true });
      
      button.addEventListener('touchmove', function(e) {
          touchMoved = true;
          // 移除视觉反馈
          this.style.opacity = '';
      }, { passive: true });
      
      button.addEventListener('touchend', function(e) {
          const touchDuration = Date.now() - touchStartTime;
          // 恢复视觉反馈
          this.style.opacity = '';
          
          // 如果是快速点击且没有移动，则触发状态切换
          if (!touchMoved && touchDuration < 500) {
              touchHandled = true;
              toggleDamaButton();
              // 延迟重置标志，确保click事件被跳过
              setTimeout(() => {
                  touchHandled = false;
              }, 100);
          }
      }, { passive: true });
      
      button.addEventListener('touchcancel', function(e) {
           // 恢复视觉反馈
           this.style.opacity = '';
       }, { passive: true });
   });

  // 条件容错选择事件
  conditionToleranceMinSelects.forEach(select => {
    select.addEventListener('change', function() {
      const groupIndex = parseInt(this.dataset.group) - 1;
      moduleState.groups[groupIndex].toleranceMin = parseInt(this.value);
    });
  });

  conditionToleranceMaxSelects.forEach(select => {
    select.addEventListener('change', function() {
      const groupIndex = parseInt(this.dataset.group) - 1;
      moduleState.groups[groupIndex].toleranceMax = parseInt(this.value);
    });
  });

  // 模块总容错选择事件
  if (moduleToleranceMinSelect) {
    moduleToleranceMinSelect.addEventListener('change', function() {
      moduleState.moduleToleranceMin = parseInt(this.value);
    });
  }

  if (moduleToleranceMaxSelect) {
    moduleToleranceMaxSelect.addEventListener('change', function() {
      moduleState.moduleToleranceMax = parseInt(this.value);
    });
  }

  // 位置选择按钮事件处理
  const positionButtons = module.querySelectorAll('.position-btn');
  positionButtons.forEach(button => {
    button.addEventListener('click', function() {
      const position = parseInt(this.dataset.position);
      
      // 切换按钮选中状态
      if (this.classList.contains('bg-green-500')) {
        // 取消选中
        this.classList.remove('bg-green-500', 'text-white');
        this.classList.add('bg-gray-200', 'text-gray-700');
        
        // 从模块状态中移除该位置
        const index = moduleState.selectedPositions.indexOf(position);
        if (index > -1) {
          moduleState.selectedPositions.splice(index, 1);
        }
      } else {
        // 选中
        this.classList.remove('bg-gray-200', 'text-gray-700');
        this.classList.add('bg-green-500', 'text-white');
        
        // 添加到模块状态中
        if (!moduleState.selectedPositions.includes(position)) {
          moduleState.selectedPositions.push(position);
        }
      }
      
      // 排序位置数组
      moduleState.selectedPositions.sort((a, b) => a - b);
      
      console.log(`模块${moduleId}选中的位置:`, moduleState.selectedPositions);
    });
  });

  /***** 核心：按"命中个数"判定（不看位置） *****/
  
  /** 求与开奖号码（前五）相交的命中个数 */
  function countHits(picks, openTop5) {
    const set = new Set(openTop5.map(String));
    let c = 0;
    for (const x of picks) if (set.has(String(x))) c++;
    return c;
  }
  
  /** 条件判定：命中个数在 [minHits, maxHits] 内即通过 */
  function evalHitCondition(picks, openTop5, minHits, maxHits) {
    const k = picks.length;
    // 规范化边界
    const lo = Math.max(0, Math.min(minHits, maxHits));
    const hi = Math.min(k, Math.max(minHits, maxHits));
    const hits = countHits(picks, openTop5);
    const ok = hits >= lo && hits <= hi;
    return { ok, hits, minHits: lo, maxHits: hi, size: k };
  }
  
  /** 组合判定：5 个条件互不干扰，最终必须全部通过 */
  function evalAllConditions(conditions, openTop5) {
    const details = conditions.map(c =>
      evalHitCondition(c.picks, openTop5, c.minHits, c.maxHits)
    );
    return { ok: details.every(d => d.ok), details };
  }
  
  /***** 便捷映射：不同写法统一成命中区间 *****/
  
  /** n胆：mode='atLeast' 表示"至少 n 中"；mode='exact' 表示"恰好 n 中" */
  function mapDanToRange(nDan, picksLen, mode = 'atLeast') {
    if (mode === 'exact') return { minHits: nDan, maxHits: nDan };
    // 默认"至少 n 中"
    return { minHits: nDan, maxHits: picksLen };
  }
  
  /** "错区间"写法（比如 '1-1', '0-2'），转成命中区间
   *  约定：'a-b' 表示"允许错 a 到 b 个"
   *  则命中范围 = [picksLen - b, picksLen - a]
   */
  function mapMissRangeToHits(missRangeStr, picksLen) {
    const [a, b] = missRangeStr.split('-').map(x => parseInt(x, 10));
    const minHits = Math.max(0, picksLen - Math.max(a, b));
    const maxHits = Math.min(picksLen, picksLen - Math.min(a, b));
    return { minHits, maxHits };
  }
  
  // 基于条件数据生成组合的函数
  function generateFromConditions(activeConditions) {
    const results = [];
    const conditionCount = activeConditions.length;
    const minFailures = moduleState.moduleToleranceMin;
    const maxFailures = moduleState.moduleToleranceMax;
    
    // 计算需要满足的条件数量范围
    const minSatisfied = Math.max(0, conditionCount - maxFailures);
    const maxSatisfied = Math.max(0, conditionCount - minFailures);
    
    console.log(`条件总数: ${conditionCount}, 容错范围: ${minFailures}-${maxFailures}`);
    console.log(`需要满足的条件数: ${minSatisfied}-${maxSatisfied}`);
    
    // 生成所有可能的条件组合
    for (let satisfiedCount = minSatisfied; satisfiedCount <= maxSatisfied; satisfiedCount++) {
      if (satisfiedCount === 0 && conditionCount > 0) continue; // 当有条件时，至少要满足一个条件
      
      // 获取所有可能的条件组合
      const conditionCombinations = getCombinations(activeConditions, satisfiedCount);
      
      for (const conditionCombo of conditionCombinations) {
        // 从选中的条件中生成数字组合
        const numberCombinations = generateNumberCombinations(conditionCombo);
        results.push(...numberCombinations);
      }
    }
    
    // 去重并限制结果数量
    const uniqueResults = [...new Set(results.map(r => r.join(',')))];
    console.log(`生成组合数: ${uniqueResults.length}`);
    
    return uniqueResults.slice(0, 10000).map(r => r.split(',').map(Number)); // 限制最多10000个结果
  }
  
  // 获取数组的所有组合
  function getCombinations(arr, count) {
    if (count === 0) return [[]];
    if (count > arr.length) return [];
    if (count === arr.length) return [arr];
    
    const result = [];
    for (let i = 0; i <= arr.length - count; i++) {
      const head = arr[i];
      const tailCombos = getCombinations(arr.slice(i + 1), count - 1);
      for (const tail of tailCombos) {
        result.push([head, ...tail]);
      }
    }
    return result;
  }
  
  // 从条件组合中生成数字组合
  function generateNumberCombinations(conditions) {
    const results = [];
    
    // 收集所有条件的数字
    const allConditionNumbers = conditions.map(condition => {
      return condition.selectedNumbers.length > 0 ? condition.selectedNumbers : [1,2,3,4,5,6,7,8,9,10];
    });
    
    // 生成笛卡尔积
    function cartesianProduct(arrays) {
      if (arrays.length === 0) return [[]];
      if (arrays.length === 1) return arrays[0].map(x => [x]);
      
      const result = [];
      const firstArray = arrays[0];
      const restProduct = cartesianProduct(arrays.slice(1));
      
      for (const first of firstArray) {
        for (const rest of restProduct) {
          const combination = [first, ...rest];
          if (combination.length === 5 && new Set(combination).size === 5) {
            // 确保是5个不重复的数字
            result.push(combination.sort((a, b) => a - b));
          }
        }
      }
      return result;
    }
    
    // 如果条件数少于5个，需要补充其他数字
    if (conditions.length < 5) {
      const usedNumbers = new Set();
      conditions.forEach(condition => {
        condition.selectedNumbers.forEach(num => usedNumbers.add(num));
      });
      
      const remainingNumbers = [1,2,3,4,5,6,7,8,9,10].filter(num => !usedNumbers.has(num));
      const needMore = 5 - conditions.length;
      
      // 从剩余数字中选择需要的数量
      const additionalCombos = getCombinations(remainingNumbers, needMore);
      
      for (const condition of conditions) {
        for (const num of condition.selectedNumbers) {
          for (const additional of additionalCombos) {
            const combination = [num, ...additional].sort((a, b) => a - b);
            if (combination.length === 5 && new Set(combination).size === 5) {
              results.push(combination);
            }
          }
        }
      }
    } else {
      // 如果条件数>=5，直接从每个条件中选一个数字
      const cartesianResults = cartesianProduct(allConditionNumbers);
      results.push(...cartesianResults);
    }
    
    return results;
  }
  
  // 条件评估函数（适配现有接口）
  function evaluateCondition(condition, resultNums) {
    // 如果条件为空，应该不参与评估
    if (condition.selectedNumbers.length === 0 && condition.selectedDamas.length === 0) {
      return { ok: true, errors: 0 };
    }
    
    const picks = condition.selectedNumbers;
    const picksLen = picks.length;
    
    // 计算实际命中个数
    const actualHitCount = countHits(picks, resultNums);
    
    if (condition.selectedDamas.length === 0) {
      // 未选择命中胆码数：如果选择了胆码数字但没有选择命中胆码数，则不通过筛选
      // 这种情况下用户需要明确指定命中几个胆码才能进行筛选
      return {
        ok: false,
        errors: picksLen - actualHitCount,
        hitCount: actualHitCount
      };
    }
    
    // 已选择命中胆码数：检查实际命中数是否在选中的胆码数范围内
    // 胆码逻辑：选择1234作为胆码，命中胆码数选3-4时，筛选包含1234中任意3个或4个的号码
    
    // 基于数学公式的条件集K容错逻辑
    // 条件集K = {选中的胆码数}，实际命中数k，容错参数r
    // r=0: 并集逻辑 Sr=0(K) = ∑N(k) for k∈K (分别满足)
    // r=1: 补集逻辑 Sr=1(K) = ∑N(k) for k∉K (不满足)
    // r(0-1): 联合逻辑 Sr(0-1)(K) = Sr=0(K) + Sr=1(K) = P(10,n) (全集)
    
    const toleranceMin = condition.toleranceMin;
    const toleranceMax = condition.toleranceMax;
    const selectedDamasSet = new Set(condition.selectedDamas);
    
    let isValid = false;
    
    if (toleranceMin === 0 && toleranceMax === 0) {
      // r=0: 并集逻辑 - 实际命中数必须在条件集K中
      isValid = selectedDamasSet.has(actualHitCount);
    } else if (toleranceMin === 1 && toleranceMax === 1) {
      // r=1: 补集逻辑 - 实际命中数必须不在条件集K中
      isValid = !selectedDamasSet.has(actualHitCount);
    } else if (toleranceMin === 0 && toleranceMax === 1) {
      // r(0-1): 联合逻辑 - 实际命中数可以在K中或不在K中（全集）
      isValid = true; // 任何命中数都满足
    } else {
      // 扩展容错逻辑：基于条件集K的包含关系
      // 计算条件集K中满足的胆码数量
      const satisfiedInK = selectedDamasSet.has(actualHitCount) ? 1 : 0;
      const unsatisfiedInK = selectedDamasSet.has(actualHitCount) ? 0 : 1;
      
      // 检查满足条件的数量是否在容错范围内
      if (toleranceMin <= toleranceMax) {
        // 标准范围容错：允许unsatisfiedInK在[toleranceMin, toleranceMax]范围内
        isValid = unsatisfiedInK >= toleranceMin && unsatisfiedInK <= toleranceMax;
      } else {
        // 特殊情况处理
        isValid = false;
      }
    }
    
    return {
      ok: isValid,
      errors: picksLen - actualHitCount,
      hitCount: actualHitCount,
      conditionSetK: Array.from(selectedDamasSet),
      toleranceApplied: `r(${toleranceMin}-${toleranceMax})`
    };
  }  
  // 评估所有条件（适配现有接口）
  function evaluateAll(conditions, resultNums) {
    // 只评估有设置的条件（选择了数字或胆码的条件）
    const activeConditions = conditions.filter(c => 
      c.selectedNumbers.length > 0 || c.selectedDamas.length > 0
    );
    
    // 如果没有任何活跃条件，返回true（通过筛选，生成所有组合）
    if (activeConditions.length === 0) {
      return { ok: true, details: [], failedCount: 0, moduleToleranceRange: [moduleState.moduleToleranceMin, moduleState.moduleToleranceMax] };
    }
    
    const details = activeConditions.map(c => evaluateCondition(c, resultNums));
    
    // 应用模块总容错逻辑
    // 统计不成立的条件数量
    const failedConditionsCount = details.filter(d => !d.ok).length;
    
    // 检查失败的条件数是否在允许的容错范围内
    const moduleToleranceOk = failedConditionsCount >= moduleState.moduleToleranceMin && 
                             failedConditionsCount <= moduleState.moduleToleranceMax;
    
    return { 
      ok: moduleToleranceOk, 
      details,
      failedCount: failedConditionsCount,
      moduleToleranceRange: [moduleState.moduleToleranceMin, moduleState.moduleToleranceMax]
    };
  }

  // 做号按钮点击事件
  generateBtn.addEventListener('click', function() {
    // 获取有数据的条件
    const activeConditions = moduleState.groups.filter(g => 
      g.selectedNumbers.length > 0 || g.selectedDamas.length > 0
    );
    
    let filteredResults = [];
    
    // 获取当前选择的星级
    const currentStarLevel = moduleState.starLevel || 5;
    
    // 如果没有活跃条件，生成所有可能的排列
    if (activeConditions.length === 0) {
      console.log(`没有活跃条件，生成所有${currentStarLevel}星排列`);
      const allNumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
      const permutations = permute(allNumbers, currentStarLevel);
      console.log(`生成${currentStarLevel}星排列数: ${permutations.length}`);
      filteredResults = permutations;
    }
    // 有活跃条件时，使用筛选逻辑
    else {
      console.log(`有活跃条件，使用${currentStarLevel}星筛选逻辑`);
      console.log('活跃条件:', activeConditions);
      
      const allNumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
      const permutations = permute(allNumbers, currentStarLevel);
      
      // 存储所有排列组合
      moduleState.allPermutations = permutations;
      
      // 根据选中的数字、胆码和容错筛选结果
      filteredResults = permutations.filter(comb => {
          // 使用容错评估逻辑
          const evaluation = evaluateAll(moduleState.groups, comb);
          
          // 调试信息：输出前几个组合的评估结果
          if (permutations.indexOf(comb) < 5) {
            console.log(`组合 ${comb.join(',')} 评估结果:`, {
              ok: evaluation.ok,
              failedCount: evaluation.failedCount,
              moduleToleranceRange: evaluation.moduleToleranceRange,
              details: evaluation.details.map(d => ({ ok: d.ok, hitCount: d.hitCount }))
            });
          }
          
          return evaluation.ok;
      });
    }
    
    // 调试信息：输出筛选统计
    console.log(`模块总容错设置: ${moduleState.moduleToleranceMin}-${moduleState.moduleToleranceMax}`);
    console.log(`活跃条件数: ${moduleState.groups.filter(g => g.selectedNumbers.length > 0 || g.selectedDamas.length > 0).length}`);
    console.log(`筛选结果: ${filteredResults.length}`);
    
    // 调试信息：输出最终结果
    console.log(`最终筛选结果数量: ${filteredResults.length}`);
    
    // 首次生成时就按照格式化逻辑处理并存储为字符串
    const formattedResults = filteredResults.map(comb => 
        comb.map(num => num.toString().padStart(2, '0')).join(' ')
    );
    
    console.log(`格式化后结果数量: ${formattedResults.length}`);
    

    
    moduleState.results = formattedResults;
    moduleState.originalResults = [...formattedResults]; // 保存原始结果
    moduleState.isReversed = false;
    
    updateResultDisplay();
  });

  // 复制按钮点击事件
  copyBtn.addEventListener('click', function() {
    if (moduleState.results.length === 0) {
      // 修改无结果提示为文本显示
      resultCount.innerHTML = '<span style="color: red;">没有可复制的结果</span>';
      setTimeout(() => {
        resultCount.textContent = `共${moduleState.results.length}注`;
      }, 1000);
      return;
    }
    
    // 复制存储的筛选结果 - 组内空格，组间逗号
    // moduleState.results中每个元素已经是格式化的字符串（如"01 02 03 04 05"）
    // 直接用逗号连接即可得到正确格式
    let textToCopy = '';
    for (let i = 0; i < moduleState.results.length; i++) {
      if (i > 0) textToCopy += ',';
      textToCopy += moduleState.results[i];
    }

    // 复制到剪贴板
    navigator.clipboard.writeText(textToCopy).then(() => {
      // 复制成功后显示红色的已复制提示
      resultCount.innerHTML = `共${moduleState.results.length}注 <span style="color: red;">已复制${moduleState.results.length}注</span>`;
    }).catch(err => {
      console.error('复制失败:', err);
      // 错误提示：显示红色错误文本
      resultCount.innerHTML = '<span style="color: red;">复制失败，请手动复制</span>';
      setTimeout(() => {
        resultCount.textContent = `共${moduleState.results.length}注`;
      }, 2000);
    });
  });

  // 验证逻辑函数 - 提取验证逻辑避免递归调用
  // 验证任务管理器
  const VerificationTaskManager = {
    currentTask: null,
    isRunning: false,
    dataUpdateTimer: null,
    lastProcessedPeriod: null,
    currentModuleId: null, // 添加当前模块ID
    
    // 启动持续验证任务
    startContinuousVerification(moduleId) {
      console.log(`🚀 启动模块${moduleId}的持续验证任务`);
      
      // 停止之前的任务
      this.stopCurrentTask();
      
      // 标记为运行状态
      this.isRunning = true;
      this.currentModuleId = moduleId;
      
      // 执行首次验证
      this.performSingleVerification();
      
      // 启动数据监听
      this.startDataMonitoring();
    },
    
    // 停止当前验证任务
    stopCurrentTask() {
      console.log('🛑 停止当前验证任务');
      
      this.isRunning = false;
      
      // 清除数据监听定时器
      if (this.dataUpdateTimer) {
        clearInterval(this.dataUpdateTimer);
        this.dataUpdateTimer = null;
      }
      
      // 重置状态
      this.lastProcessedPeriod = null;
      
      console.log('✅ 验证任务已停止');
    },
    
    // 启动数据更新监听
    startDataMonitoring() {
      console.log('👁️ 启动数据更新监听');
      
      // 每3秒检查一次数据更新
      this.dataUpdateTimer = setInterval(() => {
        if (!this.isRunning) {
          return;
        }
        
        // 检查是否有新数据
        if (r && r.length > 0) {
          const latestPeriod = r[0].period;
          
          // 如果发现新期数据，触发验证
          if (this.lastProcessedPeriod !== latestPeriod) {
            console.log(`🔔 检测到新期数据: ${latestPeriod}，触发验证`);
            this.performSingleVerification();
          }
        }
      }, 3000);
    },
    
    // 执行单次验证
    performSingleVerification() {
      if (!this.isRunning) {
        console.log('⚠️ 验证任务已停止，跳过验证');
        return;
      }
      
      console.log(`🔍 执行模块${this.currentModuleId}的持续验证 - 全期验证模式`);
      
      // 在持续验证模式下，触发全期验证更新
      if (window.PlanDataUpdateListener && typeof window.PlanDataUpdateListener.updateAllPlansWithFullVerification === 'function') {
        window.PlanDataUpdateListener.updateAllPlansWithFullVerification();
      } else {
        // 兼容旧版本，执行单次验证
        performVerification(this.currentModuleId, false, true); // 传递模块ID，第三个参数表示是持续验证模式
      }
      
      // 更新最后处理的期数
      if (window.r && window.r.length > 0) {
        this.lastProcessedPeriod = window.r[0].period;
      }
    }
  };
  
  // 将管理器暴露到全局
  window.VerificationTaskManager = VerificationTaskManager;
  
  // 生成计划唯一哈希函数
  function generatePlanHash(planNumbers, moduleState) {
    try {
      // 构建完整的做号条件信息
      const conditions = {
        numbers: Array.isArray(planNumbers) ? [...planNumbers].sort() : [], // 排序确保一致性
        selectedNumbers: (moduleState.selectedNumbers || []).sort(),
        betMultiple: moduleState.betMultiple || 1,
        periods: moduleState.periods || 1,
        moduleType: `${moduleState.starLevel || 5}星做号`,
        moduleToleranceMin: moduleState.moduleToleranceMin || 0,
        moduleToleranceMax: moduleState.moduleToleranceMax || 0,
        // 包含每个位置的详细条件
        groups: (moduleState.groups || []).map(g => ({
          selectedNumbers: (g.selectedNumbers || []).sort(),
          selectedDamas: (g.selectedDamas || []).sort(),
          toleranceMin: g.toleranceMin || 0,
          toleranceMax: g.toleranceMax || 0
        }))
      };
      
      // 生成基于完整条件的哈希字符串
      const hashString = JSON.stringify(conditions);
      let hash = 0;
      for (let i = 0; i < hashString.length; i++) {
        const char = hashString.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // 转换为32位整数
      }
      return Math.abs(hash).toString(36);
    } catch (error) {
      console.error('生成计划哈希时出错:', error);
      // 返回一个基于时间戳的简单哈希
      return `plan_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
  }
  
  // 检查计划是否已存在（防重复）
  function isPlanDuplicate(planHash) {
    if (!window.verifyPlanData || !planHash) return false;
    
    return window.verifyPlanData.some(plan => 
      plan.planHash === planHash || 
      (plan.generationConditions && plan.generationConditions.planHash === planHash)
    );
  }
  
  // 计划存储管理器
  window.PlanStorageManager = {
    // 存储计划
    storePlan: function(verifyRecord, isVerified = true) {
      // 只保存已验证的计划
      if (!isVerified) {
        console.log('⏸️ 计划未验证，跳过保存:', verifyRecord.planHash);
        return false;
      }
      
      // 确保全局变量存在
      if (typeof window.verifyPlanData === 'undefined') {
        window.verifyPlanData = [];
      }
      
      // 如果检测到重复，则更新已存在的记录并置顶显示，而不是拦截
      const idx = window.verifyPlanData.findIndex(plan => 
        plan.planHash === verifyRecord.planHash || 
        (plan.generationConditions && plan.generationConditions.planHash === verifyRecord.planHash)
      );
      if (idx >= 0) {
        // 用最新记录替换旧记录，并移动到数组最前
        window.verifyPlanData.splice(idx, 1);
        window.verifyPlanData.unshift(verifyRecord);
        console.log('🔄 检测到重复计划，已更新并置顶:', verifyRecord.planHash);
        
        // 自动保存到本地存储
        this.saveToLocalStorage();
        
        return true;
      }
      
      // 新计划，直接插入到最前
      window.verifyPlanData.unshift(verifyRecord);
      console.log('✅ 计划已存储，当前总数:', window.verifyPlanData.length);
      
      // 自动保存到本地存储
      this.saveToLocalStorage();
      
      // 更新单期验证表格
      if (typeof window.updateSinglePeriodTable === 'function') {
        window.updateSinglePeriodTable();
      }
      
      return true;
    },
    
    // 删除计划
    deletePlan: function(planId) {
      if (!window.verifyPlanData) return false;
      
      const originalLength = window.verifyPlanData.length;
      window.verifyPlanData = window.verifyPlanData.filter(plan => plan.planId !== planId);
      
      const deleted = originalLength > window.verifyPlanData.length;
      if (deleted) {
        console.log('🗑️ 计划已删除:', planId);
      }
      return deleted;
    },
    
    // 获取所有计划
    getAllPlans: function() {
      return window.verifyPlanData || [];
    },
    
    // 根据哈希查找计划
    findPlanByHash: function(planHash) {
      if (!window.verifyPlanData) return null;
      return window.verifyPlanData.find(plan => plan.planHash === planHash);
    },
    
    // 清空所有计划
    clearAllPlans: function() {
      window.verifyPlanData = [];
      console.log('🧹 所有计划已清空');
      // 同时清空本地存储
      this.saveToLocalStorage();
    },

    // 保存到本地存储
    saveToLocalStorage: function() {
      try {
        const dataToSave = {
          verifyPlanData: window.verifyPlanData || [],
          timestamp: new Date().toISOString(),
          version: '1.0'
        };
        localStorage.setItem('twpk_verify_plan_data', JSON.stringify(dataToSave));
        console.log('💾 计划验证历史已保存到本地存储，共', dataToSave.verifyPlanData.length, '条记录');
        return true;
      } catch (error) {
        console.error('❌ 保存到本地存储失败:', error);
        return false;
      }
    },

    // 从本地存储加载
    loadFromLocalStorage: function(skipVerification = false, batchSize = 50) {
      try {
        const savedData = localStorage.getItem('twpk_verify_plan_data');
        if (!savedData) {
          console.log('📂 本地存储中没有找到计划验证历史');
          return false;
        }

        const parsedData = JSON.parse(savedData);
        if (parsedData && Array.isArray(parsedData.verifyPlanData)) {
          const totalPlans = parsedData.verifyPlanData.length;
          
          // 如果计划数量较少，直接加载
          if (totalPlans <= batchSize) {
            window.verifyPlanData = parsedData.verifyPlanData;
            console.log('📂 从本地存储加载计划验证历史成功，共', totalPlans, '条记录');
            console.log('📅 数据保存时间:', parsedData.timestamp);
            
            // 如果不跳过验证，则更新单期验证表格
            if (!skipVerification && typeof window.updateSinglePeriodTable === 'function') {
              // 延迟执行验证，避免页面刷新时立即卡顿
              setTimeout(() => {
                console.log('🔄 延迟执行验证逻辑，避免页面刷新卡顿');
                window.updateSinglePeriodTable();
              }, 500); // 延迟500ms
            } else if (skipVerification) {
              console.log('⏭️ 跳过验证逻辑，仅加载数据');
            }
            
            return true;
          }
          
          // 大量数据时使用批量加载
          console.log('📊 检测到大量计划数据(' + totalPlans + '条)，启用批量加载优化');
          
          // 初始化为空数组
          window.verifyPlanData = [];
          
          // 分批加载数据
          this.loadDataInBatches(parsedData.verifyPlanData, batchSize, skipVerification);
          
          console.log('📂 批量加载已启动，数据保存时间:', parsedData.timestamp);
          return true;
        } else {
          console.warn('⚠️ 本地存储数据格式不正确');
          return false;
        }
      } catch (error) {
        console.error('❌ 从本地存储加载失败:', error);
        return false;
      }
    },

    // 批量加载数据的辅助函数
    loadDataInBatches: function(allData, batchSize, skipVerification) {
      let currentIndex = 0;
      const totalBatches = Math.ceil(allData.length / batchSize);
      
      const loadNextBatch = () => {
        const endIndex = Math.min(currentIndex + batchSize, allData.length);
        const batch = allData.slice(currentIndex, endIndex);
        
        // 将批次数据添加到全局数组
        window.verifyPlanData.push(...batch);
        
        const currentBatch = Math.floor(currentIndex / batchSize) + 1;
        console.log(`📦 批次 ${currentBatch}/${totalBatches} 加载完成 (${batch.length}条记录)`);
        
        currentIndex = endIndex;
        
        // 如果还有更多数据，继续加载下一批
        if (currentIndex < allData.length) {
          // 使用 requestAnimationFrame 来避免阻塞UI
          requestAnimationFrame(() => {
            setTimeout(loadNextBatch, 10); // 小延迟避免卡顿
          });
        } else {
          // 所有数据加载完成
          console.log('✅ 所有数据批量加载完成，共', window.verifyPlanData.length, '条记录');
          
          // 如果不跳过验证，则更新单期验证表格
          if (!skipVerification && typeof window.updateSinglePeriodTable === 'function') {
            setTimeout(() => {
              console.log('🔄 批量加载完成后执行验证逻辑');
              window.updateSinglePeriodTable();
            }, 100);
          }
        }
      };
      
      // 开始加载第一批
      loadNextBatch();
    },

    // 导出数据到文件
    exportToFile: function() {
      try {
        const dataToExport = {
          verifyPlanData: window.verifyPlanData || [],
          exportTime: new Date().toISOString(),
          version: '1.0'
        };
        
        const dataStr = JSON.stringify(dataToExport, null, 2);
        const dataBlob = new Blob([dataStr], { type: 'application/json' });
        
        const link = document.createElement('a');
        link.href = URL.createObjectURL(dataBlob);
        link.download = `twpk_verify_plan_data_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        console.log('📤 计划验证历史已导出到文件，共', dataToExport.verifyPlanData.length, '条记录');
        return true;
      } catch (error) {
        console.error('❌ 导出到文件失败:', error);
        return false;
      }
    },

    // 从文件导入数据
    importFromFile: function(file) {
      return new Promise((resolve, reject) => {
        if (!file) {
          reject(new Error('未选择文件'));
          return;
        }

        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const importedData = JSON.parse(e.target.result);
            
            if (importedData && Array.isArray(importedData.verifyPlanData)) {
              // 合并数据，避免重复
              const existingHashes = new Set((window.verifyPlanData || []).map(plan => plan.planHash));
              const newPlans = importedData.verifyPlanData.filter(plan => !existingHashes.has(plan.planHash));
              
              if (!window.verifyPlanData) {
                window.verifyPlanData = [];
              }
              
              // 将新计划添加到现有数据前面
              window.verifyPlanData = [...newPlans, ...window.verifyPlanData];
              
              // 保存到本地存储
              this.saveToLocalStorage();
              
              // 更新单期验证表格
              if (typeof window.updateSinglePeriodTable === 'function') {
                window.updateSinglePeriodTable();
              }
              
              console.log('📥 从文件导入计划验证历史成功');
              console.log('📊 导入', newPlans.length, '条新记录，总计', window.verifyPlanData.length, '条记录');
              console.log('📅 导入数据时间:', importedData.exportTime);
              
              resolve({
                imported: newPlans.length,
                total: window.verifyPlanData.length,
                skipped: importedData.verifyPlanData.length - newPlans.length
              });
            } else {
              reject(new Error('文件格式不正确'));
            }
          } catch (error) {
            reject(new Error('文件解析失败: ' + error.message));
          }
        };
        
        reader.onerror = () => {
          reject(new Error('文件读取失败'));
        };
        
        reader.readAsText(file);
      });
    },
    
    // 自动验证所有计划的中挂情况
    autoVerifyAllPlans: function(newPeriodData) {
      if (!window.verifyPlanData || window.verifyPlanData.length === 0) {
        return { updated: 0, results: [] };
      }
      
      console.log('🔄 开始自动验证所有计划，新期数据:', newPeriodData);
      
      let updatedCount = 0;
      const results = [];
      
      // 获取所有可用的历史数据源
      const allHistoryData = window.r || window.historyData || [];
      console.log('📊 可用历史数据:', allHistoryData.length, '期');
      
      window.verifyPlanData.forEach(plan => {
        // 检查是否需要验证这个计划
        if (!plan.planNumbers || !plan.period) {
          return;
        }
        
        // 在所有历史数据中查找匹配的期数
        let matchedData = null;
        
        // 首先检查新传入的数据
        if (newPeriodData && newPeriodData.data && plan.period === newPeriodData.period) {
          matchedData = newPeriodData;
          console.log(`📍 计划 ${plan.planId} 匹配新数据期数: ${newPeriodData.period}`);
        }
        
        // 如果新数据没有匹配，在历史数据中查找
        if (!matchedData && allHistoryData.length > 0) {
          const historyMatch = allHistoryData.find(item => item.period === plan.period);
          if (historyMatch) {
            matchedData = historyMatch;
            console.log(`📍 计划 ${plan.planId} 匹配历史数据期数: ${historyMatch.period}`);
          }
        }
        
        // 如果找到匹配的数据，进行验证
        if (matchedData && matchedData.data) {
          const drawNumbers = matchedData.data;
          let isWin = false;
          
          // 验证五星号码
          for (const numberSet of plan.planNumbers) {
            if (numberSet && numberSet.length === 5) {
              // 检查前五位是否完全匹配
              const match = numberSet.every((num, index) => 
                drawNumbers[index] && drawNumbers[index].toString() === num.toString()
              );
              if (match) {
                isWin = true;
                console.log(`🎯 计划 ${plan.planId} 中奖号码: ${numberSet.join('')} 匹配开奖: ${drawNumbers.slice(0, 5).join('')}`);
                break;
              }
            }
          }
          
          const newResult = isWin ? '中' : '挂';
          const oldResult = plan.result;
          
          // 更新验证结果
          plan.result = newResult;
          plan.latestData = drawNumbers;
          plan.winningNumber = drawNumbers.slice(0, 5).join('');
          plan.autoVerifiedAt = new Date().toISOString();
          plan.verifiedPeriod = matchedData.period;
          
          if (oldResult !== newResult) {
            updatedCount++;
            results.push({
              planId: plan.planId,
              period: plan.period,
              oldResult: oldResult,
              newResult: newResult,
              betCount: plan.betCount,
              verifiedPeriod: matchedData.period
            });
            
            console.log(`📊 计划 ${plan.planId} 验证结果更新: ${oldResult} -> ${newResult} (期数: ${matchedData.period})`);
          } else if (!oldResult) {
            // 首次验证
            updatedCount++;
            results.push({
              planId: plan.planId,
              period: plan.period,
              oldResult: '未验证',
              newResult: newResult,
              betCount: plan.betCount,
              verifiedPeriod: matchedData.period
            });
            
            console.log(`📊 计划 ${plan.planId} 首次验证结果: ${newResult} (期数: ${matchedData.period})`);
          }
        } else {
          console.log(`⚠️ 计划 ${plan.planId} 未找到匹配的期数数据: ${plan.period}`);
        }
      });
      
      if (updatedCount > 0) {
        console.log(`✅ 自动验证完成，更新了 ${updatedCount} 个计划的结果`);
        
        // 触发表格更新
        if (typeof window.updateVerifyPlanTable === 'function') {
          window.updateVerifyPlanTable();
        }
        
        // 更新统计信息
        if (typeof updateStatistics === 'function') {
          updateStatistics();
        }
      }
      
      return { updated: updatedCount, results: results };
    },
    
    // 对所有计划进行历史数据全量验证 - 每个计划验证所有历史期数
    verifyAllPlansAgainstHistory: function() {
      if (!window.verifyPlanData || window.verifyPlanData.length === 0) {
        console.log('📝 没有计划需要验证');
        return { updated: 0, results: [] };
      }
      
      // 获取所有可用的历史数据源
      const allHistoryData = window.r || window.historyData || [];
      if (!allHistoryData || allHistoryData.length === 0) {
        console.log('📊 没有历史数据可用于验证');
        return { updated: 0, results: [] };
      }
      
      console.log(`🔍 开始对 ${window.verifyPlanData.length} 个计划进行全历史期数验证`);
      console.log(`📊 可用历史数据: ${allHistoryData.length} 期`);
      
      let updatedCount = 0;
      const results = [];
      
      window.verifyPlanData.forEach(plan => {
        // 检查计划是否有效
        if (!plan.planNumbers || plan.planNumbers.length === 0) {
          console.log(`⚠️ 跳过无效计划: ${plan.planId}`);
          return;
        }
        
        // 跳过已完成验证的计划
        if (plan.isCompleted) {
          console.log(`✅ 跳过已完成验证的计划: ${plan.planId} (结果: ${plan.result})`);
          return;
        }
        
        console.log(`🔍 验证计划 ${plan.planId} 对所有 ${allHistoryData.length} 期历史数据`);
        
        // 初始化计划的验证结果统计
        let totalWins = 0;
        let totalPeriods = 0;
        let winningPeriods = [];
        let winningNumbers = [];
        
        // 遍历所有历史期数进行验证
        allHistoryData.forEach(periodData => {
          if (!periodData || !periodData.data || !periodData.period) {
            return;
          }
          
          const drawNumbers = periodData.data.slice(0, 5); // 取前五位
          let periodWin = false;
          let winningNumber = null;
          
          // 验证计划中的每注号码
          for (const numberStr of plan.planNumbers) {
            let numbers;
            
            // 处理不同格式的号码
            if (typeof numberStr === 'string') {
              // 如果是字符串，按空格分割
              numbers = numberStr.split(' ').map(n => parseInt(n.trim()));
            } else if (Array.isArray(numberStr)) {
              // 如果已经是数组
              numbers = numberStr.map(n => parseInt(n));
            } else {
              continue;
            }
            
            // 检查是否为有效的五星号码
            if (numbers.length === 5 && numbers.every(n => !isNaN(n))) {
              // 检查前五位是否完全一致（顺序一致）
              const exactMatch = numbers.every((n, idx) => drawNumbers[idx] && drawNumbers[idx].toString() === n.toString());
              
              if (exactMatch) {
                periodWin = true;
                winningNumber = numbers.join(' ');
                console.log(`🎉 计划 ${plan.planId} 在期数 ${periodData.period} 中奖！号码: ${winningNumber}, 开奖前五: ${drawNumbers.join(',')}`);
                break; // 只要有一注命中就停止检查该期
              }
            }
          }
          
          totalPeriods++;
          if (periodWin) {
            totalWins++;
            winningPeriods.push({
              period: periodData.period,
              winningNumber: winningNumber,
              drawNumbers: drawNumbers.join('')
            });
          }
        });
        
        // 更新计划的验证结果
        const oldResult = plan.result;
        const newResult = totalWins > 0 ? `中${totalWins}期` : '全挂';
        
        // 更新计划信息
        plan.result = newResult;
        plan.isCompleted = true; // 标记为已完成验证
        plan.totalWins = totalWins;
        plan.totalPeriods = totalPeriods;
        plan.winningPeriods = winningPeriods;
        plan.winRate = totalPeriods > 0 ? ((totalWins / totalPeriods) * 100).toFixed(2) + '%' : '0%';
        plan.autoVerifiedAt = new Date().toISOString();
        plan.historyVerified = true;
        plan.verificationDetails = {
          totalPeriods: totalPeriods,
          totalWins: totalWins,
          winRate: plan.winRate,
          winningPeriods: winningPeriods
        };
        
        if (oldResult !== newResult || !oldResult) {
          updatedCount++;
          results.push({
            planId: plan.planId,
            period: plan.period || '多期',
            oldResult: oldResult || '未验证',
            newResult: newResult,
            betCount: plan.betCount,
            totalWins: totalWins,
            totalPeriods: totalPeriods,
            winRate: plan.winRate,
            isHistoryVerification: true,
            winningPeriods: winningPeriods
          });
          
          console.log(`📊 计划 ${plan.planId} 全历史验证结果: ${oldResult || '未验证'} -> ${newResult} (${totalWins}/${totalPeriods}期中奖，胜率${plan.winRate})`);
        }
      });
      
      if (updatedCount > 0) {
        console.log(`✅ 全历史期数验证完成，更新了 ${updatedCount} 个计划的结果`);
        
        // 保存更新后的计划数据到本地存储
        if (typeof window.PlanStorageManager !== 'undefined' && window.PlanStorageManager.saveToLocalStorage) {
          window.PlanStorageManager.saveToLocalStorage();
          console.log('💾 已保存更新后的计划验证状态到本地存储');
        }
        
        // 触发表格更新
        if (typeof window.updateVerifyPlanTable === 'function') {
          window.updateVerifyPlanTable();
        }
        
        // 更新统计信息
        if (typeof updateStatistics === 'function') {
          updateStatistics();
        }
      } else {
        console.log('📊 全历史期数验证完成，没有结果需要更新');
      }
      
      return { updated: updatedCount, results: results };
    }
  };
  
  // 数据更新监听器
  window.PlanDataUpdateListener = {
    // 监听历史数据更新
    onHistoryDataUpdate: function(newData) {
      if (!newData || newData.length === 0) return;
      
      console.log('📡 检测到历史数据更新，开始全期验证计划更新');
      
      // 对所有计划进行全期重新验证
      this.updateAllPlansWithFullVerification();
      
      // 如果当前在单期验证模式，更新单期验证表格
      const singlePeriodTable = document.getElementById('singlePeriodTable');
      if (singlePeriodTable && !singlePeriodTable.classList.contains('hidden')) {
        console.log('📡 多期验证数据更新，同步更新单期验证表格');
        window.updateSinglePeriodTable();
        console.log('📡 单期验证表格同步更新完成');
      } else {
        console.log('📡 当前不在单期验证模式，跳过单期验证表格更新');
      }
    },
    
    // 对所有计划进行全期重新验证
    updateAllPlansWithFullVerification: function() {
      if (!window.verifyPlanData || window.verifyPlanData.length === 0) {
        console.log('📊 没有验证计划需要更新');
        return;
      }
      
      // 获取当前历史数据
      const dataSource = window.r || window.historyData;
      if (!dataSource || dataSource.length === 0) {
        console.log('📊 没有历史数据，无法进行全期验证');
        return;
      }
      
      console.log(`📊 开始对 ${window.verifyPlanData.length} 个计划进行全期重新验证`);
      let updatedCount = 0;
      
      window.verifyPlanData.forEach(plan => {
        if (!plan.planNumbers || plan.planNumbers.length === 0) return;
        
        // 对该计划进行全期验证
        let totalWins = 0;
        let totalPeriods = 0;
        let winningPeriods = [];
        
        dataSource.forEach(periodData => {
          if (!periodData || !periodData.data || !periodData.period) return;
          
          const drawNumbers = periodData.data.slice(0, 5); // 取前五位
          let periodWin = false;
          let winningNumber = null;
          
          // 验证计划中的每注号码
          for (const numberStr of plan.planNumbers) {
            const numbers = numberStr.split(' ').map(n => parseInt(n.trim()));
            
            // 检查是否为有效的五星号码
        if (numbers.length === 5 && numbers.every(n => !isNaN(n))) {
          // 严格判定：前五位顺序完全一致才算中
          const exactMatch = numbers.every((num, idx) => num === drawNumbers.slice(0, 5)[idx]);
          
          if (exactMatch) {
            periodWin = true;
            winningNumber = numberStr;
            break; // 只要有一注命中就停止检查该期
          }
        }
          }
          
          totalPeriods++;
          if (periodWin) {
            totalWins++;
            winningPeriods.push({
              period: periodData.period,
              winningNumber: winningNumber,
              drawNumbers: drawNumbers.join('')
            });
          }
        });
        
        // 更新计划的验证结果
        const oldResult = plan.result;
        const oldTotalWins = plan.totalWins || 0;
        
        plan.result = totalWins > 0 ? `中${totalWins}期` : '全挂';
        plan.totalWins = totalWins;
        plan.totalPeriods = totalPeriods;
        plan.winRate = totalPeriods > 0 ? ((totalWins / totalPeriods) * 100).toFixed(2) + '%' : '0%';
        plan.winningPeriods = winningPeriods;
        plan.winningNumber = winningPeriods.length > 0 ? winningPeriods[0].winningNumber : null;
        
        // 更新验证详情
        plan.verificationDetails = {
          totalPeriods: totalPeriods,
          totalWins: totalWins,
          winRate: plan.winRate,
          winningPeriods: winningPeriods
        };
        
        // 检查是否有更新
        if (oldResult !== plan.result || oldTotalWins !== totalWins) {
          updatedCount++;
          console.log(`📊 计划 ${plan.planId} 验证结果更新: ${oldResult} -> ${plan.result}`);
        }
      });
      
      if (updatedCount > 0) {
        console.log(`✅ 全期验证更新完成，更新了 ${updatedCount} 个计划的结果`);
        
        // 保存更新后的计划数据到本地存储
        if (typeof window.PlanStorageManager !== 'undefined' && window.PlanStorageManager.saveToLocalStorage) {
          window.PlanStorageManager.saveToLocalStorage();
          console.log('💾 已保存更新后的计划验证状态到本地存储');
        }
        
        // 更新验证计划表格
        if (typeof window.updateVerifyPlanTable === 'function') {
          window.updateVerifyPlanTable();
        }
        
        // 显示更新通知
        this.showUpdateNotification({ updated: updatedCount, totalWins: window.verifyPlanData.reduce((sum, p) => sum + (p.totalWins || 0), 0) });
      } else {
        console.log('📊 全期验证完成，没有新的结果需要更新');
      }
    },
    
    // 显示更新通知
    showUpdateNotification: function(verifyResult) {
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        left: 20px;
        background: #2196F3;
        color: white;
        padding: 15px 20px;
        border-radius: 8px;
        z-index: 10000;
        font-size: 14px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        max-width: 350px;
      `;
      
      // 统计全期验证结果
      const totalPlans = window.verifyPlanData ? window.verifyPlanData.length : 0;
      const winningPlans = window.verifyPlanData ? window.verifyPlanData.filter(p => (p.totalWins || 0) > 0).length : 0;
      const losingPlans = totalPlans - winningPlans;
      const totalWins = verifyResult.totalWins || 0;
      
      notification.innerHTML = `
        <div style="font-weight: bold; margin-bottom: 5px;">📊 全期验证更新完成</div>
        <div>更新了 ${verifyResult.updated} 个计划</div>
        <div style="font-size: 12px; margin-top: 5px; opacity: 0.9;">
          有中奖: ${winningPlans} 个 | 全挂: ${losingPlans} 个
        </div>
        <div style="font-size: 12px; margin-top: 3px; opacity: 0.9;">
          总中奖期数: ${totalWins} 期
        </div>
      `;
      
      document.body.appendChild(notification);
      
      setTimeout(() => {
        if (document.body.contains(notification)) {
          document.body.removeChild(notification);
        }
      }, 6000);
    }
  };

  // 获取当前模块ID的函数
  function getCurrentModuleId() {
    // 方法1：查找所有存在的模块
    const allModules = document.querySelectorAll('[id^="module"]');
    
    // 方法2：如果无法通过事件确定，则查找第一个可见的模块
    for (const module of allModules) {
      if (module.style.display !== 'none' && !module.hidden) {
        return module.id.replace('module', '');
      }
    }
    
    // 默认返回模块1
    return '1';
  }

  function performVerification(moduleId = null, isRetry = false, isContinuous = false) {
    console.log('=== 自动验证开始 ===');
    
    // 获取当前模块标识
    const currentModuleId = moduleId || getCurrentModuleId();
    console.log('当前模块ID:', currentModuleId);
    
    // 获取指定模块的状态
    const targetModuleState = window.moduleStates[currentModuleId];
    if (!targetModuleState) {
      console.error(`模块${currentModuleId}的状态不存在`);
      return;
    }
    
    // 获取指定模块的DOM元素
    const targetModule = document.getElementById(`module${currentModuleId}`);
    if (!targetModule) {
      console.error(`模块${currentModuleId}的DOM元素不存在`);
      return;
    }
    
    const targetResultCount = targetModule.querySelector('.result-count');
    
    console.log('当前模块状态results:', targetModuleState.results);
    console.log('当前r数组:', r);
    console.log('r数组长度:', r ? r.length : 'r未定义');
    console.log('是否为重试:', isRetry);
    console.log('是否为持续验证模式:', isContinuous);
    
    if (targetModuleState.results.length === 0) {
      if (targetResultCount) {
        targetResultCount.innerHTML = '<span style="color: red;">没有可验证的结果</span>';
        setTimeout(() => {
          targetResultCount.textContent = `共${targetModuleState.results.length}注`;
        }, 2000);
      }
      return;
    }
    
    // 显示验证进度
    if (targetResultCount) {
      targetResultCount.innerHTML = '<span style="color: blue;">🔄 正在自动验证...</span>';
    }
    
    // 获取最新期数据
    if (!r || r.length === 0) {
      if (isRetry) {
        // 如果是重试且仍然没有数据，则停止递归
        console.log('重试后仍无数据，停止验证');
        if (targetResultCount) {
          targetResultCount.innerHTML = '<span style="color: red;">无法获取历史数据，请先在数据分析页面加载数据</span>';
          setTimeout(() => {
            targetResultCount.textContent = `共${targetModuleState.results.length}注`;
          }, 3000);
        }
        return;
      }
      
      console.log('验证失败：r数组为空或未定义，尝试重新获取历史数据');
      if (targetResultCount) {
        targetResultCount.innerHTML = '<span style="color: orange;">正在获取历史数据，请稍候...</span>';
      }
      
      // 尝试重新获取历史数据
      if (typeof fetchHistoryData === 'function') {
        fetchHistoryData().then(() => {
          console.log('历史数据重新获取完成，r数组长度:', r ? r.length : 0);
          if (r && r.length > 0) {
            // 数据获取成功，重新执行验证逻辑（标记为重试）
            setTimeout(() => {
              performVerification(currentModuleId, true); // 传递模块ID，标记为重试，防止无限递归
            }, 500);
          } else {
            if (targetResultCount) {
              targetResultCount.innerHTML = '<span style="color: red;">无法获取历史数据，请检查网络连接</span>';
              setTimeout(() => {
                targetResultCount.textContent = `共${targetModuleState.results.length}注`;
              }, 3000);
            }
          }
        }).catch(err => {
          console.error('重新获取历史数据失败:', err);
          if (targetResultCount) {
            targetResultCount.innerHTML = '<span style="color: red;">获取历史数据失败，请稍后重试</span>';
            setTimeout(() => {
              targetResultCount.textContent = `共${targetModuleState.results.length}注`;
            }, 3000);
          }
        });
      } else {
        if (targetResultCount) {
          targetResultCount.innerHTML = '<span style="color: red;">没有数据分析数据，请先在数据分析页面加载数据</span>';
          setTimeout(() => {
            targetResultCount.textContent = `共${targetModuleState.results.length}注`;
          }, 3000);
        }
      }
      return;
    }
    
    // 获取计划号码
    const planNumbers = targetModuleState.results;
    console.log('计划号码:', planNumbers);
    console.log(`开始验证计划对所有 ${r.length} 期历史数据`);
    
    // 验证所有历史期数
    let totalWins = 0;
    let totalPeriods = 0;
    let winningPeriods = [];
    let latestPeriod = r[0]; // 保留最新期用于记录
    
    r.forEach(periodData => {
      if (!periodData || !periodData.data || !periodData.period) {
        return;
      }
      
      const drawNumbers = periodData.data.slice(0, 5); // 取前五位作为开奖号码
      let periodWin = false;
      let winningNumber = null;
      
      // 验证计划中的每注号码
      for (const numberStr of planNumbers) {
        const numbers = numberStr.split(' ').map(n => parseInt(n.trim())); // 五星做号格式是空格分隔
        
        // 检查是否为有效的五星号码
        if (numbers.length === 5 && numbers.every(n => !isNaN(n))) {
          // 严格判定：前五位顺序完全一致才算中
          const exactMatch = numbers.every((num, idx) => num === drawNumbers.slice(0, 5)[idx]);
          
          if (exactMatch) {
            periodWin = true;
            winningNumber = numberStr;
            console.log(`🎉 期数 ${periodData.period} 命中（顺序完全一致）！号码: ${winningNumber}, 开奖前五: ${drawNumbers.slice(0, 5).join(',')}`);
            break; // 只要有一注命中就停止检查该期
          }
        }
      }
      
      totalPeriods++;
      if (periodWin) {
        totalWins++;
        winningPeriods.push({
          period: periodData.period,
          winningNumber: winningNumber,
          drawNumbers: drawNumbers.join(',')
        });
      }
    });
    
    console.log(`验证完成：${totalWins}/${totalPeriods}期中奖`);
    console.log('中奖期数详情:', winningPeriods);
    
    // 获取当前模块的生成条件
    const moduleState = window.moduleStates[currentModuleId];
    const groups = (moduleState && Array.isArray(moduleState.groups)) ? moduleState.groups.map(g => ({
      selectedNumbers: Array.isArray(g.selectedNumbers) ? [...g.selectedNumbers] : [],
      selectedDamas: Array.isArray(g.selectedDamas) ? [...g.selectedDamas] : [],
      toleranceMin: typeof g.toleranceMin === 'number' ? g.toleranceMin : 0,
      toleranceMax: typeof g.toleranceMax === 'number' ? g.toleranceMax : 0,
    })) : [];
    const flatSelectedNumbers = groups.reduce((acc, g) => acc.concat(g.selectedNumbers || []), []);
    const generationConditions = {
      selectedNumbers: flatSelectedNumbers,
      betMultiple: (moduleState && typeof moduleState.betMultiple !== 'undefined') ? moduleState.betMultiple : 1,
      periods: (moduleState && typeof moduleState.periods !== 'undefined') ? moduleState.periods : 1,
      moduleType: `${moduleState.starLevel || 5}星做号`,
      moduleId: currentModuleId,
      moduleToleranceMin: moduleState && typeof moduleState.moduleToleranceMin === 'number' ? moduleState.moduleToleranceMin : 0,
      moduleToleranceMax: moduleState && typeof moduleState.moduleToleranceMax === 'number' ? moduleState.moduleToleranceMax : 0,
      groups: groups,
      generatedAt: new Date().toISOString(),
      planHash: generatePlanHash(planNumbers, moduleState) // 生成计划唯一哈希
    };
    
    // 创建验证计划记录 - 优化数据结构，只保留关键信息
    const verifyRecord = {
      period: latestPeriod.period, // 最新期数（用于显示）
      planNumbers: planNumbers,
      betCount: planNumbers.length,
      result: totalWins > 0 ? `中${totalWins}期` : '全挂', // 显示中奖期数
      isCompleted: true, // 标记为已完成验证
      totalWins: totalWins,
      totalPeriods: totalPeriods,
      winRate: totalPeriods > 0 ? ((totalWins / totalPeriods) * 100).toFixed(2) + '%' : '0%',
      // 只保留最重要的中奖期数信息（最多保留3期）
      winningPeriods: winningPeriods.slice(0, 3),
      latestData: latestPeriod.data,
      winningNumber: winningPeriods.length > 0 ? winningPeriods[0].winningNumber : null,
      timestamp: new Date().toLocaleString(),
      moduleId: currentModuleId, // 保留模块标识用于内部逻辑
      planId: `plan_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`, // 添加唯一计划ID
      // 简化生成条件，只保留核心信息
      generationConditions: {
        planHash: generationConditions.planHash,
        moduleId: generationConditions.moduleId,
        timestamp: generationConditions.timestamp
      },
      planHash: generationConditions.planHash // 计划唯一标识
    };
    console.log('创建的验证记录:', verifyRecord);
    
    // 如果是持续验证模式，更新管理器的最后处理期数
    if (isContinuous && window.VerificationTaskManager) {
      window.VerificationTaskManager.lastProcessedPeriod = latestPeriod.period;
      console.log('🔄 持续验证模式：已更新最后处理期数为', latestPeriod.period);
    }
    
    // 使用计划存储管理器存储计划（已验证）
    const isStored = window.PlanStorageManager.storePlan(verifyRecord, true);
    
    if (!isStored) {
      // 理论上不会进入这里，storePlan 对重复计划会更新并返回 true
      console.log('⚠️ 计划存储未成功');
      if (targetResultCount) {
        targetResultCount.innerHTML = '<span style="color: orange;">⚠️ 计划存储未成功</span>';
      }
      setTimeout(() => {
        if (targetResultCount) {
          targetResultCount.textContent = `共${targetModuleState.results.length}注`;
        }
      }, 3000);
      // 不 return，继续后续渲染
    }
    
    console.log('验证计划数据已更新:', window.verifyPlanData);
    
    // 立即对新提交的计划进行历史数据全量验证
    console.log('🔍 开始对新提交的计划进行历史数据验证...');
    if (window.PlanDataUpdateListener && typeof window.PlanDataUpdateListener.verifyAllPlansAgainstHistory === 'function') {
      const historyVerifyResult = window.PlanDataUpdateListener.verifyAllPlansAgainstHistory();
      console.log('📊 历史数据验证结果:', historyVerifyResult);
      
      if (historyVerifyResult.updated > 0) {
        console.log(`✅ 历史数据验证完成，更新了 ${historyVerifyResult.updated} 个计划的结果`);
        
        // 显示历史验证结果提示
        if (targetResultCount) {
          const historyResults = historyVerifyResult.results.filter(r => r.isHistoryVerification);
          if (historyResults.length > 0) {
            const winCount = historyResults.filter(r => r.newResult === '中').length;
            const loseCount = historyResults.filter(r => r.newResult === '挂').length;
            const pendingCount = historyResults.filter(r => r.newResult === '待开奖').length;
            
            let historyMessage = '📊 历史验证: ';
            if (winCount > 0) historyMessage += `${winCount}中 `;
            if (loseCount > 0) historyMessage += `${loseCount}挂 `;
            if (pendingCount > 0) historyMessage += `${pendingCount}待开奖`;
            
            targetResultCount.innerHTML += `<br><span style="color: blue; font-size: 12px;">${historyMessage}</span>`;
          }
        }
      } else {
        console.log('📊 历史数据验证完成，没有新的结果需要更新');
      }
    } else {
      console.warn('⚠️ 历史数据验证功能不可用');
    }
    
    // 自动输出验证结果到控制台和页面
    const resultOutput = generateVerifyResultOutput(verifyRecord);
    console.log('\n=== 自动验证结果输出 ===');
    console.log(resultOutput.console);
    
    // 显示验证结果 - 全期验证结果
    if (targetResultCount) {
      if (totalWins > 0) {
        targetResultCount.innerHTML = `<span style="color: green;">✅ 验证完成！${totalWins}/${totalPeriods}期中奖 (${verifyRecord.winRate})</span>`;
      } else {
        targetResultCount.innerHTML = `<span style="color: red;">❌ 验证完成，全部${totalPeriods}期未中奖</span>`;
      }
    }
    
    // 根据验证模式决定是否切换页面
    if (!isContinuous) {
      // 单次验证模式：智能处理页面切换和数据更新
      
      // 检查验证计划数据获取服务是否已经在运行
      const isVerifyPlanServiceRunning = window.verifyPlanDataTimer || window.verifyPlanUpdateInterval;
      
      if (isVerifyPlanServiceRunning) {
        // 如果验证计划服务已经在运行，只更新数据，不切换页面
        console.log('验证计划服务已运行，直接更新数据，无需切换页面');
        
        // 更新验证计划表格
        if (typeof window.updateVerifyPlanTable === 'function') {
          window.updateVerifyPlanTable();
        }
        
        // 更新单期验证表格
        if (typeof window.updateSinglePeriodTable === 'function') {
          window.updateSinglePeriodTable();
        }
        
        // 显示成功提示
        if (targetResultCount) {
          targetResultCount.innerHTML = `<span style="color: green;">✅ 计划已添加到验证列表</span>`;
        }
      } else {
        // 如果验证计划服务未运行，启动服务但不切换页面
        console.log('首次验证，启动验证计划服务但保持在当前页面');
        
        // 启动验证计划页面的数据获取服务（后台运行）
        if (typeof startVerifyPlanDataFetch === 'function') {
          startVerifyPlanDataFetch();
        }
        
        // 更新验证计划表格数据（后台更新）
        if (typeof window.updateVerifyPlanTable === 'function') {
          window.updateVerifyPlanTable();
        }
        
        // 更新单期验证表格
        if (typeof window.updateSinglePeriodTable === 'function') {
          window.updateSinglePeriodTable();
        }
        
        // 显示成功提示，不跳转页面
        if (targetResultCount) {
          targetResultCount.innerHTML = `<span style="color: green;">✅ 验证完成！计划已添加到验证列表</span>`;
        }
      }
    } else {
      // 持续验证模式：只更新数据，不切换页面
      console.log('持续验证模式：更新数据但不切换页面');
      
      // 更新验证计划表格（如果当前在验证计划页面）
      if (typeof window.updateVerifyPlanTable === 'function') {
        window.updateVerifyPlanTable();
      }
      
      // 更新单期验证表格
      if (typeof window.updateSinglePeriodTable === 'function') {
        window.updateSinglePeriodTable();
      }
    }
    
    // 恢复原始显示
    setTimeout(() => {
      if (targetResultCount) {
        targetResultCount.textContent = `共${targetModuleState.results.length}注`;
      }
    }, 5000);
  }



  // 清理非当前用户计划的函数
  function cleanupNonUserPlans() {
    if (!window.verifyPlanData || window.verifyPlanData.length === 0) {
      return;
    }
    
    // 获取当前时间戳，用于判断是否为当前会话的计划
    const currentTime = new Date().getTime();
    const sessionStartTime = window.sessionStartTime || currentTime;
    
    // 如果没有设置会话开始时间，设置为当前时间
    if (!window.sessionStartTime) {
      window.sessionStartTime = currentTime;
    }
    
    // 过滤掉非当前会话的计划（保留最近1小时内创建的计划）
    const oneHourAgo = currentTime - (60 * 60 * 1000);
    const originalCount = window.verifyPlanData.length;
    
    window.verifyPlanData = window.verifyPlanData.filter(plan => {
      // 检查计划的生成时间
      if (plan.generationConditions && plan.generationConditions.generatedAt) {
        const planTime = new Date(plan.generationConditions.generatedAt).getTime();
        return planTime > oneHourAgo;
      }
      
      // 检查计划的时间戳
      if (plan.timestamp) {
        const planTime = new Date(plan.timestamp).getTime();
        return planTime > oneHourAgo;
      }
      
      // 如果没有时间信息，保留计划
      return true;
    });
    
    const cleanedCount = originalCount - window.verifyPlanData.length;
    if (cleanedCount > 0) {
      console.log(`🧹 清理了 ${cleanedCount} 个旧计划，当前剩余 ${window.verifyPlanData.length} 个计划`);
      
      // 更新单期验证表格
      if (typeof updateSinglePeriodTable === 'function') {
        updateSinglePeriodTable();
      }
    }
  }

  // 直接提交到单期验证的函数
  function submitToSinglePeriodVerification(moduleId, moduleState, onComplete) {
    console.log('=== 提交到单期验证开始 ===');
    
    try {
    
    // 清理非当前用户的旧计划
    cleanupNonUserPlans();
    
    // 获取计划号码
    const planNumbers = moduleState.results;
    console.log('计划号码:', planNumbers);
    
    // 获取当前模块的生成条件
    const groups = (moduleState && Array.isArray(moduleState.groups)) ? moduleState.groups.map(g => ({
      selectedNumbers: Array.isArray(g.selectedNumbers) ? [...g.selectedNumbers] : [],
      selectedDamas: Array.isArray(g.selectedDamas) ? [...g.selectedDamas] : [],
      toleranceMin: typeof g.toleranceMin === 'number' ? g.toleranceMin : 0,
      toleranceMax: typeof g.toleranceMax === 'number' ? g.toleranceMax : 0,
    })) : [];
    
    const flatSelectedNumbers = groups.reduce((acc, g) => acc.concat(g.selectedNumbers || []), []);
    const generationConditions = {
      selectedNumbers: flatSelectedNumbers,
      betMultiple: (moduleState && typeof moduleState.betMultiple !== 'undefined') ? moduleState.betMultiple : 1,
      periods: (moduleState && typeof moduleState.periods !== 'undefined') ? moduleState.periods : 1,
      moduleType: `${moduleState.starLevel || 5}星做号`,
      moduleId: moduleId,
      moduleToleranceMin: moduleState && typeof moduleState.moduleToleranceMin === 'number' ? moduleState.moduleToleranceMin : 0,
      moduleToleranceMax: moduleState && typeof moduleState.moduleToleranceMax === 'number' ? moduleState.moduleToleranceMax : 0,
      groups: groups,
      generatedAt: new Date().toISOString(),
      planHash: generatePlanHash(planNumbers, moduleState) // 生成计划唯一哈希
    };
    
    // 构建条件显示文本
    const allSelectedNumbers = [];
    const allSelectedDamas = [];
    
    groups.forEach(g => {
      const numbers = Array.isArray(g.selectedNumbers) ? g.selectedNumbers : [];
      const damas = Array.isArray(g.selectedDamas) ? g.selectedDamas : [];
      
      // 收集所有选择的数字（去重）
      numbers.forEach(num => {
        if (!allSelectedNumbers.includes(num)) {
          allSelectedNumbers.push(num);
        }
      });
      
      // 收集所有胆码（去重）
      damas.forEach(dama => {
        if (!allSelectedDamas.includes(dama)) {
          allSelectedDamas.push(dama);
        }
      });
    });
    
    // 构建显示文本
    const parts = [];
    if (allSelectedNumbers.length > 0) {
      allSelectedNumbers.sort((a, b) => parseInt(a) - parseInt(b));
      parts.push(allSelectedNumbers.join(','));
    }
    if (allSelectedDamas.length > 0) {
      allSelectedDamas.sort((a, b) => parseInt(a) - parseInt(b));
      parts.push(`中${allSelectedDamas.join(',')}胆`);
    }
    
    // 添加总容错信息
    const moduleToleranceMin = generationConditions.moduleToleranceMin || 0;
    const moduleToleranceMax = generationConditions.moduleToleranceMax || 0;
    if (moduleToleranceMin !== 0 || moduleToleranceMax !== 0) {
      if (moduleToleranceMin === moduleToleranceMax) {
        parts.push(`总容错${moduleToleranceMin}`);
      } else {
        parts.push(`总容错${moduleToleranceMin}-${moduleToleranceMax}`);
      }
    }
    
    const displayName = parts.join(' ') || `模块${moduleId}计划`;
    
    // 检查是否已存在相同的计划
    const existingPlan = window.verifyPlanData && window.verifyPlanData.find(plan => 
      plan.planHash === generationConditions.planHash
    );
    
    if (existingPlan) {
      console.log('⚠️ 检测到重复计划:', displayName);
      
      // 显示重复提示
      const targetModule = document.getElementById(`module${moduleId}`);
      const targetResultCount = targetModule ? targetModule.querySelector('.result-count') : null;
      if (targetResultCount) {
        targetResultCount.innerHTML = `<span style="color: orange;">⚠️ 重复计划，已存在相同条件的验证</span>`;
        setTimeout(() => {
          targetResultCount.textContent = `共${moduleState.results.length}注`;
        }, 3000);
      }
      return;
    }
    
    // 创建验证计划记录
    // 计算提交时的基准期号与目标期（下一期）
    let dataSource = (window.r && window.r.length > 0) ? window.r : ((window.historyData && window.historyData.length > 0) ? window.historyData : []);
    let latestPeriod = '';
    if (Array.isArray(dataSource) && dataSource.length > 0) {
      const sorted = dataSource.slice().sort((a, b) => parseInt(b.period) - parseInt(a.period));
      latestPeriod = sorted[0] && sorted[0].period ? sorted[0].period.toString() : '';
    }
    const nextPeriod = latestPeriod ? calculateNextPeriod(latestPeriod) : '';
    const verifyRecord = {
      period: latestPeriod || '',
      targetPeriod: nextPeriod || '',
      planNumbers: planNumbers,
      betCount: planNumbers.length,
      result: '待验证',
      totalWins: 0,
      totalPeriods: 0,
      winRate: '0%',
      winningPeriods: [],
      latestData: null,
      winningNumber: null,
      timestamp: new Date().toLocaleString(),
      moduleId: moduleId,
      planId: `plan_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      generationConditions: generationConditions,
      planHash: generationConditions.planHash,
      displayName: displayName,
      isCompleted: false, // 添加标志位记录是否已完成验证
      verificationDetails: {
        totalPeriods: 0,
        totalWins: 0,
        winRate: '0%',
        winningPeriods: []
      }
    };
    
    // 添加到验证计划数据
    if (!window.verifyPlanData) {
      window.verifyPlanData = [];
    }
    
    window.verifyPlanData.unshift(verifyRecord);
    console.log('✅ 计划已提交到单期验证:', displayName);
    console.log('当前验证计划数量:', window.verifyPlanData.length);
    
    // 自动保存到本地存储
    if (window.PlanStorageManager && typeof window.PlanStorageManager.storePlan === 'function') {
      try {
        window.PlanStorageManager.storePlan(verifyRecord, true);
        console.log('✅ 计划已自动保存到本地存储');
      } catch (saveError) {
        console.error('保存计划到本地存储失败:', saveError);
      }
    } else {
      console.warn('⚠️ PlanStorageManager 不可用，无法自动保存');
    }
    
    console.log('🔄 计划已提交到单期验证，将在下一期进行验证');
    
    // 重置单期验证状态，确保每次提交都是新的验证周期
    resetSinglePeriodVerification();
    
    // 更新单期验证表格
    if (typeof updateSinglePeriodTable === 'function') {
      updateSinglePeriodTable();
    }
    
    console.log('=== 提交到单期验证完成 ===');
    
    // 调用完成回调
    if (typeof onComplete === 'function') {
      onComplete(true, '提交成功');
    }
    
    } catch (error) {
      console.error('提交到单期验证时出错:', error);
      
      // 调用完成回调，传递错误信息
      if (typeof onComplete === 'function') {
        onComplete(false, error.message || '提交失败');
      }
    }
  }

  // 验证按钮事件监听器 - 直接提交到单期验证
  verifyBtn.addEventListener('click', function() {
    // 获取当前模块的状态和DOM元素
    const currentModuleState = window.moduleStates[moduleId];
    const currentResultCount = module.querySelector('.result-count');
    
    if (!currentModuleState || !currentResultCount) {
      console.error(`模块${moduleId}状态或DOM元素不存在`);
      return;
    }
    
    if (currentModuleState.results.length === 0) {
      currentResultCount.innerHTML = '<span style="color: red;">没有可验证的结果</span>';
      setTimeout(() => {
        currentResultCount.textContent = `共${currentModuleState.results.length}注`;
      }, 2000);
      return;
    }
    
    console.log(`🎯 用户点击验证按钮，直接提交模块${moduleId}到单期验证`);
    
    // 显示正在提交状态
    currentResultCount.innerHTML = '<span style="color: blue;">🔄 正在提交验证...</span>';
    
    // 直接提交到单期验证，使用回调处理结果
    submitToSinglePeriodVerification(moduleId, currentModuleState, function(success, message) {
      const currentCount = currentModuleState.results.length;
      
      if (success) {
        // 显示提交成功状态
        currentResultCount.innerHTML = `共${currentCount}注 <span style="color: green;">已提交到单期验证</span>`;
        
        // 3秒后移除验证提示，只保留注数
        setTimeout(() => {
          currentResultCount.textContent = `共${currentModuleState.results.length}注`;
        }, 3000);
      } else {
        // 显示提交失败状态
        currentResultCount.innerHTML = `<span style="color: red;">提交失败: ${message}</span>`;
        
        // 3秒后恢复注数显示
        setTimeout(() => {
          currentResultCount.textContent = `共${currentModuleState.results.length}注`;
        }, 3000);
      }
    });
  });
  
  // 生成验证结果输出
  function generateVerifyResultOutput(record) {
    const separator = '='.repeat(50);
    const timestamp = record.timestamp || new Date().toLocaleString();
    
    const consoleOutput = `
${separator}
🎯 自动验证结果报告
${separator}
📅 验证时间: ${timestamp}
🎲 开奖期数: ${record.period}
🔢 开奖号码: ${record.latestData.join(' ')}
📊 计划注数: ${record.betCount}注
🎯 验证结果: ${record.result}
${record.winningNumber ? `🏆 中奖号码: ${record.winningNumber}` : ''}

📋 计划号码:
${record.planNumbers.map((num, index) => `  ${index + 1}. ${num}`).join('\n')}

💡 验证说明: ${record.generationConditions?.moduleType || '5星做号'}玩法需要相应位置完全匹配开奖号码前几位
${separator}
    `;
    
    return {
      console: consoleOutput,
      summary: `期数:${record.period} | 结果:${record.result} | 注数:${record.betCount}`
    };
  }
  


  // 清除按钮点击事件
  clearBtn.addEventListener('click', function() {
    // 修复：按组清除选中状态
    moduleState.groups.forEach(group => {
        group.selectedNumbers = [];
        group.selectedDamas = [];
    });
    moduleState.results = [];
    moduleState.originalResults = [];
    moduleState.isReversed = false;
    
    // 清除所有按钮选中状态
    numberButtons.forEach(btn => btn.classList.remove('bg-primary', 'text-white'));
    damaButtons.forEach(btn => btn.classList.remove('bg-primary', 'text-white'));
    
    // 清除结果显示
    resultInput.value = '';
    resultCount.textContent = '共0注';
  });

  // 反向按钮点击事件 - 修改为显示筛选结果的补集
  reverseBtn.addEventListener('click', function() {
    // 检查是否已生成结果
    if (moduleState.allPermutations.length === 0 || moduleState.originalResults.length === 0) {
      alert('请先点击"做号"生成结果');
      return;
    }

    // 切换反向状态
    if (!moduleState.isReversed) {
      // 生成原始结果的补集（所有组合中排除原始结果）
      // 创建原始结果的字符串表示集合用于快速查找
      const originalSet = new Set(moduleState.originalResults);
      // 筛选出不在原始结果中的所有组合，并格式化
      const complementResults = moduleState.allPermutations
        .filter(comb => {
          const formattedComb = comb.map(num => num.toString().padStart(2, '0')).join(' ');
          return !originalSet.has(formattedComb);
        })
        .map(comb => comb.map(num => num.toString().padStart(2, '0')).join(' '));
      moduleState.results = complementResults;
      moduleState.isReversed = true;
    } else {
      // 恢复显示原始结果
      moduleState.results = moduleState.originalResults;
      moduleState.isReversed = false;
    }

    updateResultDisplay();
  });



  // 更新结果显示 - 版本2024.12.19
  function updateResultDisplay() {
    const totalCount = moduleState.results.length;
    const displayResults = totalCount > 200 ? moduleState.results.slice(0, 200) : moduleState.results;
    // 结果已经是格式化的字符串，直接用逗号连接（逗号后不加空格）
    let displayText = '';
    for (let i = 0; i < displayResults.length; i++) {
      if (i > 0) displayText += ',';
      displayText += displayResults[i];
    }
    
    // 立即设置结果
    resultInput.value = totalCount > 200 ? displayText + '...' : displayText;
    resultCount.textContent = `共${totalCount}注`;
    
    // 延迟再次确保格式正确（防止被其他代码覆盖）
    setTimeout(() => {
      resultInput.value = totalCount > 200 ? displayText + '...' : displayText;
    }, 10);
    

  }

  // 做号星级选择器事件处理
  if (moduleStarButtons && moduleStarButtons.length > 0) {
    // 星级描述映射
    const starDescriptions = {
      2: '当前：2星 - 从10个号码中选择2个号码组成一注',
      3: '当前：3星 - 从10个号码中选择3个号码组成一注',
      4: '当前：4星 - 从10个号码中选择4个号码组成一注',
      5: '当前：5星 - 从10个号码中选择5个号码组成一注'
    };

    moduleStarButtons.forEach(button => {
      button.addEventListener('click', function() {
        const selectedStar = parseInt(this.dataset.star);
        
        // 更新按钮样式
        moduleStarButtons.forEach(btn => {
          btn.classList.remove('bg-green-500', 'text-white', 'active', 'border-green-500');
          btn.classList.add('border-gray-200', 'text-gray-600');
          btn.style.borderWidth = '1px';
        });
        
        this.classList.remove('border-gray-200', 'text-gray-600');
        this.classList.add('bg-green-500', 'text-white', 'active', 'border-green-500');
        this.style.borderWidth = '2px';
        
        // 更新模块的星级设置
        moduleState.starLevel = selectedStar;
        
        // 更新描述
        if (moduleStarDescription) {
          moduleStarDescription.textContent = starDescriptions[selectedStar];
        }
        
        console.log(`模块${moduleId}星级已切换到: ${selectedStar}星`);
      });
    });
  }
}

// 页面加载时初始化现有模块
document.addEventListener('DOMContentLoaded', function() {
  // 初始化全局星级变量
  window.globalStarLevel = 5;
  
  // 初始化模块1和模块2
  if (!window.moduleStates || !window.moduleStates[1]) {
    initFiveStarModule(1);
  }
  if (!window.moduleStates || !window.moduleStates[2]) {
    initFiveStarModule(2);
  }
  
  // 初始化星级选择器事件监听器
  initStarSelector();
});

// 星级选择器初始化函数
function initStarSelector() {
  const starButtons = document.querySelectorAll('.star-btn');
  
  starButtons.forEach(button => {
    button.addEventListener('click', function() {
      const selectedStar = parseInt(this.dataset.star);
      
      // 更新按钮样式
      starButtons.forEach(btn => {
        btn.classList.remove('bg-green-500', 'text-white', 'active', 'border-green-500');
        btn.classList.add('border-gray-200', 'text-gray-600');
        btn.style.borderWidth = '1px';
      });
      
      this.classList.remove('border-gray-200', 'text-gray-600');
      this.classList.add('bg-green-500', 'text-white', 'active', 'border-green-500');
      this.style.borderWidth = '2px';
      
      // 更新全局星级设置（不覆盖模块的独立设置）
      if (window.globalStarLevel !== undefined) {
        window.globalStarLevel = selectedStar;
      }
      
      console.log(`拼接做号星级已切换到: ${selectedStar}星`);
    });
  });
  
  // 初始化号码显示区域的按钮事件
  initNumberDisplayButtons();
}

// 初始化号码显示区域的按钮功能
function initNumberDisplayButtons() {
  // 全局号码存储
  window.allGeneratedNumbers = [];
  
  // 拼接按钮功能
  const concatBtn = document.getElementById('concatBtn');
  if (concatBtn) {
    concatBtn.addEventListener('click', function() {
      // 获取当前选择的星级
      const activeStarBtn = document.querySelector('.star-btn.active');
      const selectedStar = activeStarBtn ? parseInt(activeStarBtn.dataset.star) : 5;
      
      // 根据星级调用相应的拼接函数
      generateStarConcatenation(selectedStar);
    });
  }
  
  // 复制按钮功能
  const copyAllBtn = document.getElementById('copyAllBtn');
  if (copyAllBtn) {
    copyAllBtn.addEventListener('click', function() {
      copyAllNumbers();
    });
  }
  
  // 验证按钮功能
  const verifyBtn = document.getElementById('verifyBtn');
  if (verifyBtn) {
    verifyBtn.addEventListener('click', function() {
      verifyNumbers();
    });
  }
}

// 五星做号页面的拼接功能（使用交集拼接逻辑）
function generateFiveStarConcatenation() {
    const selectedType = 5; // 五星做号固定为5星
    
    // 检查是否有做号模块结果
    if (!window.moduleStates || Object.keys(window.moduleStates).length === 0) {
        alert('请先进行做号，然后再进行拼接');
        return;
    }
    
    // 收集所有有效的做号模块
    const validModules = [];
    Object.keys(window.moduleStates).forEach(key => {
        const ms = window.moduleStates[key];
        if (ms && Array.isArray(ms.results) && ms.results.length > 0) {
            // 获取模块的位置信息
            let positions = Array.isArray(ms.selectedPositions) && ms.selectedPositions.length > 0
                ? ms.selectedPositions.slice()
                : Array.from({ length: ms.starLevel || 0 }, (_, i) => i + 1);
            
            // 解析模块结果
            const moduleResults = [];
            for (const line of ms.results) {
                if (typeof line !== 'string') continue;
                const parts = line.split(/\s+/).map(s => s.trim()).filter(Boolean);
                if (parts.length >= positions.length) {
                    const result = {};
                    for (let idx = 0; idx < positions.length; idx++) {
                        const pos = positions[idx];
                        const num = (parts[idx] || '').padStart(2, '0');
                        if (/^\d+$/.test(num)) {
                            result[pos] = num;
                        }
                    }
                    if (Object.keys(result).length === positions.length) {
                        moduleResults.push(result);
                    }
                }
            }
            
            if (moduleResults.length > 0) {
                validModules.push({
                    positions: positions,
                    results: moduleResults,
                    starLevel: ms.starLevel
                });
            }
        }
    });
    
    if (validModules.length === 0) {
        alert('没有找到有效的做号模块结果');
        return;
    }
    
    // 生成交集拼接结果
    const combinations = generateIntersectionCombinations(validModules, selectedType);
    
    // 更新五星做号页面的显示
    window.allGeneratedNumbers = combinations;
    updateNumberDisplay();
}

// 通用的星级拼接函数
function generateStarConcatenation(targetStarLevel) {
    // 检查是否有做号模块结果
    if (!window.moduleStates || Object.keys(window.moduleStates).length === 0) {
        alert('请先进行做号，然后再进行拼接');
        return;
    }
    
    // 定义拼接星级限制规则
    const starLevelRules = {
        3: [2],           // 3星拼接只能使用2星做号
        4: [2, 3],        // 4星拼接只能使用2星或3星做号
        5: [2, 3, 4]      // 5星拼接只能使用2星、3星或4星做号
    };
    
    // 检查目标星级是否支持拼接
    if (!starLevelRules[targetStarLevel]) {
        alert(`不支持 ${targetStarLevel} 星拼接功能`);
        return;
    }
    
    const allowedStarLevels = starLevelRules[targetStarLevel];
    
    // 收集所有有效的做号模块
    const validModules = [];
    const invalidModules = [];
    
    Object.keys(window.moduleStates).forEach(key => {
        const ms = window.moduleStates[key];
        if (ms && Array.isArray(ms.results) && ms.results.length > 0) {
            const moduleStarLevel = ms.starLevel || 0;
            
            // 检查做号星级是否符合拼接规则
            if (!allowedStarLevels.includes(moduleStarLevel)) {
                invalidModules.push({
                    key: key,
                    starLevel: moduleStarLevel
                });
                return; // 跳过不符合规则的模块
            }
            
            // 获取模块的位置信息
            let positions = Array.isArray(ms.selectedPositions) && ms.selectedPositions.length > 0
                ? ms.selectedPositions.slice()
                : Array.from({ length: ms.starLevel || 0 }, (_, i) => i + 1);
            
            // 解析模块结果
            const moduleResults = [];
            for (const line of ms.results) {
                if (typeof line !== 'string') continue;
                const parts = line.split(/\s+/).map(s => s.trim()).filter(Boolean);
                if (parts.length >= positions.length) {
                    const result = {};
                    for (let idx = 0; idx < positions.length; idx++) {
                        const pos = positions[idx];
                        const num = (parts[idx] || '').padStart(2, '0');
                        if (/^\d+$/.test(num)) {
                            result[pos] = num;
                        }
                    }
                    if (Object.keys(result).length === positions.length) {
                        moduleResults.push(result);
                    }
                }
            }
            
            if (moduleResults.length > 0) {
                validModules.push({
                    positions: positions,
                    results: moduleResults,
                    starLevel: ms.starLevel
                });
            }
        }
    });
    
    // 检查是否有不符合规则的模块
    if (invalidModules.length > 0) {
        const invalidStarLevels = [...new Set(invalidModules.map(m => m.starLevel))];
        const allowedStarLevelsStr = allowedStarLevels.join('星、') + '星';
        alert(`${targetStarLevel}星拼接只能使用${allowedStarLevelsStr}做号的结果。\n当前存在${invalidStarLevels.join('星、')}星做号结果，无法进行拼接。\n请删除不符合要求的做号模块或重新选择拼接星级。`);
        return;
    }
    
    if (validModules.length === 0) {
        const allowedStarLevelsStr = allowedStarLevels.join('星、') + '星';
        alert(`没有找到符合${targetStarLevel}星拼接要求的做号模块结果。\n请先进行${allowedStarLevelsStr}做号，然后再进行拼接。`);
        return;
    }
    
    // 生成交集拼接结果
    const combinations = generateIntersectionCombinations(validModules, targetStarLevel);
    
    // 更新显示
    window.allGeneratedNumbers = combinations;
    updateNumberDisplay();
    
    console.log(`已生成 ${targetStarLevel} 星拼接结果，共 ${combinations.length} 注`);
}

// 收集所有模块的号码（保留原有功能作为备用）
function collectAllNumbers() {
  window.allGeneratedNumbers = [];
  
  // 遍历所有模块，收集生成的号码
  if (window.moduleStates) {
    Object.keys(window.moduleStates).forEach(moduleId => {
      const moduleState = window.moduleStates[moduleId];
      if (moduleState && moduleState.results && moduleState.results.length > 0) {
        window.allGeneratedNumbers = window.allGeneratedNumbers.concat(moduleState.results);
      }
    });
  }
  
  updateNumberDisplay();
}

// 更新号码显示区域
function updateNumberDisplay() {
  const numberDisplay = document.getElementById('numberDisplay');
  const numberCount = document.getElementById('numberCount');
  
  if (!numberDisplay || !numberCount) return;
  
  const totalCount = window.allGeneratedNumbers.length;
  
  if (totalCount === 0) {
    numberDisplay.innerHTML = '<div class="text-gray-500 text-center py-8">暂无生成的号码</div>';
    numberCount.textContent = '共 0 注';
    return;
  }
  
  // 显示前200注，剩余的省略
  const displayCount = Math.min(200, totalCount);
  const displayNumbers = window.allGeneratedNumbers.slice(0, displayCount);
  
  let html = displayNumbers.join(',');
  
  if (totalCount > 200) {
    html += `<div class="text-gray-400 text-center mt-3 py-2 border-t">... 还有 ${totalCount - 200} 注号码未显示</div>`;
  }
  
  numberDisplay.innerHTML = html;
  numberCount.textContent = `共 ${totalCount} 注`;
}

// 复制所有号码到剪贴板
function copyAllNumbers() {
  if (!window.allGeneratedNumbers || window.allGeneratedNumbers.length === 0) {
    alert('暂无号码可复制');
    return;
  }
  
  const numbersText = window.allGeneratedNumbers.join(',');
  
  // 使用现代剪贴板API
  if (navigator.clipboard && window.isSecureContext) {
    navigator.clipboard.writeText(numbersText).then(() => {
      alert(`已复制 ${window.allGeneratedNumbers.length} 注号码到剪贴板`);
    }).catch(err => {
      console.error('复制失败:', err);
      fallbackCopyTextToClipboard(numbersText);
    });
  } else {
    // 降级方案
    fallbackCopyTextToClipboard(numbersText);
  }
}

// 降级复制方案
function fallbackCopyTextToClipboard(text) {
  const textArea = document.createElement("textarea");
  textArea.value = text;
  textArea.style.top = "0";
  textArea.style.left = "0";
  textArea.style.position = "fixed";
  
  document.body.appendChild(textArea);
  textArea.focus();
  textArea.select();
  
  try {
    const successful = document.execCommand('copy');
    if (successful) {
      alert(`已复制 ${window.allGeneratedNumbers.length} 注号码到剪贴板`);
    } else {
      alert('复制失败，请手动复制');
    }
  } catch (err) {
    console.error('降级复制也失败:', err);
    alert('复制失败，请手动复制');
  }
  
  document.body.removeChild(textArea);
}

// 验证号码功能 - 直接提交到验证计划
function verifyNumbers() {
  if (!window.allGeneratedNumbers || window.allGeneratedNumbers.length === 0) {
    // 更新页面显示状态，不使用弹窗
    const numberCount = document.getElementById('numberCount');
    if (numberCount) {
      numberCount.innerHTML = '<span style="color: red;">暂无号码可验证</span>';
      setTimeout(() => {
        numberCount.textContent = '共 0 注';
      }, 3000);
    }
    return;
  }
  
  // 直接提交到验证计划，不显示弹窗
  submitAllNumbersToVerification();
}

// 统一的验证提交函数 - 处理做号拼接页面的所有号码
function submitAllNumbersToVerification() {
  const numberCount = document.getElementById('numberCount');
  
  if (!window.allGeneratedNumbers || window.allGeneratedNumbers.length === 0) {
    if (numberCount) {
      numberCount.innerHTML = '<span style="color: red;">没有可验证的号码</span>';
      setTimeout(() => {
        numberCount.textContent = '共 0 注';
      }, 3000);
    }
    return;
  }
  
  // 显示正在提交状态
  if (numberCount) {
    numberCount.innerHTML = `<span style="color: blue;">🔄 正在提交 ${window.allGeneratedNumbers.length} 注到验证计划...</span>`;
  }
  
  try {
    // 创建验证计划数据
    const planData = {
      planId: `拼接验证_${Date.now()}`,
      displayName: `做号拼接验证 (${window.allGeneratedNumbers.length}注)`,
      planNumbers: [...window.allGeneratedNumbers],
      betCount: window.allGeneratedNumbers.length,
      generationConditions: {
        moduleType: '做号拼接',
        timestamp: new Date().toLocaleString(),
        source: '做号拼接页面'
      },
      planHash: `concat_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
    };
    
    // 确保验证计划数据数组已初始化
    if (!window.verifyPlanData) {
      window.verifyPlanData = [];
    }
    
    // 添加到验证计划数据
    window.verifyPlanData.push(planData);
    
    console.log('✅ 做号拼接验证计划已提交:', planData.displayName);
    console.log('当前验证计划数量:', window.verifyPlanData.length);
    
    // 启动验证计划服务（如果尚未启动）
    if (typeof startVerifyPlanDataFetching === 'function') {
      startVerifyPlanDataFetching();
    }
    
    // 更新验证计划表格（如果当前在验证计划页面）
    if (typeof updateVerifyPlanTable === 'function') {
      updateVerifyPlanTable();
    }
    
    // 更新单期验证表格
    if (typeof updateSinglePeriodVerificationTable === 'function') {
      updateSinglePeriodVerificationTable();
    }
    
    // 显示提交成功状态
    if (numberCount) {
      numberCount.innerHTML = `共 ${window.allGeneratedNumbers.length} 注 <span style="color: green;">已提交到验证计划</span>`;
      
      // 3秒后恢复正常显示
      setTimeout(() => {
        numberCount.textContent = `共 ${window.allGeneratedNumbers.length} 注`;
      }, 3000);
    }
    
    console.log('=== 做号拼接验证提交完成 ===');
    
  } catch (error) {
    console.error('提交做号拼接验证时出错:', error);
    
    // 显示提交失败状态
    if (numberCount) {
      numberCount.innerHTML = `<span style="color: red;">提交失败: ${error.message || '未知错误'}</span>`;
      
      // 3秒后恢复正常显示
      setTimeout(() => {
        numberCount.textContent = `共 ${window.allGeneratedNumbers.length} 注`;
      }, 3000);
    }
  }
}


// 旧的模块初始化函数已被新的 initFiveStarModule 函数替代

// 添加模块功能
function addModule(currentModuleId) {
  const modulesContainer = document.getElementById('modules-container');
  const moduleElements = modulesContainer.querySelectorAll('.five-star-module');

  // 检查模块数量上限（最多14个）
  if (moduleElements.length >= 14) {
    alert('最多只能添加14个模块');
    return;
  }

  // 获取最后一个模块ID并递增
  const lastModuleId = parseInt(moduleElements[moduleElements.length - 1].id.replace('module', ''));
  const newModuleId = lastModuleId + 1;

  // 克隆当前模块
  const currentModule = document.getElementById(`module${currentModuleId}`);
  const newModule = currentModule.cloneNode(true);
  newModule.id = `module${newModuleId}`;
  newModule.querySelectorAll('[data-module]').forEach(el => {
    el.dataset.module = newModuleId;
  });
  resetModuleState(newModule);

  // 克隆当前模块后添加以下代码
  const newAddBtn = newModule.querySelector('.add-btn');
  newAddBtn.setAttribute('onclick', `addModule(${newModuleId})`);

  const newRemoveBtn = newModule.querySelector('.remove-btn');
  newRemoveBtn.setAttribute('onclick', `removeModule(${newModuleId})`);

  // 添加到容器
  modulesContainer.appendChild(newModule);
  
  // 初始化新模块
  initFiveStarModule(newModuleId);
}

// 移除模块功能
function removeModule(moduleId) {
  const modulesContainer = document.getElementById('modules-container');
  const moduleElements = modulesContainer.querySelectorAll('.five-star-module');
  const moduleToRemove = document.getElementById(`module${moduleId}`);
  
  if (moduleElements.length <= 2) {
    alert('至少保留2个模块');
    return;
  }
  
  moduleToRemove.remove();
}

// 重置模块状态
function resetModuleState(module) {
  // 重置按钮状态
  module.querySelectorAll('.number-btn, .dama-btn').forEach(btn => {
    btn.classList.remove('bg-primary', 'text-white');
  });
  
  // 重置输入和显示
  module.querySelector('.result-input').value = '';
  module.querySelector('.result-count').textContent = '共0注';
  
  // 重置模块总容错为默认值0-0
  const toleranceMinSelect = module.querySelector('.module-tolerance-min');
  const toleranceMaxSelect = module.querySelector('.module-tolerance-max');
  if (toleranceMinSelect) toleranceMinSelect.value = '0';
  if (toleranceMaxSelect) toleranceMaxSelect.value = '0';
}

// 重复的permute函数已删除，使用上面的迭代版本

// Tailwind配置
tailwind.config = {
  theme: {
    extend: {
      colors: {
        primary: '#d62828',
        secondary: '#f77f00',
        neutral: '#f5f5f5',
        dark: '#333333'
      },
      fontFamily: {
        sans: ['Inter', 'system-ui', 'sans-serif']
      }
    }
  }
};

// 页面切换功能
document.addEventListener('DOMContentLoaded', function() {
  // 云端数据库功能已禁用
  
  // 页面加载时自动从MongoDB数据库加载数据 - 已禁用云端数据库功能
  async function fetchLatestData() {
    // 云端数据库功能已禁用
    console.log('云端数据库功能已禁用');
    const currentTime = new Date().toLocaleTimeString();
    if (v) {
      v.textContent = `云端数据库功能已禁用，请手动输入数据 (${currentTime})`;
    }
    
    // 清空现有数据
    r = [];
    d.clear();
    
    // 更新页面显示
    document.getElementById("periodCount").textContent = 0;
    
    // 重新渲染表格 - 移除立即筛选，等待确认按钮点击
    // if (typeof L === 'function') {
    //   L();
    // }
  }

  
  // 云端数据库功能已禁用 - 不再自动获取数据
  // fetchLatestData(); // 已禁用
  
  // 云端数据库功能已禁用 - 不再设置定时器
  // setInterval(() => {
  //   console.log('定时刷新数据...');
  //   fetchLatestData();
  // }, 5000); // 已禁用
  
  console.log('云端数据库功能已禁用，请手动输入数据');
  
  const dataAnalysisBtn = document.getElementById('dataAnalysisBtn');
  const fiveStarBtn = document.getElementById('fiveStarBtn');
  const verifyPlanBtn = document.getElementById('verifyPlanBtn');
  const goldenRatioBtn = document.getElementById('goldenRatioBtn');
  const intersectionCutBtn = document.getElementById('intersectionCutBtn');
  const dataAnalysisPage = document.getElementById('dataAnalysisPage');
  const fiveStarPage = document.getElementById('fiveStarPage');
  const verifyPlanPage = document.getElementById('verifyPlanPage');
  const goldenRatioPage = document.getElementById('goldenRatioPage');
  const intersectionCutPage = document.getElementById('intersectionCutPage');
  
  // 滚动位置保存和恢复功能
  const scrollPositions = {
    dataAnalysis: 0,
    fiveStar: 0,
    verifyPlan: 0,
    goldenRatio: 0,
    intersectionCut: 0
  };
  
  // 保存当前页面的滚动位置
  function saveScrollPosition(pageType) {
    scrollPositions[pageType] = window.pageYOffset || document.documentElement.scrollTop;
  }
  
  // 恢复指定页面的滚动位置
  function restoreScrollPosition(pageType) {
    // 使用requestAnimationFrame确保在下一帧渲染时恢复滚动位置，避免卡顿
    requestAnimationFrame(() => {
      window.scrollTo({
        top: scrollPositions[pageType],
        behavior: 'instant' // 使用instant避免滚动动画
      });
    });
  }
  
  // 获取当前显示的页面类型
  function getCurrentPageType() {
    if (!dataAnalysisPage.classList.contains('hidden')) return 'dataAnalysis';
    if (!fiveStarPage.classList.contains('hidden')) return 'fiveStar';
    if (!verifyPlanPage.classList.contains('hidden')) return 'verifyPlan';
    if (!goldenRatioPage.classList.contains('hidden')) return 'goldenRatio';
    if (!intersectionCutPage.classList.contains('hidden')) return 'intersectionCut';
    return 'dataAnalysis'; // 默认
  }

  if (dataAnalysisBtn && fiveStarBtn && verifyPlanBtn && goldenRatioBtn && intersectionCutBtn && dataAnalysisPage && fiveStarPage && verifyPlanPage && goldenRatioPage && intersectionCutPage) {
    dataAnalysisBtn.addEventListener('click', function() {
      // 禁用滚动监听，防止页面切换时跳动
      disableScrollListener();
      
      // 保存当前页面的滚动位置
      const currentPage = getCurrentPageType();
      saveScrollPosition(currentPage);
      
      // 移除单期验证轮询调用
      
      // 不再停止验证计划页面的数据获取，让验证服务在后台持续运行
      // stopVerifyPlanDataFetch(); // 已注释，保持验证服务运行
      
      // 切换页面
      dataAnalysisPage.classList.remove('hidden');
      fiveStarPage.classList.add('hidden');
      verifyPlanPage.classList.add('hidden');
      goldenRatioPage.classList.add('hidden');
      intersectionCutPage.classList.add('hidden');
      dataAnalysisBtn.classList.add('bg-primary');
      dataAnalysisBtn.classList.remove('bg-gray-600');
      fiveStarBtn.classList.add('bg-gray-600');
      fiveStarBtn.classList.remove('bg-primary');
      verifyPlanBtn.classList.add('bg-gray-600');
      verifyPlanBtn.classList.remove('bg-primary');
      goldenRatioBtn.classList.add('bg-gray-600');
      goldenRatioBtn.classList.remove('bg-primary');
      intersectionCutBtn.classList.add('bg-gray-600');
      intersectionCutBtn.classList.remove('bg-primary');
      
      // 恢复数据分析页面的滚动位置
      restoreScrollPosition('dataAnalysis');
    });
    
    fiveStarBtn.addEventListener('click', function() {
      // 禁用滚动监听，防止页面切换时跳动
      disableScrollListener();
      
      // 保存当前页面的滚动位置
      const currentPage = getCurrentPageType();
      saveScrollPosition(currentPage);
      
      // 移除单期验证轮询调用
      
      // 不再停止验证计划页面的数据获取，让验证服务在后台持续运行
      // stopVerifyPlanDataFetch(); // 已注释，保持验证服务运行
      
      // 切换页面
      dataAnalysisPage.classList.add('hidden');
      fiveStarPage.classList.remove('hidden');
      verifyPlanPage.classList.add('hidden');
      goldenRatioPage.classList.add('hidden');
      intersectionCutPage.classList.add('hidden');
      fiveStarBtn.classList.add('bg-primary');
      fiveStarBtn.classList.remove('bg-gray-600');
      dataAnalysisBtn.classList.add('bg-gray-600');
      dataAnalysisBtn.classList.remove('bg-primary');
      verifyPlanBtn.classList.add('bg-gray-600');
      verifyPlanBtn.classList.remove('bg-primary');
      goldenRatioBtn.classList.add('bg-gray-600');
      goldenRatioBtn.classList.remove('bg-primary');
      intersectionCutBtn.classList.add('bg-gray-600');
      intersectionCutBtn.classList.remove('bg-primary');
      
      // 恢复五星做号页面的滚动位置
      restoreScrollPosition('fiveStar');
    });
    
    verifyPlanBtn.addEventListener('click', function() {
      // 禁用滚动监听，防止页面切换时跳动
      disableScrollListener();
      
      // 保存当前页面的滚动位置
      const currentPage = getCurrentPageType();
      saveScrollPosition(currentPage);
      
      // 切换页面
      dataAnalysisPage.classList.add('hidden');
      fiveStarPage.classList.add('hidden');
      verifyPlanPage.classList.remove('hidden');
      goldenRatioPage.classList.add('hidden');
      intersectionCutPage.classList.add('hidden');
      verifyPlanBtn.classList.add('bg-primary');
      verifyPlanBtn.classList.remove('bg-gray-600');
      dataAnalysisBtn.classList.add('bg-gray-600');
      dataAnalysisBtn.classList.remove('bg-primary');
      fiveStarBtn.classList.add('bg-gray-600');
      fiveStarBtn.classList.remove('bg-primary');
      goldenRatioBtn.classList.add('bg-gray-600');
      goldenRatioBtn.classList.remove('bg-primary');
      intersectionCutBtn.classList.add('bg-gray-600');
      intersectionCutBtn.classList.remove('bg-primary');
      
      // 启动验证计划页面的数据加载和自动更新
      startVerifyPlanDataFetch();
      
      // 恢复验证计划页面的滚动位置
      restoreScrollPosition('verifyPlan');
    });
    
    goldenRatioBtn.addEventListener('click', function() {
      // 禁用滚动监听，防止页面切换时跳动
      disableScrollListener();
      
      // 保存当前页面的滚动位置
      const currentPage = getCurrentPageType();
      saveScrollPosition(currentPage);
      
      // 移除单期验证轮询调用
      
      // 不再停止验证计划页面的数据获取，让验证服务在后台持续运行
      // stopVerifyPlanDataFetch(); // 已注释，保持验证服务运行
      
      // 切换页面
      dataAnalysisPage.classList.add('hidden');
      fiveStarPage.classList.add('hidden');
      verifyPlanPage.classList.add('hidden');
      goldenRatioPage.classList.remove('hidden');
      intersectionCutPage.classList.add('hidden');
      goldenRatioBtn.classList.add('bg-primary');
      goldenRatioBtn.classList.remove('bg-gray-600');
      dataAnalysisBtn.classList.add('bg-gray-600');
      dataAnalysisBtn.classList.remove('bg-primary');
      fiveStarBtn.classList.add('bg-gray-600');
      fiveStarBtn.classList.remove('bg-primary');
      verifyPlanBtn.classList.add('bg-gray-600');
      verifyPlanBtn.classList.remove('bg-primary');
      intersectionCutBtn.classList.add('bg-gray-600');
      intersectionCutBtn.classList.remove('bg-primary');
      
      // 恢复黄金切割页面的滚动位置
      restoreScrollPosition('goldenRatio');
    });

    // 交集拼接按钮事件监听器
    intersectionCutBtn.addEventListener('click', function() {
      // 禁用滚动监听，防止页面切换时跳动
      disableScrollListener();
      
      // 保存当前页面的滚动位置
      const currentPage = getCurrentPageType();
      saveScrollPosition(currentPage);
      
      // 移除单期验证轮询调用
      
      // 切换页面
      dataAnalysisPage.classList.add('hidden');
      fiveStarPage.classList.add('hidden');
      verifyPlanPage.classList.add('hidden');
      goldenRatioPage.classList.add('hidden');
      intersectionCutPage.classList.remove('hidden');
      
      // 更新按钮样式
      intersectionCutBtn.classList.add('bg-primary');
      intersectionCutBtn.classList.remove('bg-gray-600');
      dataAnalysisBtn.classList.add('bg-gray-600');
      dataAnalysisBtn.classList.remove('bg-primary');
      fiveStarBtn.classList.add('bg-gray-600');
      fiveStarBtn.classList.remove('bg-primary');
      verifyPlanBtn.classList.add('bg-gray-600');
      verifyPlanBtn.classList.remove('bg-primary');
      goldenRatioBtn.classList.add('bg-gray-600');
      goldenRatioBtn.classList.remove('bg-primary');
      
      // 恢复交集拼接页面的滚动位置
      restoreScrollPosition('intersectionCut');
    });

  } else {
    console.error('页面切换所需元素未找到');
  }
  
  // 页面加载时检查当前显示的页面，启动相应的数据获取
  const currentPageType = getCurrentPageType();
  if (currentPageType === 'verifyPlan') {
    // 如果当前显示验证计划页面，启动数据获取
    startVerifyPlanDataFetch();
  }
  
  // 手机端上滑全屏功能
  let lastScrollY = 0;
  let isFullscreen = false;
  let scrollTimeout = null;
  
  // 检测是否为手机端
  function isMobile() {
    return window.innerWidth <= 768;
  }
  
  // 切换全屏模式
  function toggleFullscreen(enable) {
    if (!isMobile()) return;
    
    const header = document.querySelector('header');
    const titleArea = header.querySelector('.container');
    const toolbarArea = header.querySelector('.bg-gray-800');
    const keyCountdown = document.getElementById('keyCountdown');
    
    if (enable && !isFullscreen) {
      // 进入全屏模式
      isFullscreen = true;
      
      // 隐藏标题区域
      if (titleArea) {
        titleArea.style.transform = 'translateY(-100%)';
        titleArea.style.transition = 'transform 0.3s ease-in-out';
      }
      
      // 隐藏密钥倒计时栏（完全隐藏并释放空间）
      if (keyCountdown && !keyCountdown.classList.contains('hidden')) {
        keyCountdown.style.height = '0';
        keyCountdown.style.opacity = '0';
        keyCountdown.style.paddingTop = '0';
        keyCountdown.style.paddingBottom = '0';
        keyCountdown.style.overflow = 'hidden';
        keyCountdown.style.transition = 'all 0.3s ease-in-out';
      }
      
      // 调整工具栏位置到顶部
      if (toolbarArea) {
        toolbarArea.style.position = 'fixed';
        toolbarArea.style.top = '0';
        toolbarArea.style.left = '0';
        toolbarArea.style.right = '0';
        toolbarArea.style.zIndex = '1000';
        toolbarArea.style.transition = 'all 0.3s ease-in-out';
      }
      
      // 调整主内容区域的上边距
      const main = document.querySelector('main');
      if (main) {
        main.style.paddingTop = '50px'; // 工具栏高度
        main.style.transition = 'padding-top 0.3s ease-in-out';
      }
      
    } else if (!enable && isFullscreen) {
      // 退出全屏模式
      isFullscreen = false;
      
      // 显示标题区域
      if (titleArea) {
        titleArea.style.transform = 'translateY(0)';
      }
      
      // 显示密钥倒计时栏（恢复原始高度和样式）
      if (keyCountdown && !keyCountdown.classList.contains('hidden')) {
        keyCountdown.style.height = 'auto';
        keyCountdown.style.opacity = '1';
        keyCountdown.style.paddingTop = '0.5rem';
        keyCountdown.style.paddingBottom = '0.5rem';
        keyCountdown.style.overflow = 'visible';
        keyCountdown.style.transition = 'all 0.3s ease-in-out';
      }
      
      // 恢复工具栏位置
      if (toolbarArea) {
        toolbarArea.style.position = '';
        toolbarArea.style.top = '';
        toolbarArea.style.left = '';
        toolbarArea.style.right = '';
        toolbarArea.style.zIndex = '';
      }
      
      // 恢复主内容区域的上边距
      const main = document.querySelector('main');
      if (main) {
        main.style.paddingTop = '';
      }
    }
  }
  
  // 滚动事件监听
  function handleScroll() {
    if (!isMobile()) return;
    
    const currentScrollY = window.pageYOffset || document.documentElement.scrollTop;
    const scrollDelta = currentScrollY - lastScrollY;
    
    // 清除之前的定时器
    if (scrollTimeout) {
      clearTimeout(scrollTimeout);
    }
    
    // 设置新的定时器，延迟执行以避免频繁切换
    scrollTimeout = setTimeout(() => {
      // 向上滑动且滑动距离超过50px时进入全屏
      if (scrollDelta < -50 && currentScrollY > 100) {
        toggleFullscreen(true);
      }
      // 向下滑动且滑动距离超过30px时退出全屏
      // 或者滚动到页面顶部附近时也退出全屏
      else if (scrollDelta > 30 || currentScrollY < 50) {
        toggleFullscreen(false);
      }
    }, 150); // 增加延迟时间，减少误触发
    
    lastScrollY = currentScrollY;
  }
  
  // 添加滚动事件监听器
  window.addEventListener('scroll', handleScroll, { passive: true });
  
  // 为工具栏按钮添加点击事件监听，防止误触发全屏
  const toolbarButtons = document.querySelectorAll('.bg-gray-800 button');
  toolbarButtons.forEach(button => {
    button.addEventListener('click', () => {
      // 点击按钮时暂时禁用滚动检测
      if (scrollTimeout) {
        clearTimeout(scrollTimeout);
      }
      // 短暂延迟后重新启用滚动检测
      setTimeout(() => {
        lastScrollY = window.pageYOffset || document.documentElement.scrollTop;
      }, 300);
    });
  });
  
  // 窗口大小改变时重置全屏状态
  window.addEventListener('resize', () => {
    if (!isMobile() && isFullscreen) {
      toggleFullscreen(false);
    }
  });
});

// 重复的初始化代码已移除
let r=[],i=1,a=null,s=null,d=new Set,u=null,l=null,m=!1,f=15,y=!1,hitRateSort=!1,currentPage=1,pageSize=50,totalPages=1;

// 多重加密验证状态系统
let _0x1a2b3c = false;
let _0x4d5e6f = null;
let _0x7g8h9i = [];
let _0x0j1k2l = new Date().getTime();
let _0x3m4n5o = 'aGVsbG93b3JsZA==';
let _0x9p8q7r = Math.random().toString(36).substring(2);
let _0x5s6t7u = btoa(window.location.href).slice(-10);

// 验证令牌生成和检查系统
function _0xVerifyToken() {
    const _0xTime = new Date().getTime();
    const _0xDiff = _0xTime - _0x0j1k2l;
    if (_0xDiff > 28800000) return false; // 8小时过期
    
    const _0xHash = btoa(String.fromCharCode(..._0x7g8h9i));
    const _0xCheck = _0x4d5e6f && _0x1a2b3c && _0xHash.length > 0;
    
    // 额外的完整性检查
    const _0xIntegrity = _0x9p8q7r.length > 5 && _0x5s6t7u.length > 5;
    
    return _0xCheck && _0xIntegrity;
}

// 设置验证状态
function _0xSetAuth(_0xToken) {
    _0x1a2b3c = true;
    _0x4d5e6f = _0xToken;
    _0x7g8h9i = Array.from(_0xToken).map(c => c.charCodeAt(0));
    _0x0j1k2l = new Date().getTime();
    _0x9p8q7r = btoa(_0xToken).slice(0, 10);
    _0xStartTimer(); // 启动定时验证
}

// 验证检查包装器
function _0xAuthCheck() {
    if (!_0xIntegrityCheck()) return false;
    if (!_0xAntiDebug()) {
        _0x1a2b3c = 0;
        return false;
    }
    if (!_0xVerifyToken()) {
        return false;
    }
    return true;
}

// 假的验证逻辑 - 陷阱代码
let fakeAuth = false;
function enableFakeAuth() { fakeAuth = true; }
function checkFakeAuth() { return fakeAuth; }
function validateLicense() { return Math.random() > 0.5; }
function isValidUser() { return localStorage.getItem('user') === 'valid'; }

// 反调试检查
function _0xAntiDebug() {
    const start = performance.now();
    debugger;
    const end = performance.now();
    return (end - start) < 100;
}

// 动态验证码生成
function _0xDynamicCode() {
    const timestamp = Date.now();
    const random = Math.floor(Math.random() * 1000000);
    return btoa(timestamp + ':' + random + ':' + _0x1a2b3c);
}

// 定时验证检查
// 定时验证机制 - 只有在用户已验证后才启动
let _0xTimerStarted = false;
function _0xStartTimer() {
    if (_0xTimerStarted) return;
    _0xTimerStarted = true;
    setInterval(() => {
        if (_0x1a2b3c && !_0xAuthCheck()) {
            document.body.innerHTML = '<div style="text-align:center;padding:50px;color:red;">验证失效，请重新加载页面</div>';
            setTimeout(() => location.reload(), 2000);
        }
    }, 300000); // 每5分钟检查一次
}

// 代码完整性检查
function _0xIntegrityCheck() {
    const _0xFuncs = [_0xVerifyToken, _0xSetAuth, _0xAuthCheck];
    for (let _0xFunc of _0xFuncs) {
        if (typeof _0xFunc !== 'function') {
            document.body.innerHTML = '<div style="text-align:center;padding:50px;color:red;">系统检测到异常，请刷新页面</div>';
            return false;
        }
    }
    return true;
}

// 兼容性变量（保持原有功能）
// 兼容性变量（保持原有功能）
let b = false;
const h = "pk4_access_key";
const g = document.getElementById("keyModal");
const p = document.getElementById("keyInput");
const v = document.getElementById("output");
const x = document.getElementById("tableContainer");
const w = document.getElementById("horizontalThumb");
const k = document.getElementById("horizontalFill");
const $ = document.getElementById("verticalSlider");
const B = document.getElementById("verticalThumb");
const I = document.getElementById("verticalFill");
const M = document.getElementById("numButtons");

function N(t) {
    t.forEach(e => e.addEventListener("click", () => {
        t.forEach(t => t.classList.remove("btn-active"));
        e.classList.add("btn-active");
        console.log('位置选择已更改，等待确认按钮点击');
    }));
}

function C(t) {
    t.forEach(t => {
        // 设置初始样式
        t.style.backgroundColor = '#e5e7eb'; // gray-200
        t.style.color = '#374151'; // gray-700
        t.style.cursor = 'pointer';
        t.style.transition = 'all 0.2s ease';
        
        t.addEventListener("click", (e) => {
            e.preventDefault();
            e.stopPropagation();
            
            console.log('*** 命中码数按钮点击事件触发 ***', t.textContent, t.dataset.hit);
            
            // 切换选中状态
            if (t.classList.contains("btn-active")) {
                // 取消选中
                console.log('*** 移除选中状态 ***');
                t.classList.remove("btn-active");
                t.style.backgroundColor = '#e5e7eb'; // gray-200
                t.style.color = '#374151'; // gray-700
            } else {
                // 选中
                console.log('*** 添加选中状态 ***');
                t.classList.add("btn-active");
                t.style.backgroundColor = '#3b82f6'; // blue-500
                t.style.color = 'white';
            }
            
            console.log('*** 当前按钮类名 ***', t.className);
            console.log('命中码数选择已更改，等待确认按钮点击');
        });
    });
}
// 立即输出调试信息
console.log('*** 脚本开始执行 ***');
console.log('*** 当前时间戳:', Date.now(), '***');

// 初始化命中码数按钮
document.addEventListener('DOMContentLoaded', function() {
    console.log('*** DOMContentLoaded事件触发 ***');
    
    // 自动加载计划验证历史（但不触发验证表格更新）
    if (window.PlanStorageManager && typeof window.PlanStorageManager.loadFromLocalStorage === 'function') {
        setTimeout(() => {
            window.PlanStorageManager.loadFromLocalStorage(true); // skipVerification = true，仅加载数据不更新表格
        }, 100); // 延迟100ms确保页面完全加载
    }
    
    // 初始化验证模式为单期验证，确保历史管理控件显示
    setTimeout(() => {
        if (typeof window.switchVerifyMode === 'function') {
            const planHistoryControls = document.getElementById('planHistoryControls');
            if (planHistoryControls) {
                window.switchVerifyMode('single', true);
                console.log('✅ 页面加载时验证模式初始化成功，历史管理控件已显示');
            }
        }
    }, 200);
    
    const S = document.getElementById("hitButtons");
    if (!S) {
        console.error('hitButtons元素未找到');
        return;
    }
    console.log('*** hitButtons元素找到，开始初始化 ***');
    
    [0,1,2,3,4,5].forEach(t=>{const e=document.createElement("button");e.className="px-3 py-1 rounded-md bg-gray-200 btn-hover",e.dataset.hit=t,e.textContent=t+"胆",S.appendChild(e)});
    
    // 移除默认选中状态 - 页面加载时命中码数都不选中
    // document.querySelector('#hitButtons button[data-hit="2"]').classList.add("btn-active");
    // document.querySelector('#hitButtons button[data-hit="3"]').classList.add("btn-active");
    
    // 移除默认选中状态 - 页面加载时命中数字都不选中
    // const defaultHitNumbers = [1, 2, 3, 4, 5, 6];
    // defaultHitNumbers.forEach(num => {
    //     const button = document.querySelector(`.hit-number-btn[data-number="${num}"]`);
    //     if (button) {
    //         button.classList.add('btn-active', 'bg-primary', 'text-white');
    //         button.classList.remove('border-gray-300');
    //     }
    // });
    
    C(Array.from(S.children));
    
    // 位置选择按钮事件处理 - 全新实现
    console.log('=== 开始初始化位置选择按钮 ===');
    
    // 等待DOM完全加载
    setTimeout(() => {
        const positionButtons = document.querySelectorAll('.position-btn');
        console.log('找到位置选择按钮数量:', positionButtons.length);
        
        if (positionButtons.length === 0) {
            console.error('未找到位置选择按钮！');
            return;
        }
        
        // 为每个按钮添加点击事件
        positionButtons.forEach((button, index) => {
            // 设置初始样式
            button.style.backgroundColor = '#e5e7eb'; // gray-200
            button.style.color = '#374151'; // gray-700
            button.style.cursor = 'pointer';
            button.style.transition = 'all 0.2s ease';
            
            // 位置按钮状态切换函数
            function togglePositionButton() {
                console.log('位置按钮点击:', button.textContent, button.dataset.position);
                
                // 切换选中状态
                if (button.classList.contains('btn-active')) {
                    // 取消选中
                    button.classList.remove('btn-active');
                    button.style.backgroundColor = '#e5e7eb'; // gray-200
                    button.style.color = '#374151'; // gray-700
                    console.log('取消选中:', button.textContent);
                } else {
                    // 选中
                    button.classList.add('btn-active');
                    button.style.backgroundColor = '#3b82f6'; // blue-500
                    button.style.color = 'white';
                    console.log('选中:', button.textContent);
                }
                
                // 输出当前选中状态
                const selectedPositions = Array.from(document.querySelectorAll('.position-btn.btn-active'))
                    .map(btn => btn.dataset.position);
                console.log('当前选中位置:', selectedPositions);
                
                // 移除立即筛选，等待确认按钮点击
                console.log('位置选择已更改，等待确认按钮点击');
            }
            
            // 移动端触摸事件处理变量
            let touchStartTime = 0;
            let touchMoved = false;
            let touchHandled = false;
            
            // 添加点击事件（仅在非触摸设备上生效）
            button.addEventListener('click', function(e) {
                // 如果触摸事件已处理，则跳过click事件
                if (touchHandled) {
                    touchHandled = false;
                    return;
                }
                e.preventDefault();
                e.stopPropagation();
                togglePositionButton();
            });
            
            // 添加移动端触摸事件处理
            button.addEventListener('touchstart', function(e) {
                touchStartTime = Date.now();
                touchMoved = false;
                touchHandled = false;
                // 添加触摸开始的视觉反馈
                this.style.opacity = '0.7';
            }, { passive: true });
            
            button.addEventListener('touchmove', function(e) {
                touchMoved = true;
                // 移除视觉反馈
                this.style.opacity = '';
            }, { passive: true });
            
            button.addEventListener('touchend', function(e) {
                const touchDuration = Date.now() - touchStartTime;
                // 恢复视觉反馈
                this.style.opacity = '';
                
                // 如果是快速点击且没有移动，则触发状态切换
                if (!touchMoved && touchDuration < 500) {
                    touchHandled = true;
                    e.preventDefault();
                    e.stopPropagation();
                    togglePositionButton();
                    // 延迟重置标志，确保click事件被跳过
                    setTimeout(() => {
                        touchHandled = false;
                    }, 100);
                }
            }, { passive: true });
            
            button.addEventListener('touchcancel', function(e) {
                // 恢复视觉反馈
                this.style.opacity = '';
                touchHandled = false;
            }, { passive: true });
            
            console.log(`位置按钮 ${index + 1} (${button.textContent}) 初始化完成`);
        });
        
        // 添加测试函数
        window.testPositionButton = function() {
            console.log('=== 测试位置选择按钮 ===');
            const buttons = document.querySelectorAll('.position-btn');
            if (buttons.length > 0) {
                console.log('模拟点击第一个按钮:', buttons[0].textContent);
                buttons[0].click();
            } else {
                console.error('未找到位置按钮！');
            }
        };
        
        console.log('=== 位置选择按钮初始化完成 ===');
    }, 100);
    
    console.log('*** 位置选择按钮事件绑定完成 ***');
    
    console.log('*** 按钮创建完成，开始调试输出 ***');
    
    // 调试：输出初始选择状态
    setTimeout(() => {
        console.log('=== 初始化完成，当前选择状态 ===');
        console.log('前五码数:', document.getElementById('numSelect').value);
        console.log('命中数字:', Array.from(document.querySelectorAll('.hit-number-btn.btn-active')).map(btn => btn.dataset.number));
        console.log('命中码数:', Array.from(document.querySelectorAll('#hitButtons .btn-active')).map(btn => btn.dataset.hit));
        console.log('=== 初始化状态输出完成 ===');
        
        // 移除自动筛选，等待用户点击确认按钮
        console.log('页面初始化完成，等待用户点击确认按钮进行筛选');
    }, 100);
});

// 前五码数下拉选择框事件监听 - 移除立即筛选
const numSelect = document.getElementById('numSelect');
if (numSelect) {
    numSelect.addEventListener('change', function() {
        console.log('前五码数选择已更改:', this.value);
        // 移除立即筛选，等待确认按钮点击
    });
}

// 位置选择按钮事件处理将在DOMContentLoaded中进行

let T=null;function D(t){const e=document.getElementById("keyCountdown"),n=document.getElementById("timeRemaining");function o(){const o=new Date,c=new Date(1e3*t)-o;if(c<=0){n.textContent="已过期",e.classList.remove("bg-primary","bg-amber-500"),e.classList.add("bg-red-500"),clearInterval(T);const t=Y();return localStorage.removeItem(`validKey_${t}`),localStorage.removeItem(`keyExpiry_${t}`),b=!1,void setTimeout(()=>{window.location.reload()},3e3)}const r=Math.floor(c/864e5),i=Math.floor(c%864e5/36e5),a=Math.floor(c%36e5/6e4),s=Math.floor(c%6e4/1e3);n.textContent=`${r}天 ${i}小时 ${a}分钟 ${s}秒`;const d=24*r+i;d<=24?(e.classList.remove("bg-primary","bg-amber-500"),e.classList.add("bg-red-500")):d<=72?(e.classList.remove("bg-primary","bg-red-500"),e.classList.add("bg-amber-500")):(e.classList.remove("bg-amber-500","bg-red-500"),e.classList.add("bg-primary"))}T&&clearInterval(T),o(),e.classList.remove("hidden"),T=setInterval(o,1e3);}function generateDeviceFingerprint(){
  // 使用固定的通用指纹，允许密钥在任何设备上使用
  // 这样可以确保密钥的跨设备兼容性
    return 'universal_device_2024';
 }

// 生成校验和函数
function generateChecksum(data) {
    // 使用与密钥生成器相同的增强校验和算法
    return generateEnhancedChecksum(data);
}

// 生成确定性校验和（6个字符）- 验证时必须确定性
function generateEnhancedChecksum(input) {
    // 使用多重哈希算法但保持确定性
    let hash1 = 0;
    let hash2 = 0;
    
    for (let i = 0; i < input.length; i++) {
        const char = input.charCodeAt(i);
        // 第一个哈希
        hash1 = ((hash1 << 5) - hash1) + char;
        hash1 = hash1 & hash1;
        
        // 第二个哈希（不同的算法）
        hash2 = ((hash2 << 3) + hash2) ^ char;
        hash2 = hash2 & hash2;
    }
    
    // 组合两个哈希值（移除时间戳微扰动以保持确定性）
    const combinedHash = Math.abs(hash1) + Math.abs(hash2);
    
    // 生成6位校验和
    let checksum = combinedHash.toString(36).substring(0, 6);
    if (checksum.length < 6) {
        // 如果不足6位，用确定性字符补充
        const padding = '0123456789abcdefghijklmnopqrstuvwxyz';
        for (let i = checksum.length; i < 6; i++) {
            checksum += padding[(combinedHash + i) % padding.length];
        }
    }
    
    return checksum.substring(0, 6);
}

// 生成安全随机字符串（与密钥生成器保持一致）
function generateSecureRandomString(length) {
    const chars = '0123456789abcdefghijklmnopqrstuvwxyz';
    
    // 检查是否支持crypto API
    if (window.crypto && window.crypto.getRandomValues) {
        const array = new Uint8Array(length);
        window.crypto.getRandomValues(array);
        
        let result = '';
        for (let i = 0; i < length; i++) {
            result += chars[array[i] % chars.length];
        }
        return result;
    } else {
        // 降级到Math.random()（兼容性处理）
        let result = '';
        for (let i = 0; i < length; i++) {
            result += chars[Math.floor(Math.random() * chars.length)];
        }
        return result;
    }
}

// 纯本地记录密钥使用信息
function recordKeyUsage(keyData) {
    try {
        const deviceId = generateDeviceFingerprint();
        const localRecord = {
            keyId: keyData.nonce,
            deviceId: deviceId,
            deviceInfo: navigator.userAgent,
            usedAt: new Date().toISOString(),
            expiresAt: new Date(keyData.expiry * 1000).toISOString(),
            savedLocally: true
        };
        
        // 保存到本地存储
        localStorage.setItem(`keyRecord_${keyData.nonce}`, JSON.stringify(localRecord));
        console.log('密钥使用记录已保存到本地:', localRecord);
        
        return { success: true, data: localRecord, localBackup: true };
    } catch (error) {
        console.error('记录密钥使用信息失败:', error);
        return { success: false, error: error.message };
    }
}

// 纯本地密钥使用状态检查
function O(t){console.log("使用本地验证检查密钥:",t);return{used:JSON.parse(localStorage.getItem("usedNonces")||"[]").includes(t)}}// 纯本地密钥标记为已使用
function K(t){console.log("本地标记密钥为已使用:",t);const e=JSON.parse(localStorage.getItem("usedNonces")||"[]");return e.includes(t)||(e.push(t),localStorage.setItem("usedNonces",JSON.stringify(e)),console.log("本地记录nonce:",t)),{success:!0}}
const P=document.getElementById("verifyKeyBtn");function E(t){let e;if(t.includes("\t"))e=t.trim().split(/\t+/);else{if(!t.includes(" "))return null;e=t.trim().split(/\s+/)}if(e.length<2)return null;const n=e[0].trim();let o;if(e[1].includes(","))o=e[1].split(",").map(t=>parseInt(t.trim(),10));else{if(!e[1].includes(" "))return null;o=e[1].split(" ").map(t=>parseInt(t.trim(),10))}return 10!==o.length||o.some(isNaN)?null:{period:n,data:o}}async function A(t){try{// 支持新的短密钥格式（约22个字符）
if(t.length <= 25) {
// 短密钥格式：前4位标识符 + 6位时间戳 + 6位随机填充 + 6位校验和 = 22位
if(t.length < 20 || t.length > 25) return {valid: false, reason: "密钥格式无效"};

const identifier = t.substring(0, 4);
const timestampPart = t.substring(4, 10);
const randomPadding = t.substring(10, 16);
const checksum = t.substring(16, 22);

// 解析有效期（新的随机标识符格式）
// 标识符现在是完全随机的，不再用于识别有效期
// 时间戳部分直接包含过期时间戳
const expiry = parseInt(timestampPart, 36);

// 验证时间戳是否有效（基本范围检查）
if (isNaN(expiry) || expiry <= 0) {
    return {valid: false, reason: "密钥时间戳无效"};
}

// 检查是否过期
const currentTime = Math.floor(Date.now() / 1000);
if(currentTime > expiry) {
return {valid: false, reason: "密钥已过期"};
}

// 验证校验和
const expectedChecksum = generateChecksum(identifier + timestampPart + randomPadding);
if(checksum !== expectedChecksum) {
return {valid: false, reason: "密钥校验失败"};
}

// 使用服务器端验证（短密钥）
        const nonce = t; // 使用整个短密钥作为nonce
        
        console.log('使用服务器端验证短密钥:', nonce);
        
        // 首先调用服务器端API检查密钥使用状态并自动注册
        try {
            const checkResponse = await fetch('http://localhost:3002/api/keys/validate-and-register', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ key: nonce }),
                credentials: 'include'
            });
            
            const checkResult = await checkResponse.json();
            
            if (checkResult.success) {
                console.log('服务器端验证成功:', checkResult.message);
                
                // 同时更新本地记录
                const usedNonces = JSON.parse(localStorage.getItem('usedNonces') || '[]');
                if (!usedNonces.includes(nonce)) {
                    usedNonces.push(nonce);
                    localStorage.setItem('usedNonces', JSON.stringify(usedNonces));
                    console.log('本地同步标记密钥为已使用:', nonce);
                }
                
                // 直接返回成功结果，跳过后续的API调用
                return {
                    valid: true, 
                    reason: checkResult.message,
                    autoRegistered: checkResult.data.autoRegistered,
                    keyData: checkResult.data,
                    data: {nonce: nonce, expiry: expiry, deviceFingerprint: "universal"}
                };
            } else {
                console.log('服务器端验证失败:', checkResult.message);
                return {valid: false, reason: checkResult.message};
            }
        } catch (error) {
            console.log('服务器端API调用失败，回退到本地验证:', error);
            
            // 服务器端验证失败时，回退到本地验证
            const usedNonces = JSON.parse(localStorage.getItem('usedNonces') || '[]');
            if (usedNonces.includes(nonce)) {
                return {valid: false, reason: "密钥已被使用，每个密钥只能使用一次（本地验证）"};
            }
            
            // 本地标记为已使用
            usedNonces.push(nonce);
            localStorage.setItem('usedNonces', JSON.stringify(usedNonces));
            console.log('本地标记短密钥为已使用:', nonce);
        }
        
        // 同时向后台API发送验证记录（不影响本地验证结果）
        try {
            const response = await fetch('http://localhost:3002/api/keys/validate', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ key: nonce }),
                credentials: 'include'
            });
            
            if (response.ok) {
                console.log('后台API验证记录成功');
            } else {
                console.log('后台API验证记录失败，但不影响本地验证');
            }
        } catch (error) {
            console.log('后台API调用失败，但不影响本地验证:', error);
        }
        
        return {valid: true, data: {nonce: nonce, expiry: expiry, deviceFingerprint: "universal"}};
}

// 纯本地长密钥格式验证 - 长密钥已全部失效
const e=atob(t),n=decodeURIComponent(escape(e)),o=JSON.parse(n);if(!o.expiry||!o.nonce||!o.deviceFingerprint)return{valid:!1,reason:"密钥缺少必要字段"};const c=(new Date).getTime();if(Math.floor(c/1e3)>o.expiry)return{valid:!1,reason:"密钥已过期"};const r=generateDeviceFingerprint();if(o.deviceFingerprint!==r)return{valid:!1,reason:"此密钥不可在当前设备使用"};console.log('检测到长密钥，已失效:',o.nonce);return{valid:!1,reason:"长密钥已失效，请使用新的短密钥"}}catch(t){return t instanceof DOMException&&"InvalidCharacterError"===t.name?{valid:!1,reason:"密钥Base64解码失败"}:t instanceof SyntaxError?{valid:!1,reason:"密钥JSON格式无效"}:{valid:!1,reason:"验证过程异常: "+t.message}}}

// 纯本地检查密钥是否已被使用
function checkKeyOnlineUsage(nonce) {
    try {
        console.log('使用纯本地验证检查密钥:', nonce);
        const usedNonces = JSON.parse(localStorage.getItem('usedNonces') || '[]');
        const isUsed = usedNonces.includes(nonce);
        console.log('密钥使用状态:', isUsed);
        return { used: isUsed };
    } catch (error) {
        console.error('检查密钥使用状态时出错:', error);
        return { used: false };
    }
}

// 纯本地标记密钥为已使用
function markKeyAsUsedOnline(nonce) {
    console.log('使用纯本地标记密钥为已使用:', nonce);
    const usedNonces = JSON.parse(localStorage.getItem('usedNonces') || '[]');
    if (!usedNonces.includes(nonce)) {
        usedNonces.push(nonce);
        localStorage.setItem('usedNonces', JSON.stringify(usedNonces));
        console.log('本地标记nonce:', nonce);
    }
    return { success: true };
}

    // 纯本地记录密钥使用信息（备用函数）
    function recordKeyUsageBackup(keyData) {
      try {
        const localRecord = {
            keyId: keyData.nonce,
            deviceInfo: navigator.userAgent,
            usedAt: new Date().toISOString(),
            expiryTime: new Date(keyData.expiry * 1000).toISOString(),
            createdTime: new Date().toISOString(),
            savedLocally: true
        };
        
        localStorage.setItem(`keyRecordBackup_${keyData.nonce}`, JSON.stringify(localRecord));
        console.log('密钥使用记录已保存到本地（备用）:', localRecord);
        return { success: true, data: localRecord, localBackup: true };
      } catch (error) {
        console.error('记录密钥使用信息失败:', error);
        // 网络失败时的本地备用方案
        const localRecord = {
          keyId: keyData.nonce,
          deviceInfo: navigator.userAgent,
          usedAt: new Date().toISOString(),
          savedLocally: true
        };
        localStorage.setItem(`keyRecord_${keyData.nonce}`, JSON.stringify(localRecord));
        return { success: false, error: error.message, localBackup: true };
      }
    }

function F(){const t=document.getElementById("numbersInput").value.trim().split(/\n+/).filter(Boolean);if(!t.length)return void(v.textContent="请输入数据");let e=0;for(const n of t){const t=E(n);if(!t)return void(v.textContent="格式错误：请输入正确的数据格式");const{period:o,data:c}=t,i=c.join(",");d.has(o)||r.length&&r[r.length-1].input===i||(r.push({period:o,data:c,input:i}),d.add(o),e++)}document.getElementById("numbersInput").value="",v.textContent=e>0?`成功添加 ${e} 期数据`:"没有新数据添加";console.log(`F()函数: 添加 ${e} 期新数据后，数据数组长度为 ${r.length}`);document.getElementById("periodCount").textContent=r.length;console.log(`F()函数: 期数统计已更新为 ${r.length}`);r.sort((t,e)=>{const n=t.period.toString();const o=e.period.toString();return o.localeCompare(n)}); 
    // 调用表格渲染函数显示数据
    L();
    console.log('F()函数: 已调用L()函数渲染表格');
}
// 云端数据库功能已禁用 - J函数中的API调用代码已移除
// 替代函数：禁用云端数据获取功能
function J(){
    v.textContent="云端数据库功能已禁用，请手动输入数据";
    console.log('云端数据库功能已禁用');
}
function R(t,e){const n=[];return function o(c,r){if(r.length!==e)for(let e=c;e<t.length;e++)r.push(t[e]),o(e+1,r),r.pop();else n.push(r.slice())}(0,[]),n}

/**
 * 黄金切割（必须 5 中 4）：任意注数 → 5 组
 * 思路：为每条注单指定唯一"缺席组"omitted = 0..4
 * 第 g 组收集所有 omitted !== g 的注单
 * 结论：任意 4 组合并 = 全集（严格保证）
 * 
 * assign: 'roundrobin' 更均匀；'hash' 更稳定（同一注单长期落同一缺席组）
 */
function goldenSplit5in4(data, assign = 'roundrobin') {
  const G = 5;
  const groups = Array.from({ length: G }, () => []);

  // 缺席组索引（每注唯一）
  const omittedIdx = new Array(data.length);

  if (assign === 'hash') {
    for (let i = 0; i < data.length; i++) {
      omittedIdx[i] = hash5(data[i]); // 0..4
    }
  } else {
    for (let i = 0; i < data.length; i++) {
      omittedIdx[i] = i % G; // 轮转
    }
  }

  // 构建 5 组：每注出现在 4 个组
  for (let i = 0; i < data.length; i++) {
    const omit = omittedIdx[i];
    for (let g = 0; g < G; g++) {
      if (g !== omit) groups[g].push(data[i]);
    }
  }
  return groups;

  function hash5(str) {
    let h = 2166136261 >>> 0;
    for (let j = 0; j < str.length; j++) {
      h ^= str.charCodeAt(j);
      h = Math.imul(h, 16777619);
    }
    return h % 5;
  }
}

/** 校验：任意四组合并是否等于全集（严格 5 中 4） */
function validate5in4(groups, original) {
  const uniq = (arr) => Array.from(new Set(arr));
  const origSet = new Set(uniq(original));
  const G = groups.length;

  for (let miss = 0; miss < G; miss++) {
    const merged = new Set();
    for (let g = 0; g < G; g++) {
      if (g === miss) continue;
      for (const x of groups[g]) merged.add(x);
    }
    if (merged.size !== origSet.size) return false;
    // 也可逐条核对
    for (const x of origSet) if (!merged.has(x)) return false;
  }
  return true;
}

/** 解析输入：支持换行/逗号分隔；自动去重；保持原顺序的唯一化 */
function parseInput(raw) {
  const parts = raw
    .split(/[\n,]+/g)
    .map(s => s.trim())
    .filter(Boolean);
  const seen = new Set();
  const out = [];
  for (const p of parts) {
    if (!seen.has(p)) { seen.add(p); out.push(p); }
  }
  return out;
}

// 验证任意4组组合后是否为全集
function validate_5in4(groups) {
    if (!groups || groups.length < 4) {
        return {
            valid: false,
            results: {},
            all_valid: false,
            total_data_size: 0
        };
    }
    
    // 获取所有数据的并集
    const all_set = new Set();
    groups.forEach(group => {
        group.forEach(item => all_set.add(item));
    });
    
    const results = {};
    const total_data_size = all_set.size;
    
    // 生成所有4组的组合
    const combinations = [];
    for (let i = 0; i < groups.length; i++) {
        for (let j = i + 1; j < groups.length; j++) {
            for (let k = j + 1; k < groups.length; k++) {
                for (let l = k + 1; l < groups.length; l++) {
                    combinations.push([i, j, k, l]);
                }
            }
        }
    }
    
    // 验证每个4组组合
    combinations.forEach(combo => {
        const merged = new Set();
        combo.forEach(i => {
            groups[i].forEach(item => merged.add(item));
        });
        
        const is_complete = merged.size === total_data_size;
        results[combo.join(',')] = {
            combo: combo,
            size: merged.size,
            is_complete: is_complete,
            coverage: total_data_size > 0 ? (merged.size / total_data_size) : 0
        };
    });
    
    // 检查是否所有组合都完整
    const all_valid = Object.values(results).every(r => r.is_complete);
    
    return {
        valid: all_valid,
        results: results,
        all_valid: all_valid,
        total_data_size: total_data_size,
        combinations_count: combinations.length
    };
}

// 渲染黄金切割结果 - 5个紧凑框布局
function renderGoldenResults(groups, originalItems = [], isValid = false) {
    const resultsContainer = document.getElementById('goldenResults');
    const resultSummary = document.getElementById('resultSummary');
    const validationResults = document.getElementById('validationResults');
    const validationContent = document.getElementById('validationContent');
    
    resultsContainer.innerHTML = '';
    
    if (!groups || groups.length === 0) {
        resultsContainer.innerHTML = '<div class="col-span-5 text-center text-gray-500 py-8">暂无分割结果</div>';
        resultSummary.textContent = '';
        validationResults.classList.add('hidden');
        return;
    }
    
    // 更新摘要信息
    const totalItems = groups.reduce((sum, group) => sum + group.length, 0);
    const avgGroupSize = Math.round(totalItems / groups.length);
    resultSummary.innerHTML = `共${groups.length}组，总计${totalItems}项，平均每组${avgGroupSize}项 | 验证结果：${isValid ? '<span class="text-green-600 font-semibold">✅ 通过</span>' : '<span class="text-red-600 font-semibold">❌ 失败</span>'}`;
    
    // 显示验证结果
    if (originalItems.length > 0) {
        validationContent.innerHTML = `
            <div class="text-sm text-gray-600">
                <p class="mb-2">原始数据：${originalItems.length} 注</p>
                <p class="mb-2">分组结果：${groups.length} 组</p>
                <p class="mb-2">5中4验证：${isValid ? '<span class="text-green-600 font-semibold">通过 - 任意4组合并等于全集</span>' : '<span class="text-red-600 font-semibold">失败 - 不满足5中4条件</span>'}</p>
            </div>
        `;
        validationResults.classList.remove('hidden');
    } else {
        validationResults.classList.add('hidden');
    }
    
    // 确保显示5个框，不足的用空框填充
    const displayGroups = [...groups];
    while (displayGroups.length < 5) {
        displayGroups.push([]);
    }
    
    // 生成5个紧凑的分组框
    displayGroups.slice(0, 5).forEach((group, index) => {
        const groupDiv = document.createElement('div');
        groupDiv.className = 'bg-white border border-gray-200 rounded-lg p-3';
        
        if (group.length === 0) {
            // 空框
            groupDiv.innerHTML = `
                <div class="text-center text-gray-400 py-4">
                    <div class="text-sm font-medium mb-1">组 ${index + 1}</div>
                    <div class="text-xs">暂无数据</div>
                </div>
            `;
        } else {
            // 有数据的框
            groupDiv.innerHTML = `
                <div class="flex items-center justify-between mb-2">
                    <h4 class="font-semibold text-gray-800 text-sm">组 ${index + 1}</h4>
                    <div class="flex items-center gap-1">
                        <span class="text-xs text-gray-500">${group.length}项</span>
                        <button 
                            onclick="copyGroupData(${index})" 
                            class="px-1 py-0.5 bg-blue-500 text-white text-xs rounded hover:bg-blue-600 transition-colors"
                            title="复制本组数据"
                        >
                            复制
                        </button>

                    </div>
                </div>
                <div class="max-h-32 overflow-y-auto">
                    <div class="text-xs space-y-1" id="group-${index}-data" data-full-data="${group.join(',')}">
                        ${group.slice(0, 200).map(item => `<div class="p-1 bg-gray-50 rounded text-center hover:bg-gray-100 transition-colors">${item}</div>`).join('')}
                        ${group.length > 200 ? '<div class="p-1 text-center text-gray-400 text-xs">...还有' + (group.length - 200) + '项</div>' : ''}
                    </div>
                </div>
            `;
        }
        
        resultsContainer.appendChild(groupDiv);
    });
}

// 复制组数据功能
function copyGroupData(groupIndex) {
    const groupDataDiv = document.getElementById(`group-${groupIndex}-data`);
    if (!groupDataDiv) {
        alert('未找到数据');
        return;
    }
    
    // 从data-full-data属性获取完整数据，确保复制全部数据而不受显示限制影响
    const dataText = groupDataDiv.getAttribute('data-full-data') || '';
    
    if (!dataText) {
        alert('没有可复制的数据');
        return;
    }
    
    // 复制到剪贴板
    if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(dataText).then(() => {
            // 显示复制成功提示
            showCopySuccess(groupIndex);
        }).catch(err => {
            console.error('复制失败:', err);
            fallbackCopyTextToClipboard(dataText, groupIndex);
        });
    } else {
        fallbackCopyTextToClipboard(dataText, groupIndex);
    }
}

// 备用复制方法
function fallbackCopyTextToClipboard(text, groupIndex) {
    const textArea = document.createElement('textarea');
    textArea.value = text;
    textArea.style.position = 'fixed';
    textArea.style.left = '-999999px';
    textArea.style.top = '-999999px';
    textArea.style.opacity = '0';
    textArea.style.pointerEvents = 'none';
    // 防止移动端弹出输入法
    textArea.readOnly = true;
    textArea.setAttribute('readonly', 'readonly');
    textArea.setAttribute('inputmode', 'none');
    document.body.appendChild(textArea);
    
    // 在移动端避免使用focus，直接选择文本
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    if (!isMobile) {
        textArea.focus();
    }
    textArea.select();
    
    try {
        const successful = document.execCommand('copy');
        if (successful) {
            showCopySuccess(groupIndex);
        } else {
            alert('复制失败，请手动选择复制');
        }
    } catch (err) {
        console.error('复制失败:', err);
        alert('复制失败，请手动选择复制');
    }
    
    document.body.removeChild(textArea);
}

// 重置所有复制按钮状态（仅在重新切割时调用）
function resetAllCopyButtons() {
    const allCopyButtons = document.querySelectorAll('button[onclick^="copyGroupData("]');
    allCopyButtons.forEach(btn => {
        btn.innerHTML = '复制';
        btn.classList.remove('bg-green-500');
        btn.classList.add('bg-blue-500', 'hover:bg-blue-600');
    });
}

// 显示复制成功提示
function showCopySuccess(groupIndex) {
    // 设置当前按钮为已复制状态（持久显示）
    const button = document.querySelector(`button[onclick="copyGroupData(${groupIndex})"]`);
    if (button) {
        button.innerHTML = '<i class="fa fa-check"></i> 已复制';
        button.classList.remove('bg-blue-500', 'hover:bg-blue-600');
        button.classList.add('bg-green-500');
    }
}



// 渲染验证结果
function renderValidationResults(validation) {
    const validationContainer = document.getElementById('validationResults');
    const validationContent = document.getElementById('validationContent');
    
    if (!validation || !validation.results) {
        validationContainer.classList.add('hidden');
        return;
    }
    
    validationContainer.classList.remove('hidden');
    
    let html = `
        <div class="mb-4">
            <div class="text-sm text-gray-600 mb-2">
                总数据量: ${validation.total_data_size} 注 | 
                验证组合数: ${validation.combinations_count} 个 | 
                整体验证: ${validation.all_valid ? '<span class="text-green-600 font-semibold">✅ 通过</span>' : '<span class="text-red-600 font-semibold">❌ 失败</span>'}
            </div>
        </div>
        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3">
    `;
    
    Object.entries(validation.results).forEach(([comboKey, result]) => {
        const comboText = result.combo.map(i => `组${i + 1}`).join(' + ');
        const statusClass = result.is_complete ? 'bg-green-50 border-green-200' : 'bg-red-50 border-red-200';
        const statusIcon = result.is_complete ? '✅' : '❌';
        
        html += `
            <div class="${statusClass} border rounded-lg p-3">
                <div class="font-medium text-sm">${comboText}</div>
                <div class="text-xs text-gray-600 mt-1">
                    ${result.size}注 (${(result.coverage * 100).toFixed(1)}%) ${statusIcon}
                </div>
            </div>
        `;
    });
    
    html += '</div>';
    validationContent.innerHTML = html;
}function H(t,e){const n={};return e.forEach(e=>{let o=0,c=0,r=0,i=0;t.forEach(t=>{t.cells[e].hit?(r++,i=0,r>o&&(o=r)):(i++,r=0,i>c&&(c=i))}),n[e]={maxHit:o,maxMiss:c}}),n}function U(t,e){const n={};return e.forEach(e=>{let o=0;for(let n=0;n<t.length&&t[n].cells[e].hit;n++)o++;n[e]=o}),n}function z(t,e){const n={};return e.forEach(e=>{let o=0;for(let n=0;n<t.length&&!t[n].cells[e].hit;n++)o++;n[e]=o}),n}function L(){const t=document.querySelector("#resultTable thead"),e=document.querySelector("#resultTable tbody");t.innerHTML="",e.innerHTML="";console.log('筛选函数L()开始执行，数据长度:', r.length);if(!r.length){const t=document.createElement("tr"),n=document.createElement("td");return n.colSpan=100,n.className="py-4 text-center text-gray-500",n.textContent="暂无数据，请先输入或获取数据",t.appendChild(n),e.appendChild(t),void j()}console.log('数据存在，开始处理表格渲染');// 从下拉选择框获取前五码数
const numSelect = document.getElementById('numSelect');
const selectedNums = numSelect && numSelect.value ? [parseInt(numSelect.value)] : [];

// 从按钮获取位置选择
const selectedPositions = Array.from(document.querySelectorAll('.position-btn.btn-active')).map(btn => parseInt(btn.dataset.position));

// 从按钮获取命中数字选择
const selectedHitNumbers = Array.from(document.querySelectorAll('.hit-number-btn.btn-active')).map(btn => parseInt(btn.dataset.number));

const c=Array.from(document.querySelectorAll("#hitButtons .btn-active")).map(t=>+t.dataset.hit),i=[...Array(10)].map((t,e)=>e+1);

// 使用完整的数据数组，不进行截取
const n = r.slice(); // 使用完整数据
console.log('L()函数: 使用完整数据数组，长度为', n.length, '期数限制f为', f);

// 生成筛选后的组合
let filteredCombos = [];
// 获取前五码数选择
const numToSelect = selectedNums.length > 0 ? selectedNums[0] : (numSelect && numSelect.value ? parseInt(numSelect.value) : 3);

// 检查是否有选择条件，如果都没有选择则使用默认逻辑
if (selectedHitNumbers.length > 0 && c.length > 0) {
  // 根据前五码数、命中码数、命中数字进行筛选
  const allCombos = R(i, numToSelect); // 生成所有可能的组合
  
  const validCombos = allCombos.filter(combo => {
    // 检查组合中包含的命中数字个数
    const hitCount = combo.filter(num => selectedHitNumbers.includes(num)).length;
    return c.includes(hitCount); // 命中个数必须在选中的命中码数范围内
  });
  
  // 对每个有效组合进行展开：将每个数字轮流置为第1位
  filteredCombos = [];
  validCombos.forEach(combo => {
    combo.forEach(firstNum => {
      const remainingNums = combo.filter(num => num !== firstNum).sort((a, b) => a - b);
      const expandedCombo = [firstNum, ...remainingNums];
      filteredCombos.push(expandedCombo);
    });
  });
} else {
  // 当没有选择命中数字或命中码数时的默认逻辑
  if (selectedNums.length > 0) {
    filteredCombos = selectedNums.flatMap(o=>o>0&&o<=10?R(i,o):[]);
  } else {
    // 如果前五码数也没有选择，使用默认的3码组合
    filteredCombos = R(i, numToSelect);
  }
}

// 合并筛选组合和自定义组合
let allCombos = [...filteredCombos,...document.getElementById("customCombos").value.trim().split(/\s+/).filter(Boolean).map(t=>t.split(",").map(t=>+t).filter(t=>!isNaN(t)))].filter(t=>t.length>0);

// 对相同数字组合进行去重处理
const uniqueCombos = new Map();
allCombos.forEach(combo => {
    // 将数字组合排序后作为唯一标识
    const sortedKey = combo.slice().sort((a,b)=>a-b).join(',');
    if (!uniqueCombos.has(sortedKey)) {
        uniqueCombos.set(sortedKey, combo.join(','));
    }
});

// 获取去重后的组合数组
const a = Array.from(uniqueCombos.values());
// 根据期数限制截取数据用于显示，但确保不超过实际数据长度
const actualLimit = Math.min(n.length, f);
const displayData = n.slice(0, actualLimit);
const s=displayData.map(t=>({rec:t,cells:{}}));
// 修复分页计算：确保totalPages基于实际显示的数据行数
totalPages=Math.max(1, Math.ceil(s.length/pageSize));
console.log('原始组合数量:', allCombos.length);
console.log('去重后组合数量:', a.length);
console.log('完整数据长度:', n.length, '期数限制:', f, '实际限制:', actualLimit);
console.log('显示数据长度:', displayData.length);
console.log('处理的数据行数:', s.length);
console.log('总页数计算:', totalPages, '= Math.max(1, Math.ceil(' + s.length + '/' + pageSize + '))');
console.log('当前页面:', currentPage, '是否超出范围:', currentPage > totalPages);
// 如果当前页面超出范围，重置到第一页
if (currentPage > totalPages) {
    currentPage = 1;
    console.log('当前页面超出范围，重置到第一页');
}a.forEach(t=>{let e=0;for(let n=s.length-1;n>=0;n--){const o=s[n].rec,allPositions=o.data.slice(0,8);let r=0;if(selectedPositions.length>0){selectedPositions.forEach(pos=>{if(pos>=1&&pos<=8&&t.split(",").map(t=>+t).includes(allPositions[pos-1])){r++}});}else{// 修改筛选逻辑：数字相同但顺序不同算作同一个结果
const comboNumbers = t.split(",").map(t=>+t).sort((a,b)=>a-b);
const frontFiveSorted = allPositions.slice(0,5).sort((a,b)=>a-b);
r = comboNumbers.filter(num => frontFiveSorted.includes(num)).length;}// 修复筛选逻辑：当没有选择命中码数时，显示所有组合
const shouldHit = c.length === 0 || c.includes(r);
if(shouldHit){
  s[n].cells[t]={txt:t,hit:!0};
  e=0;
}else{
  e++;
  s[n].cells[t]={txt:e,hit:!1};
}
console.log(`组合${t}在第${s[n].rec.period}期: 命中数=${r}, 是否命中=${shouldHit}, 选择的命中码数=${c.join(',')}`);}});console.log('表格数据处理完成，开始渲染');console.log(`L()函数: 当前数据数组长度 ${r.length}，期数统计显示 ${document.getElementById('periodCount').textContent}`);if(r.length.toString() !== document.getElementById('periodCount').textContent){console.warn('数据不一致：数据数组长度与期数统计不匹配！');}const d=H(s,a),u=U(s,a),l=z(s,a),b=a.slice().sort((t,e)=>{if(hitRateSort){// 命中率排序模式：按当前期数命中率从高到低排序
const hitRateT = Math.round((s.filter(row=>row.cells[t]&&row.cells[t].hit).length/s.length)*100)||0;
const hitRateE = Math.round((s.filter(row=>row.cells[e]&&row.cells[e].hit).length/s.length)*100)||0;
return hitRateE - hitRateT; // 从高到低排序
}else if(y){// 当前模式：按当前遗漏值或当前连中值排序
return m?u[e]-u[t]||l[t]-l[e]:l[e]-l[t]||u[t]-u[e]}// 历史模式：按历史最大值排序
const{maxHit:n,maxMiss:o}=d[t],{maxHit:c,maxMiss:r}=d[e];return m?c-n||o-r:o-r||c-n});

// 保存处理后的数据到全局变量，供updateTablePage函数使用
window.lastProcessedData = s;
window.lastSortedCombinations = b;
console.log('已保存处理后的数据到全局变量');document.getElementById("sortText").textContent=hitRateSort?"按命中率排序":m?"按遗漏次数排序":"按连中次数排序";const startIndex=(currentPage-1)*pageSize,endIndex=Math.min(startIndex+pageSize,s.length),pageData=s.slice(startIndex,endIndex);document.getElementById("summary").innerHTML=`\n        <div class="grid grid-cols-1 md:grid-cols-4 gap-4">\n          <div>共 ${b.length} 注分析组合</div>\n          <div>当前显示: ${displayData.length} 期 / 总计: ${r.length} 期</div>\n          <div>筛选条件: ${selectedNums.length>0?selectedNums.join("/"):"全部"}码组合，命中${c.length>0?c.join("/"):"全部"}胆${selectedPositions.length>0?`，位置${selectedPositions.join("/")}名`:""}${selectedHitNumbers.length>0?`，命中数字${selectedHitNumbers.join("/")}`:""}</div>\n          <div>第 ${currentPage}/${totalPages} 页 (${pageData.length}/${s.length} 行)</div>\n        </div>\n        <div class="flex justify-center items-center mt-4 space-x-2">\n          <button id="prevPage" class="px-3 py-1 bg-gray-200 rounded hover:bg-gray-300 disabled:opacity-50" ${currentPage<=1?'disabled':''}>上一页</button>\n          <span class="text-sm text-gray-600">第 ${currentPage} 页，共 ${totalPages} 页</span>\n          <button id="nextPage" class="px-3 py-1 bg-gray-200 rounded hover:bg-gray-300 disabled:opacity-50" ${currentPage>=totalPages?'disabled':''}>下一页</button>\n        </div>`;const h=document.createElement("tr");
h.className="bg-gray-50 table-header-sticky",h.innerHTML='<th class="px-3 py-2 text-center sticky-col left-0 border-r border-gray-200 fixed-width-period sticky-bg-white" style="position: sticky; top: 0; z-index: 1001;">期数</th><th class="px-3 py-2 text-center sticky-col left-[120px] border-r border-gray-200 fixed-width-data sticky-bg-white" style="position: sticky; top: 0; z-index: 1001;">数据</th>';b.forEach(t=>{const{maxHit:e,maxMiss:n}=d[t],o=document.createElement("th");o.className="px-3 py-2 text-center border-r border-gray-200",o.innerHTML=y?m?`\n              <div class="font-medium">${t}</div>\n              <div class="text-xs text-gray-500 whitespace-nowrap">连:${u[t]} 漏${n} (${Math.round((s.filter(row=>row.cells[t]&&row.cells[t].hit).length/s.length)*100)||0}%)</div>\n            `:`\n              <div class="font-medium">${t}</div>\n              <div class="text-xs text-gray-500 whitespace-nowrap">漏:${l[t]} 史:${n} (${Math.round((s.filter(row=>row.cells[t]&&row.cells[t].hit).length/s.length)*100)||0}%)</div>\n            `:m?`\n              <div class="font-medium">${t}</div>\n              <div class="text-xs text-gray-500 whitespace-nowrap">连:${u[t]} 史:${e} (${Math.round((s.filter(row=>row.cells[t]&&row.cells[t].hit).length/s.length)*100)||0}%)</div>\n            `:`\n              <div class="font-medium">${t}</div>\n              <div class="text-xs text-gray-500 whitespace-nowrap">漏:${l[t]} 史:${n} (${Math.round((s.filter(row=>row.cells[t]&&row.cells[t].hit).length/s.length)*100)||0}%)</div>\n            `,h.appendChild(o)}),t.appendChild(h),pageData.forEach((t,n)=>{const o=document.createElement("tr");o.className=0===n?"bg-gray-100":1===n?"bg-gray-50":"",o.innerHTML=`\n          <td class="px-3 py-2 text-left sticky-col left-0 border-r border-gray-200 font-medium fixed-width-period ${0===n?"sticky-bg-gray-100":1===n?"sticky-bg-gray-50":"sticky-bg-white"}">${t.rec.period}</td>\n          <td class="px-3 py-2 text-left sticky-col left-[120px] border-r border-gray-200 fixed-width-data ${0===n?"sticky-bg-gray-100":1===n?"sticky-bg-gray-50":"sticky-bg-white"}">\n            <div class="number-row">${t.rec.data.slice(0,5).join(",")}</div>\n            <div class="number-row">${t.rec.data.slice(5).join(",")}</div>\n          </td>\n        `,b.forEach(e=>{const n=t.cells[e],c=document.createElement("td");c.className="px-3 py-2 text-center border-r border-gray-200 "+(n.hit?"hit-cell":"miss-cell"),c.textContent=n.txt,o.appendChild(c)}),e.appendChild(o)}),setTimeout(()=>{const t=document.getElementById("prevPage"),e=document.getElementById("nextPage");t&&t.addEventListener("click",(event)=>{event.preventDefault();if(currentPage>1){currentPage--;updateTablePage();}}),e&&e.addEventListener("click",(event)=>{event.preventDefault();if(currentPage<totalPages){currentPage++;updateTablePage();}});},100);
    
    // 将处理后的数据赋值给window.r，供验证计划页面使用
    window.r = r;
    console.log('L()函数: 已将数据赋值给window.r，数组长度:', r.length);
    
    // 延迟同步数据到验证计划页面，确保DOM渲染完成
    setTimeout(() => {
        console.log('L()函数: 开始延迟执行数据同步，当前时间:', new Date().toISOString());
        if (typeof window.syncDataToVerifyPlan === 'function') {
            console.log('L()函数: 延迟调用syncDataToVerifyPlan');
            window.syncDataToVerifyPlan();
            console.log('L()函数: syncDataToVerifyPlan执行完成');
        }
        // 同时更新单期验证表格，确保下一期数据实时同步
        if (typeof window.updateSinglePeriodTable === 'function') {
            console.log('L()函数: 延迟更新单期验证表格');
            window.updateSinglePeriodTable();
            console.log('L()函数: updateSinglePeriodTable执行完成');
        }
        console.log('L()函数: 延迟执行完成，数据同步结束');
    }, 10);

// 获取筛选后的数据
function getFilteredData() {
    let filteredData = r.slice();
    
    // 应用筛选条件
    if (selectedNums.length > 0) {
        filteredData = filteredData.filter(item => {
            const combinations = getCombinations();
            return combinations.some(combo => {
                const nums = combo.split(",").map(n => parseInt(n));
                return selectedNums.every(selectedNum => nums.includes(selectedNum));
            });
        });
    }
    
    if (selectedPositions.length > 0) {
        filteredData = filteredData.filter(item => {
            return selectedPositions.some(pos => {
                const index = parseInt(pos) - 1;
                return index >= 0 && index < item.data.length;
            });
        });
    }
    
    if (selectedHitNumbers.length > 0) {
        // 获取选中的命中码数（胆码数量）
        const selectedHitCounts = Array.from(document.querySelectorAll("#hitButtons .btn-active")).map(btn => parseInt(btn.dataset.hit));
        
        if (selectedHitCounts.length > 0) {
            // 根据命中数字和命中码数进行筛选
            filteredData = filteredData.filter(item => {
                const firstFive = item.data.slice(0, 5);
                // 计算前5位开奖号码中有多少个在选中的命中数字中
                const hitCount = firstFive.filter(num => selectedHitNumbers.includes(num)).length;
                // 检查命中数量是否在选中的命中码数范围内
                return selectedHitCounts.includes(hitCount);
            });
        }
    }
    
    return filteredData;
}

// 获取组合列表
function getCombinations() {
    const combinations = [];
    
    // 根据当前选择的码数生成组合
    for (let i = 1; i <= 10; i++) {
        for (let j = i + 1; j <= 10; j++) {
            if (selectedNums.length === 0 || (selectedNums.includes(i) && selectedNums.includes(j))) {
                combinations.push(`${i},${j}`);
            }
        }
    }
    
    // 如果没有选择特定码数，生成所有可能的组合
    if (combinations.length === 0) {
        for (let i = 1; i <= 10; i++) {
            for (let j = i + 1; j <= 10; j++) {
                combinations.push(`${i},${j}`);
            }
        }
    }
    
    return combinations;
}

// 新增函数：只更新表格页面内容，不重新渲染整个表格
function updateTablePage() {
    console.log('updateTablePage被调用，当前页面:', currentPage);
    
    const tbody = document.querySelector("#resultTable tbody");
    if (!tbody) {
        console.warn('表格tbody未找到，调用L()函数重新渲染');
        L();
        return;
    }
    
    // 获取当前已处理的数据（从全局变量中获取）
    if (!window.lastProcessedData || !window.lastSortedCombinations) {
        console.warn('缺少已处理的数据，调用L()函数重新渲染');
        L();
        return;
    }
    
    const s = window.lastProcessedData;
    const b = window.lastSortedCombinations;
    
    // 计算当前页的数据
    const startIndex = (currentPage - 1) * pageSize;
    const endIndex = Math.min(startIndex + pageSize, s.length);
    const pageData = s.slice(startIndex, endIndex);
    
    console.log('只更新表格内容，当前页数据行数:', pageData.length);
    
    // 清空并重新生成tbody内容
    tbody.innerHTML = '';
    
    pageData.forEach((t, n) => {
        const o = document.createElement("tr");
        o.className = 0 === n ? "bg-gray-100" : 1 === n ? "bg-gray-50" : "";
        o.innerHTML = `
            <td class="px-3 py-2 text-left sticky-col left-0 border-r border-gray-200 font-medium fixed-width-period ${0 === n ? "sticky-bg-gray-100" : 1 === n ? "sticky-bg-gray-50" : "sticky-bg-white"}">${t.rec.period}</td>
            <td class="px-3 py-2 text-left sticky-col left-[120px] border-r border-gray-200 fixed-width-data ${0 === n ? "sticky-bg-gray-100" : 1 === n ? "sticky-bg-gray-50" : "sticky-bg-white"}">
                <div class="number-row">${t.rec.data.slice(0,5).join(",")}</div>
                <div class="number-row">${t.rec.data.slice(5).join(",")}</div>
            </td>
        `;
        
        b.forEach(e => {
            const n = t.cells[e];
            const c = document.createElement("td");
            c.className = "px-3 py-2 text-center border-r border-gray-200 " + (n.hit ? "hit-cell" : "miss-cell");
            c.textContent = n.txt;
            o.appendChild(c);
        });
        
        tbody.appendChild(o);
    });
    
    // 更新分页信息
    const summaryDiv = document.getElementById("summary");
    if (summaryDiv) {
        const summaryHTML = summaryDiv.innerHTML;
        const updatedSummary = summaryHTML.replace(
            /第 \d+\/\d+ 页 \(\d+\/\d+ 行\)/,
            `第 ${currentPage}/${totalPages} 页 (${pageData.length}/${s.length} 行)`
        ).replace(
            /<div class="flex justify-center[\s\S]*?<\/div>\s*$/,
            `<div class="flex justify-center items-center mt-4 space-x-2">
                <button id="prevPage" class="px-3 py-1 bg-gray-200 rounded hover:bg-gray-300 disabled:opacity-50" ${currentPage <= 1 ? 'disabled' : ''}>上一页</button>
                <span class="text-sm text-gray-600">第 ${currentPage} 页，共 ${totalPages} 页</span>
                <button id="nextPage" class="px-3 py-1 bg-gray-200 rounded hover:bg-gray-300 disabled:opacity-50" ${currentPage >= totalPages ? 'disabled' : ''}>下一页</button>
            </div>`
        );
        summaryDiv.innerHTML = updatedSummary;
    }
    
    // 重新绑定翻页按钮事件
    setTimeout(() => {
        const prevBtn = document.getElementById("prevPage");
        const nextBtn = document.getElementById("nextPage");
        
        if (prevBtn) {
            prevBtn.addEventListener("click", (event) => {
                event.preventDefault();
                if (currentPage > 1) {
                    currentPage--;
                    updateTablePage();
                }
            });
        }
        
        if (nextBtn) {
            nextBtn.addEventListener("click", (event) => {
                event.preventDefault();
                if (currentPage < totalPages) {
                    currentPage++;
                    updateTablePage();
                }
            });
        }
    }, 10);
}
// j(); // 移除可能导致无限递归的调用
}function j(){const t=document.getElementById("resultTable"),e=document.getElementById("tableContainer"),n=t.offsetWidth,o=e.offsetWidth;if(n>o){document.querySelector(".slider-container").style.display="block";const u=o/n,l=Math.max(20,u*o);k.style.width=e.scrollLeft/(n-o)*100+"%",w.style.left=e.scrollLeft/(n-o)*(o-l)+"px",w.style.width=`${l}px`,k.style.width=e.scrollLeft/(n-o)*100+"%";let m=!1;function c(t){if(!m)return;const c=e.getBoundingClientRect(),r=t.clientX-c.left-l/2,i=o-l,a=Math.max(0,Math.min(r,i)),s=a/i,d=s*(n-o);e.scrollLeft=d,w.style.left=`${a}px`,k.style.width=100*s+"%"}function r(){m=!1,document.removeEventListener("mousemove",c),document.removeEventListener("mouseup",r)}w.addEventListener("mousedown",t=>{m=!0,document.addEventListener("mousemove",c),document.addEventListener("mouseup",r),t.preventDefault()}),document.querySelector(".slider-track").addEventListener("click",t=>{const c=e.getBoundingClientRect(),r=t.clientX-c.left-l/2,i=o-l,a=Math.max(0,Math.min(r,i)),s=a/i,d=s*(n-o);e.scrollLeft=d,w.style.left=`${a}px`,k.style.width=100*s+"%"})}else document.querySelector(".slider-container").style.display="none";const i=t.offsetHeight,a=e.offsetHeight;if(i>a){$.style.display="none";const f=a/i,y=Math.max(20,f*a);I.style.height=e.scrollTop/(i-a)*100+"%",B.style.top=e.scrollTop/(i-a)*(a-y)+"px",B.style.height=`${y}px`,I.style.height=e.scrollTop/(i-a)*100+"%";let b=!1;function s(t){if(!b)return;const n=e.getBoundingClientRect(),o=t.clientY-n.top-y/2,c=a-y,r=Math.max(0,Math.min(o,c)),s=r/c,d=s*(i-a);e.scrollTop=d,B.style.top=`${r}px`,I.style.height=100*s+"%"}function d(){b=!1,document.removeEventListener("mousemove",s),document.removeEventListener("mouseup",d)}B.addEventListener("mousedown",t=>{b=!0,document.addEventListener("mousemove",s),document.addEventListener("mouseup",d),t.preventDefault()}),document.querySelector(".vertical-slider-track").addEventListener("click",t=>{const n=e.getBoundingClientRect(),o=t.clientY-n.top-y/2,c=a-y,r=Math.max(0,Math.min(o,c)),s=r/c,d=s*(i-a);e.scrollTop=d,B.style.top=`${r}px`,I.style.height=100*s+"%"})}else $.style.display="none";e.addEventListener("scroll",()=>{if(n>o){const t=e.scrollLeft/(n-o);w.style.left=t*(o-parseInt(getComputedStyle(w).width))+"px",k.style.width=100*t+"%";const periodCols=document.querySelectorAll(".fixed-width-period");const dataCols=document.querySelectorAll(".fixed-width-data");if(e.scrollLeft>10){periodCols.forEach(col=>col.style.opacity="0");dataCols.forEach(col=>col.style.left="0px")}else{periodCols.forEach(col=>col.style.opacity="1");dataCols.forEach(col=>col.style.left="120px")}}if(i>a){const t=e.scrollTop/(i-a);const thumbHeight=Math.max(20,f*a);B.style.top=Math.min(t*(a-thumbHeight),a-thumbHeight)+"px",I.style.height=Math.min(100*t,100)+"%"}})}async function V(){if(s)try{const t=await s.getFile(),e=(await t.text()).trim().split("\n").filter(Boolean);console.log(`V()函数: 从文件读取到 ${e.length} 行数据`);for(const t of e)q(t);r.sort((t,e)=>{const n=t.period.toString();return e.period.toString().localeCompare(n)});console.log(`V()函数: 处理后数据数组长度为 ${r.length}`);document.getElementById("periodCount").textContent=r.length;console.log(`V()函数: 期数统计已更新为 ${r.length}`);L(); /* 自动渲染表格 */}catch(t){v.textContent=`读取文件错误: ${t.message}`}}async function W(){if(s)try{const t=await s.getFile(),e=(await t.text()).trim().split("\n")[0],n=e.trim().split(/\t+/);if(2!==n.length)return;const o=n[0].trim();if(o===u)return;u=o,q(e);// 重新排序数据，确保最新期号在第一行
r.sort((t,e)=>{const n=t.period.toString();return e.period.toString().localeCompare(n)});console.log(`W()函数: 新增数据后，数据数组长度为 ${r.length}`);document.getElementById("periodCount").textContent=r.length;console.log(`W()函数: 期数统计已更新为 ${r.length}`);// 自动刷新表格显示最新数据
L();}catch(t){}}function q(t){let e;if(t.includes("\t"))e=t.trim().split(/\t+/);else{if(!t.includes(" "))return;e=t.trim().split(/\s+/)}if(e.length<2)return;const n=e[0].trim();if(d.has(n))return;let o;if(e[1].includes(","))o=e[1].split(",").map(t=>parseInt(t.trim(),10));else{if(!e[1].includes(" "))return;o=e[1].split(" ").map(t=>parseInt(t.trim(),10))}10!==o.length||o.some(isNaN)||(d.add(n),r.unshift({period:n,data:o,input:o.join(",")}))}// Y函数定义 - 生成文件标识符
function Y(){try{const t=document.documentElement.outerHTML.substring(0,1e3)+window.location.href.split("/").slice(-2).join("/");let e=0;for(let n=0;n<t.length;n++)e=(e<<5)-e+t.charCodeAt(n),e&=e;return"file_"+Math.abs(e).toString(36)}catch(t){return console.error("Failed to generate file identifier:",t),"fallback_"+Date.now()}}

// 添加防重复点击和防抖机制
let isVerifying = false;
let verifyTimeout = null;

P.addEventListener("click",async function(){const t=p.value.trim();if(t){// 防重复点击检查
if(isVerifying){console.warn("验证正在进行中，请勿重复点击");return;}

// 清除之前的防抖定时器
if(verifyTimeout){clearTimeout(verifyTimeout);verifyTimeout=null;}

// 设置验证状态
isVerifying=true;
this.disabled=true;
this.textContent="验证中...";
this.style.opacity="0.6";
this.style.cursor="not-allowed";

// 添加加载动画效果
const originalText=this.textContent;

let dots=0;
const loadingInterval=setInterval(()=>{dots=(dots+1)%4;this.textContent="验证中"+".".repeat(dots);},500);

// 清理可能的状态缓存
const deviceId=Y();
const existingKey=localStorage.getItem(`validKey_${deviceId}`);
if(existingKey){console.log("清理现有密钥缓存");localStorage.removeItem(`validKey_${deviceId}`);localStorage.removeItem(`keyExpiry_${deviceId}`);}

try{const e=await A(t);if(e.valid){// 标记密钥为已使用
// 记录密钥使用信息到本地
recordKeyUsage(e.data);
const n=Y();localStorage.setItem(`validKey_${n}`,t);localStorage.setItem(`keyExpiry_${n}`,e.data.expiry);g.classList.add("hidden");g.style.display="none";
// 设置新的加密验证状态
_0xSetAuth(t);
b=!0;
D(e.data.expiry)}else alert("密钥验证失败: "+e.reason)}catch(t){console.error("密钥验证过程出错:",t);alert("验证过程中发生错误: "+t.message)}finally{// 重置验证状态（添加延迟防抖）
if(loadingInterval){clearInterval(loadingInterval);}
verifyTimeout=setTimeout(()=>{isVerifying=false;this.disabled=false;this.textContent="验证密钥";this.style.opacity="1";this.style.cursor="pointer";},1000);}}else alert("请输入密钥")});

window.addEventListener("load",async function(){try{const t=Y(),e=localStorage.getItem(`validKey_${t}`),n=localStorage.getItem(`keyExpiry_${t}`),o=Math.floor((new Date).getTime()/1e3);if(e&&n){const r=parseInt(n);if(o<r){// 检查是否为长密钥格式（长密钥已失效）
// 移除长密钥强制失效限制，允许长密钥正常使用
if(e.length > 25) {
  console.log('检测到长密钥，尝试验证');
  // 不再强制失效，继续验证流程
}// 短密钥验证逻辑
if(!e.includes('.')){_0xSetAuth(e);b=!0;D(r);g.classList.add("hidden");g.style.display="none"}else try{const keyData=JSON.parse(atob(e.split('.')[1]));const checkResult=checkKeyOnlineUsage(keyData.nonce);if(checkResult.used){localStorage.removeItem(`validKey_${t}`),localStorage.removeItem(`keyExpiry_${t}`),b=!1;
// 友好的错误提示和重试机制
const errorDiv = document.createElement('div');
errorDiv.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:white;border:2px solid #ef4444;border-radius:8px;padding:20px;z-index:9999;box-shadow:0 4px 12px rgba(0,0,0,0.3);text-align:center;max-width:400px;';
errorDiv.innerHTML = `
  <div style="color:#ef4444;font-size:18px;margin-bottom:15px;">🔑 密钥验证失败</div>
  <div style="color:#666;margin-bottom:20px;">您的密钥已被使用，请重新获取新的密钥</div>
  <button onclick="location.reload()" style="background:#3b82f6;color:white;border:none;padding:8px 16px;border-radius:4px;cursor:pointer;margin-right:10px;">重新加载</button>
  <button onclick="this.parentNode.remove()" style="background:#6b7280;color:white;border:none;padding:8px 16px;border-radius:4px;cursor:pointer;">稍后再试</button>
`;
document.body.appendChild(errorDiv);
g.classList.remove("hidden"),g.style.display="flex"}else{_0xSetAuth(e);b=!0,D(r),g.classList.add("hidden"),g.style.display="none"}}catch(err){console.error("本地验证失败:",err);
// 验证失败时的友好提示
const warningDiv = document.createElement('div');
warningDiv.style.cssText = 'position:fixed;top:20px;left:0;right:0;background:#f59e0b;color:white;text-align:center;padding:8px;z-index:9998;font-size:14px;';
warningDiv.innerHTML = '密钥验证出现问题，已使用备用验证方式 <button onclick="this.parentNode.remove()" style="margin-left:10px;padding:2px 8px;background:white;color:#f59e0b;border:none;border-radius:3px;cursor:pointer;">知道了</button>';
document.body.insertBefore(warningDiv, document.body.firstChild);
setTimeout(() => { if (warningDiv.parentNode) warningDiv.parentNode.removeChild(warningDiv); }, 6000);
_0xSetAuth(e);b=!0,D(r),g.classList.add("hidden"),g.style.display="none"}}else{localStorage.removeItem(`validKey_${t}`),localStorage.removeItem(`keyExpiry_${t}`),b=!1,alert("您的访问密钥已过期，请重新验证密钥"),g.classList.remove("hidden"),g.style.display="flex"}}else b=!1,g.classList.remove("hidden"),g.style.display="flex"}catch(t){console.error("页面加载时密钥检查出错:",t),b=!1,g.classList.remove("hidden"),g.style.display="flex"}}),document.getElementById("calcBtn").addEventListener("click",F),document.getElementById("numbersInput").addEventListener("keydown",t=>{"Enter"!==t.key||t.shiftKey||(t.preventDefault(),F())});

// 自动抓取相关变量
let autoScrapeInterval = null;
let countdownInterval = null;
let lastPeriodNumber = null;
let isInActiveTimeRange = false;

// 检查是否在活跃时间段内 (23:55-07:05)
function isInActiveTime() {
    const now = new Date();
    const hours = now.getHours();
    const minutes = now.getMinutes();
    const currentTime = hours * 60 + minutes;
    
    // 23:55 = 1435分钟, 07:05 = 425分钟
    const startTime = 23 * 60 + 55; // 1435
    const endTime = 7 * 60 + 5;     // 425
    
    // 跨越午夜的时间段
    return currentTime >= startTime || currentTime <= endTime;
}

// 云端数据库功能已禁用 - 远程API基础URL已移除

// 云端数据库功能已禁用 - runPythonScraper函数已移除

// 启动自动抓取功能 - 每2秒获取一次数据
function startAutoScrape() {
    if (autoScrapeInterval) {
        clearInterval(autoScrapeInterval);
    }
    
    console.log('启动自动获取数据功能，每2秒获取一次');
    isInActiveTimeRange = true;
    
    // 立即获取一次数据
    fetchApiData();
    
    // 设置定时器每2秒获取一次
    autoScrapeInterval = setInterval(async () => {
        try {
            await fetchApiData();
        } catch (error) {
            console.error('自动获取数据失败:', error);
        }
    }, 2000); // 2秒间隔
    
    // 更新按钮状态
    const autoFetchBtn = document.getElementById('autoFetchBtn');
    if (autoFetchBtn) {
        autoFetchBtn.innerHTML = '<i class="fa fa-stop mr-2"></i>停止自动获取';
        autoFetchBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
        autoFetchBtn.classList.add('bg-red-500', 'hover:bg-red-600');
    }
    
    showNotification('已启动自动获取数据功能，每2秒获取一次', 'success');
}

// 停止自动抓取功能
function stopAutoScrape() {
    if (autoScrapeInterval) {
        clearInterval(autoScrapeInterval);
        autoScrapeInterval = null;
    }
    
    console.log('停止自动获取数据功能');
    isInActiveTimeRange = false;
    
    // 更新按钮状态
    const autoFetchBtn = document.getElementById('autoFetchBtn');
    if (autoFetchBtn) {
        autoFetchBtn.innerHTML = '<i class="fa fa-play mr-2"></i>开始自动获取';
        autoFetchBtn.classList.remove('bg-red-500', 'hover:bg-red-600');
        autoFetchBtn.classList.add('bg-green-500', 'hover:bg-green-600');
    }
    
    showNotification('已停止自动获取数据功能', 'info');
}

// 页面加载时自动开始每5秒刷新
window.addEventListener('load', function() {
    // 云端数据库功能已禁用 - 不再自动加载数据
    // fetchTodayDataFromDatabase(); // 已禁用
    
    // 云端数据库功能已禁用 - 不再启动自动刷新
    // setTimeout(() => {
    //     console.log('页面加载完成，启动每5秒自动刷新功能');
    //     startAutoRefresh();
    // }, 3000); // 已禁用
    
    console.log('页面加载完成，云端数据库功能已禁用，请手动输入数据');
});

// 页面卸载时清理定时器
window.addEventListener('beforeunload', function() {
    stopAutoRefresh();
});

// 添加命中数字按钮的事件监听器
document.addEventListener('DOMContentLoaded', function() {
    // 命中数字按钮多选功能
    const hitNumberButtons = document.querySelectorAll('.hit-number-btn');
    hitNumberButtons.forEach(button => {
        // 设置初始样式
        button.style.backgroundColor = '#e5e7eb'; // gray-200
        button.style.color = '#374151'; // gray-700
        button.style.cursor = 'pointer';
        button.style.transition = 'all 0.2s ease';
        
        button.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            
            console.log('命中数字按钮点击:', this.textContent, this.dataset.number);
            
            // 切换选中状态
            if (this.classList.contains('btn-active')) {
                // 取消选中
                this.classList.remove('btn-active');
                this.style.backgroundColor = '#e5e7eb'; // gray-200
                this.style.color = '#374151'; // gray-700
                console.log('取消选中:', this.textContent);
            } else {
                // 选中
                this.classList.add('btn-active');
                this.style.backgroundColor = '#3b82f6'; // blue-500
                this.style.color = 'white';
                console.log('选中:', this.textContent);
            }
            
            // 输出当前选中状态
            const selectedNumbers = Array.from(document.querySelectorAll('.hit-number-btn.btn-active'))
                .map(btn => btn.dataset.number);
            console.log('当前选中数字:', selectedNumbers);
            
            // 移除立即筛选，等待确认按钮点击
            console.log('命中数字选择已更改，等待确认按钮点击');
        });
    });
    
    // 命中码数按钮事件处理已在DOMContentLoaded中通过C函数处理，无需重复绑定
    
    // 确认按钮事件处理
    const confirmFilterBtn = document.getElementById('confirmFilterBtn');
    if (confirmFilterBtn) {
        confirmFilterBtn.addEventListener('click', function() {
            console.log('确认按钮被点击，开始执行筛选');
            // 执行筛选函数
            L();
        });
    }
    
    // 页面初始化时自动获取历史数据
    setTimeout(async function() {
        if (r && r.length > 0) {
            console.log('页面初始化检测到数据，自动渲染表格，数据长度:', r.length);
            L();
        } else {
            console.log('页面初始化时暂无数据，开始自动获取历史数据...');
            try {
                // 自动获取历史数据
                const result = await fetchHistoryData();
                if (result && result.success && result.added > 0) {
                    console.log(`页面初始化：成功获取 ${result.added} 条新数据`);
                    // 数据获取成功后自动渲染表格
                    L();
                } else {
                    console.log('页面初始化：未获取到新数据或获取失败');
                }
            } catch (error) {
                console.error('页面初始化：自动获取历史数据失败:', error);
            }
        }
    }, 500); // 延迟500ms确保所有初始化完成
});

document.getElementById("autoFetchBtn").addEventListener("click",()=>{if(isInActiveTimeRange){stopAutoScrape()}else{startAutoScrape()}});

// 获取最新数据按钮事件监听
document.getElementById("fetchApiBtn").addEventListener("click", async ()=>{
    const btn = document.getElementById("fetchApiBtn");
    const originalText = btn.innerHTML;
    
    // 显示加载状态
    btn.innerHTML = '<i class="fa fa-spinner fa-spin mr-2"></i>获取中...';
    btn.disabled = true;
    
    try {
        await fetchApiData();
    } finally {
        // 恢复按钮状态
        btn.innerHTML = originalText;
        btn.disabled = false;
    }
});document.getElementById("sortToggle").addEventListener("click",()=>{m=!m; /* 移除立即筛选，等待确认按钮点击 */});// 当前遗漏按钮事件
document.getElementById("currentMissBtn").addEventListener("click",()=>{const tableContainer=document.getElementById("tableContainer");const wasHidden=tableContainer&&tableContainer.scrollLeft>10;y=!0;m=!1;hitRateSort=!1; // 设置为当前模式和遗漏模式，关闭命中率排序
document.getElementById("currentMissBtn").classList.add("btn-active","bg-blue-600","text-white");document.getElementById("currentMissBtn").classList.remove("bg-gray-200","text-gray-700");document.getElementById("currentHitBtn").classList.remove("btn-active","bg-blue-600","text-white");document.getElementById("currentHitBtn").classList.add("bg-gray-200","text-gray-700");document.getElementById("hitRateSortBtn").classList.remove("btn-active","bg-orange-600","text-white");document.getElementById("hitRateSortBtn").classList.add("bg-gray-200","text-gray-700"); console.log('当前遗漏按钮被点击，开始刷新数据'); L(); /* 添加数据刷新功能 */ if(wasHidden){setTimeout(()=>{const periodCols=document.querySelectorAll(".fixed-width-period");const dataCols=document.querySelectorAll(".fixed-width-data");periodCols.forEach(col=>col.style.opacity="0");dataCols.forEach(col=>col.style.left="0px")},50)}});

// 当前连中按钮事件
document.getElementById("currentHitBtn").addEventListener("click",()=>{const tableContainer=document.getElementById("tableContainer");const wasHidden=tableContainer&&tableContainer.scrollLeft>10;y=!0;m=!0;hitRateSort=!1; // 设置为当前模式和连中模式，关闭命中率排序
document.getElementById("currentHitBtn").classList.add("btn-active","bg-blue-600","text-white");document.getElementById("currentHitBtn").classList.remove("bg-gray-200","text-gray-700");document.getElementById("currentMissBtn").classList.remove("btn-active","bg-blue-600","text-white");document.getElementById("currentMissBtn").classList.add("bg-gray-200","text-gray-700");document.getElementById("hitRateSortBtn").classList.remove("btn-active","bg-orange-600","text-white");document.getElementById("hitRateSortBtn").classList.add("bg-gray-200","text-gray-700"); console.log('当前连中按钮被点击，开始刷新数据'); L(); /* 添加数据刷新功能 */ if(wasHidden){setTimeout(()=>{const periodCols=document.querySelectorAll(".fixed-width-period");const dataCols=document.querySelectorAll(".fixed-width-data");periodCols.forEach(col=>col.style.opacity="0");dataCols.forEach(col=>col.style.left="0px")},50)}});

// 命中率排序按钮事件
document.getElementById("hitRateSortBtn").addEventListener("click",()=>{const tableContainer=document.getElementById("tableContainer");const wasHidden=tableContainer&&tableContainer.scrollLeft>10;y=!0;hitRateSort=!0; // 设置为当前模式和命中率排序模式
document.getElementById("hitRateSortBtn").classList.add("btn-active","bg-orange-600","text-white");document.getElementById("hitRateSortBtn").classList.remove("bg-gray-200","text-gray-700");document.getElementById("currentMissBtn").classList.remove("btn-active","bg-blue-600","text-white");document.getElementById("currentMissBtn").classList.add("bg-gray-200","text-gray-700");document.getElementById("currentHitBtn").classList.remove("btn-active","bg-blue-600","text-white");document.getElementById("currentHitBtn").classList.add("bg-gray-200","text-gray-700"); console.log('命中率排序按钮被点击，开始刷新数据'); L(); /* 添加数据刷新功能 */ if(wasHidden){setTimeout(()=>{const periodCols=document.querySelectorAll(".fixed-width-period");const dataCols=document.querySelectorAll(".fixed-width-data");periodCols.forEach(col=>col.style.opacity="0");dataCols.forEach(col=>col.style.left="0px")},50)}}); document.getElementById("statBtn").addEventListener("click",() => { /* 移除立即筛选，等待确认按钮点击 */ });document.getElementById("clearBtn").addEventListener("click",()=>{if(confirm("确定要清空所有数据吗？此操作不可恢复。")){
r=[];
i=1;
d.clear();
document.getElementById("periodCount").textContent="0";
document.getElementById("summary").textContent="";
v.textContent="数据已清空";
// 重置为自动获取模式
window.isUsingFileData = false;
updateDataSourceIndicator(false);
// 重新渲染表格以清空显示
L();
// 清空验证计划表格
if (typeof window.updateVerifyPlanTable === 'function') {
    window.updateVerifyPlanTable();
}
if (typeof window.updateSinglePeriodTable === 'function') {
    window.updateSinglePeriodTable();
}
// 重新启动API数据获取定时器
console.log('重新启动API数据获取定时器...');
if (typeof window.startHistoryDataFetch === 'function') {
    window.startHistoryDataFetch();
    console.log('历史数据获取定时器已重新启动');
}
if (typeof window.startVerifyPlanDataFetch === 'function') {
    window.startVerifyPlanDataFetch();
    console.log('验证计划数据获取定时器已重新启动');
}
console.log('数据已清空，已切换回自动获取模式，所有表格已重新渲染，API数据获取已重新启动');
}});document.addEventListener("DOMContentLoaded",()=>{document.getElementById("uploadDataBtn").addEventListener("click",async()=>{try{[s]=await window.showOpenFilePicker();
// 停止所有API数据获取定时器
console.log('文件导入开始，停止所有API数据获取...');
// 停止自动抓取
if (typeof stopAutoScrape === 'function') {
    stopAutoScrape();
    console.log('已停止自动抓取功能');
}
// 停止历史数据获取
if (typeof window.stopHistoryDataFetch === 'function') {
    window.stopHistoryDataFetch();
    console.log('已停止历史数据获取');
}
// 停止验证计划数据获取
if (typeof window.stopVerifyPlanDataFetch === 'function') {
    window.stopVerifyPlanDataFetch();
    console.log('已停止验证计划数据获取');
}
// 停止其他可能的定时器
if (autoScrapeInterval) {
    clearInterval(autoScrapeInterval);
    autoScrapeInterval = null;
    console.log('已清除自动抓取定时器');
}
if (historyDataTimer) {
    clearInterval(historyDataTimer);
    historyDataTimer = null;
    console.log('已清除历史数据定时器');
}
if (verifyPlanDataTimer) {
    clearInterval(verifyPlanDataTimer);
    verifyPlanDataTimer = null;
    console.log('已清除验证计划数据定时器');
}
// 设置数据源标识
window.isUsingFileData = true;
console.log('数据源已切换为文件获取模式');
// 更新数据源指示器
updateDataSourceIndicator(true);
d.clear();u=null;r=[];i=1;await V();l&&clearInterval(l);l=setInterval(W,2e3);v.textContent=`已加载文件: ${s.name} (文件数据模式)`}catch(t){v.textContent=`文件选择错误: ${t.message}`}})});const X=document.querySelectorAll(".period-btn");X.forEach(t=>{t.addEventListener("click",()=>{X.forEach(t=>t.classList.remove("btn-active"));t.classList.add("btn-active");f=parseInt(t.dataset.period);document.getElementById("customPeriod").value=f;currentPage=1;console.log(`期数按钮被点击，设置期数为: ${f}`);L(); /* 添加表格刷新功能 */})});document.getElementById("customPeriodBtn").addEventListener("click",()=>{const t=parseInt(document.getElementById("customPeriod").value);!isNaN(t)&&t>=1&&t<=1e4?(f=t,X.forEach(t=>t.classList.remove("btn-active")),currentPage=1,console.log(`自定义期数被设置为: ${f}`),L() /* 添加表格刷新功能 */):alert("请输入1-10000之间的数字")});window.addEventListener("resize",j);



// 全局自动刷新变量
let autoRefreshTimer = null;
let lastUpdateTime = null;

// 页面加载时从数据库获取今天的数据
// 云端数据库功能已禁用 - fetchTodayDataFromDatabase函数已移除

// 云端数据库功能已禁用 - autoRefreshLatestData函数已移除

// 生成模拟期号
function generateMockPeriod() {
    const now = new Date();
    const year = now.getFullYear().toString().slice(-2);
    const month = (now.getMonth() + 1).toString().padStart(2, '0');
    const day = now.getDate().toString().padStart(2, '0');
    const hour = now.getHours().toString().padStart(2, '0');
    const minute = now.getMinutes().toString().padStart(2, '0');
    return `${year}${month}${day}${hour}${minute}`;
}

// 生成模拟开奖号码
function generateMockNumbers() {
    const numbers = [];
    for (let i = 0; i < 10; i++) {
        numbers.push(Math.floor(Math.random() * 10));
    }
    return numbers.join(',');
}

// 更新数据源指示器
function updateDataSourceIndicator(isFileMode) {
    const statusElement = document.getElementById('dataSourceStatus');
    if (statusElement) {
        if (isFileMode) {
            statusElement.textContent = '文件获取';
            statusElement.className = 'px-2 py-1 rounded text-xs font-medium bg-blue-600 text-white';
        } else {
            statusElement.textContent = '自动获取';
            statusElement.className = 'px-2 py-1 rounded text-xs font-medium bg-green-600 text-white';
        }
    }
}

// API数据获取功能 - 直接从原始API获取
async function fetchApiData() {
    // 检查是否正在使用文件数据模式
    if (window.isUsingFileData) {
        console.log('当前为文件数据模式，跳过API数据获取');
        return null;
    }
    
    try {
        console.log('步骤1: 开始从API获取数据...');
        
        // 直接调用原始API
        const apiUrl = 'https://api.api68.com/pks/getLotteryPksInfo.do?lotCode=10057';
        
        let response;
        try {
            // 尝试正常fetch
            response = await fetch(apiUrl, {
                method: 'GET',
                headers: {
                    'Accept': 'application/json',
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                }
            });
        } catch (corsError) {
            console.log('CORS错误，尝试no-cors模式:', corsError);
            // 如果CORS失败，尝试no-cors模式
            response = await fetch(apiUrl, {
                method: 'GET',
                mode: 'no-cors',
                headers: {
                    'Accept': 'application/json'
                }
            });
        }
        
        if (!response.ok) {
            throw new Error(`HTTP错误! 状态: ${response.status}`);
        }
        
        const data = await response.json();
        console.log('步骤2: API返回数据:', data);
        
        // 检查API返回的错误码
        if (data.errorCode !== 0) {
            throw new Error(data.message || 'API返回错误');
        }
        
        // 解析API数据
        let period, numbersStr, drawTime;
        
        if (data && data.result && data.result.data) {
            const apiData = data.result.data;
            period = apiData.preDrawIssue;
            numbersStr = apiData.preDrawCode;
            drawTime = apiData.preDrawTime;
        } else {
            throw new Error('API返回数据格式不正确');
        }
        
        console.log('步骤3: 解析数据:', { period, numbersStr, drawTime });
        
        // 检查是否已存在该期数据
        const dataExists = d.has(period);
        if (dataExists) {
            console.log('步骤4: 数据已存在，但仍需触发状态更新');
        } else {
            console.log('步骤4: 数据不存在，准备添加新数据');
        }
        
        // 处理数据
        const numbers = numbersStr.split(',').map(n => parseInt(n.trim(), 10));
        if (numbers.length === 10 && !numbers.some(isNaN)) {
            // 只有当数据不存在时才添加到数组
            if (!dataExists) {
                d.add(period);
                r.unshift({
                    period: period,
                    data: numbers,
                    input: numbersStr
                });
                console.log('步骤5: 新数据已添加到数组，当前数组长度:', r.length);
            } else {
                console.log('步骤5: 数据已存在，跳过添加到数组');
            }
            
            // 将r数组赋值给window.r，供验证计划页面使用
            window.r = r;
            console.log('步骤6: 已将数据同步到window.r，长度:', window.r.length);
            
            // 触发计划自动验证（仅在有新数据时）
            if (!dataExists && window.PlanDataUpdateListener && typeof window.PlanDataUpdateListener.onHistoryDataUpdate === 'function') {
                console.log('步骤6.1: 触发计划自动验证');
                const newDataItem = {
                    period: period,
                    data: numbers,
                    input: numbersStr
                };
                window.PlanDataUpdateListener.onHistoryDataUpdate([newDataItem]);
            }
            
            // 更新期数统计
            document.getElementById('periodCount').textContent = r.length;
            
            // 无论数据是否已存在，都要调用L()函数更新表格和触发状态更新
            console.log('步骤7: 开始更新表格显示和状态');
            L();
            console.log('步骤8: L()函数已调用，将通过延迟机制自动更新单期验证状态');
            
            console.log('步骤9: 数据处理完成，状态更新已触发');
        } else {
            throw new Error('数据格式不正确');
        }
        
        return { period, numbersStr, drawTime, dataExists };
    } catch (error) {
        console.error('获取API数据失败:', error);
        console.log('获取数据失败: ' + error.message);
        return null;
    }
}

// 历史数据获取功能 - 获取指定日期的历史开奖数据
window.fetchHistoryData = async function fetchHistoryData() {
    // 检查是否正在使用文件数据模式
    if (window.isUsingFileData) {
        console.log('当前为文件数据模式，跳过历史数据获取');
        return null;
    }
    
    try {
        console.log('步骤1: 开始获取历史数据（今天和昨天）...');
        
        // 计算今天和昨天的日期
        const today = new Date();
        const yesterday = new Date(today);
        yesterday.setDate(yesterday.getDate() - 1);
        
        const todayStr = today.getFullYear() + '-' + 
                        String(today.getMonth() + 1).padStart(2, '0') + '-' + 
                        String(today.getDate()).padStart(2, '0');
        
        const yesterdayStr = yesterday.getFullYear() + '-' + 
                            String(yesterday.getMonth() + 1).padStart(2, '0') + '-' + 
                            String(yesterday.getDate()).padStart(2, '0');
        
        console.log('步骤2: 准备获取两天数据:', { today: todayStr, yesterday: yesterdayStr });
        
        // 获取两天的数据
        const dates = [todayStr, yesterdayStr];
        let allHistoryItems = [];
        
        for (const dateStr of dates) {
            const historyApiUrl = `https://api.api68.com/pks/getPksHistoryList.do?lotCode=10057&date=${dateStr}`;
            console.log(`步骤2.${dates.indexOf(dateStr) + 1}: 请求URL:`, historyApiUrl);
        
            let response;
            try {
                // 尝试正常fetch
                response = await fetch(historyApiUrl, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json',
                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                    }
                });
            } catch (corsError) {
                console.log(`CORS错误，尝试no-cors模式 (${dateStr}):`, corsError);
                // 如果CORS失败，尝试no-cors模式
                response = await fetch(historyApiUrl, {
                    method: 'GET',
                    mode: 'no-cors',
                    headers: {
                        'Accept': 'application/json'
                    }
                });
            }
            
            if (!response.ok) {
                console.warn(`HTTP错误 (${dateStr})! 状态: ${response.status}`);
                continue; // 跳过这个日期，继续下一个
            }
            
            const data = await response.json();
            console.log(`步骤3.${dates.indexOf(dateStr) + 1}: ${dateStr} 历史数据API返回:`, data);
            
            // 检查API返回的错误码
            if (data.errorCode !== 0) {
                console.warn(`API返回错误 (${dateStr}):`, data.message || '未知错误');
                continue; // 跳过这个日期，继续下一个
            }
            
            // 解析历史数据
            if (data && data.result && data.result.data && Array.isArray(data.result.data)) {
                const historyItems = data.result.data;
                console.log(`步骤4.${dates.indexOf(dateStr) + 1}: ${dateStr} 获取到 ${historyItems.length} 条历史数据`);
                allHistoryItems.push(...historyItems);
            } else {
                console.warn(`${dateStr} 历史数据API返回格式不正确`);
            }
        }
        
        console.log(`步骤3: 总共获取到 ${allHistoryItems.length} 条历史数据`);
        
        if (allHistoryItems.length > 0) {
            let addedCount = 0;
            
            // 按时间倒序排列历史数据（最新的在前）
            allHistoryItems.sort((a, b) => {
                const timeA = new Date(a.preDrawTime);
                const timeB = new Date(b.preDrawTime);
                return timeB.getTime() - timeA.getTime(); // 倒序排列
            });
            
            // 收集新数据，然后一次性添加到数组开头
            const newDataItems = [];
            for (const item of allHistoryItems) {
                const period = item.preDrawIssue;
                const numbersStr = item.preDrawCode;
                const drawTime = item.preDrawTime;
                
                // 检查是否已存在该期数据
                if (!d.has(period)) {
                    // 解析号码
                    const numbers = numbersStr.split(',').map(n => parseInt(n.trim(), 10));
                    if (numbers.length === 10 && !numbers.some(isNaN)) {
                        d.add(period);
                        newDataItems.push({
                            period: period,
                            data: numbers,
                            input: numbersStr
                        });
                        addedCount++;
                    }
                }
            }
            
            // 将新数据添加到数组开头（保持最新数据在前的顺序）
            r.unshift(...newDataItems);
            
            if (addedCount > 0) {
                console.log(`步骤5: 新增 ${addedCount} 条数据到表格`);
                
                // 将r数组赋值给window.r，供验证计划页面使用
                window.r = r;
                console.log('步骤5.1: 已将历史数据同步到window.r，长度:', window.r.length);
                
                // 触发计划自动验证
                if (window.PlanDataUpdateListener && typeof window.PlanDataUpdateListener.onHistoryDataUpdate === 'function') {
                    console.log('步骤5.2: 触发计划自动验证');
                    window.PlanDataUpdateListener.onHistoryDataUpdate(newDataItems);
                }
                
                // 更新期数统计
                document.getElementById('periodCount').textContent = r.length;
                
                // 调用L()函数更新表格（L函数内部会延迟调用syncDataToVerifyPlan和updateSinglePeriodTable）
                console.log('步骤6: 更新表格显示');
                L();
                console.log('步骤6.1: L()函数已调用，将通过延迟机制自动更新单期验证状态');
                
                // 获取到新数据时，也更新倒计时
                console.log('步骤6.2: 获取到新数据，更新倒计时');
                try {
                    const newDrawTime = await getNextDrawTime();
                    if (newDrawTime) {
                        nextDrawTime = newDrawTime;
                        // 如果页面上有倒计时显示元素，启动倒计时
                        const verifyLastUpdate = document.getElementById('verifyLastUpdate');
                        if (verifyLastUpdate) {
                            isUpdatingDrawTime = false; // 重置更新状态
                            startCountdown();
                            console.log('步骤6.3: 倒计时已更新');
                        }
                    }
                } catch (error) {
                    console.log('步骤6.3: 更新倒计时失败:', error.message);
                }
                
                console.log('步骤7: 历史数据处理完成');
            } else {
                console.log('步骤5: 没有新数据需要添加');
            }
            
            return { success: true, total: allHistoryItems.length, added: addedCount };
        } else {
            throw new Error('历史数据API返回格式不正确');
        }
        
    } catch (error) {
        console.error('获取历史数据失败:', error);
        return { success: false, error: error.message };
    }
}

// 历史数据自动获取定时器
let historyDataTimer = null;

// 启动历史数据自动获取
window.startHistoryDataFetch = function startHistoryDataFetch() {
    if (historyDataTimer) {
        clearInterval(historyDataTimer);
    }
    
    console.log('启动历史数据自动获取，每2秒刷新一次');
    
    // 立即执行一次
    fetchHistoryData();
    
    // 设置定时器，每2秒执行一次
    historyDataTimer = setInterval(() => {
        fetchHistoryData();
    }, 2000);
}

// 停止历史数据自动获取
window.stopHistoryDataFetch = function stopHistoryDataFetch() {
    if (historyDataTimer) {
        clearInterval(historyDataTimer);
        historyDataTimer = null;
        console.log('历史数据自动获取已停止');
    }
}

// 验证计划页面数据自动获取定时器
let verifyPlanDataTimer = null;

// 启动验证计划页面数据自动获取
window.startVerifyPlanDataFetch = function startVerifyPlanDataFetch() {
    if (verifyPlanDataTimer) {
        clearInterval(verifyPlanDataTimer);
    }
    
    console.log('启动验证计划页面数据自动获取，每2秒刷新一次');
    
    // 立即执行一次
    updateVerifyPlanPeriodInfo();
    
    // 设置定时器，每2秒执行一次
    verifyPlanDataTimer = setInterval(() => {
        updateVerifyPlanPeriodInfo();
    }, 2000);
}

// 停止验证计划页面数据自动获取
window.stopVerifyPlanDataFetch = function stopVerifyPlanDataFetch() {
    if (verifyPlanDataTimer) {
        clearInterval(verifyPlanDataTimer);
        verifyPlanDataTimer = null;
        console.log('验证计划页面数据自动获取已停止');
    }
}

// 更新验证计划页面期号信息
function updateVerifyPlanPeriodInfo() {
    // 检查是否已有历史数据，避免重复获取
    if (window.historyData && window.historyData.length > 0) {
        // 直接使用现有数据更新显示
        updateVerifyPlanDisplay();
        
        // 更新验证计划表格数据
        if (typeof window.updateVerifyPlanTable === 'function') {
            window.updateVerifyPlanTable();
        }
    } else {
        // 只有在没有数据时才获取新数据
        console.log('验证计划页面：检测到无历史数据，开始获取...');
        fetchHistoryData().then(result => {
            if (result && result.success) {
                updateVerifyPlanDisplay();
                
                // 更新验证计划表格数据
                if (typeof window.updateVerifyPlanTable === 'function') {
                    window.updateVerifyPlanTable();
                }
            }
        }).catch(error => {
            console.error('验证计划页面数据更新失败:', error);
        });
    }
}

// 倒计时相关变量
let countdownTimer = null;
let nextDrawTime = null;
let lastApiCallTime = 0;
let isUpdatingDrawTime = false;

// 获取下一期开奖时间
async function getNextDrawTime() {
    try {
        // 从API获取最新开奖数据
        const apiUrl = 'https://api.api68.com/pks/getLotteryPksInfo.do?lotCode=10057';
        const response = await fetch(apiUrl, {
            method: 'GET',
            headers: {
                'Accept': 'application/json',
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
            }
        });
        
        if (!response.ok) {
            throw new Error(`HTTP错误! 状态: ${response.status}`);
        }
        
        const data = await response.json();
        
        if (data.errorCode !== 0) {
            throw new Error(data.message || 'API返回错误');
        }
        
        if (data && data.result && data.result.data) {
            const nextDrawTime = data.result.data.drawTime;
            // 直接使用API返回的下一期开奖时间
            const nextDraw = new Date(nextDrawTime);
            lastApiCallTime = Date.now();
            return nextDraw;
        }
        
        throw new Error('API返回数据格式不正确');
    } catch (error) {
        console.error('获取下一期开奖时间失败:', error);
        return null;
    }
}

// 格式化倒计时显示
function formatCountdown(seconds) {
    if (seconds <= 0) {
        return '00:00';
    }
    
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;
    
    return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
}

// 启动倒计时
function startCountdown() {
    const verifyLastUpdate = document.getElementById('verifyLastUpdate');
    if (!verifyLastUpdate || !nextDrawTime) return;
    
    // 清除现有定时器
    if (countdownTimer) {
        clearInterval(countdownTimer);
    }
    
    countdownTimer = setInterval(async () => {
        const now = new Date();
        const timeDiff = nextDrawTime.getTime() - now.getTime();
        const remainingSeconds = Math.floor(timeDiff / 1000);
        
        if (remainingSeconds <= 0) {
            // 倒计时结束，显示开奖中状态
            clearInterval(countdownTimer);
            verifyLastUpdate.textContent = '倒计时: 开奖中...';
            
            // 设置一个较长的等待时间，等待数据自动更新
            // 数据更新会通过fetchHistoryData函数触发新的倒计时
            setTimeout(() => {
                // 如果长时间没有新数据，才尝试重新获取开奖时间
                if (verifyLastUpdate.textContent === '倒计时: 开奖中...') {
                    if (!isUpdatingDrawTime) {
                        updateVerifyPlanDisplay();
                    }
                }
            }, 300000); // 5分钟后才重试
        } else {
            verifyLastUpdate.textContent = `倒计时: ${formatCountdown(remainingSeconds)}`;
        }
    }, 1000);
}

// 更新验证计划页面显示信息
async function updateVerifyPlanDisplay() {
    const verifyPeriodCount = document.getElementById('verifyPeriodCount');
    const verifyLastUpdate = document.getElementById('verifyLastUpdate');
    
    if (verifyPeriodCount && window.historyData) {
        verifyPeriodCount.textContent = window.historyData.length;
    }
    
    if (verifyLastUpdate) {
        // 如果正在更新中，避免重复调用
        if (isUpdatingDrawTime) {
            return;
        }
        
        isUpdatingDrawTime = true;
        
        // 获取下一期开奖时间
        nextDrawTime = await getNextDrawTime();
        
        if (nextDrawTime) {
            isUpdatingDrawTime = false;
            // 启动倒计时
            startCountdown();
        } else {
            // 获取失败，显示错误信息
            verifyLastUpdate.textContent = '倒计时: 获取失败';
            isUpdatingDrawTime = false;
            
            // 5秒后重试
            setTimeout(() => {
                if (!isUpdatingDrawTime) {
                    updateVerifyPlanDisplay();
                }
            }, 5000);
        }
    }
}

// 显示通知消息
function showNotification(message, type = 'info') {
    // 创建通知元素
    const notification = document.createElement('div');
    notification.className = `fixed top-4 right-4 z-50 px-4 py-2 rounded-md text-white font-medium transition-all duration-300 transform translate-x-full`;
    
    // 根据类型设置颜色
    switch(type) {
        case 'success':
            notification.classList.add('bg-green-500');
            break;
        case 'error':
            notification.classList.add('bg-red-500');
            break;
        case 'warning':
            notification.classList.add('bg-yellow-500');
            break;
        default:
            notification.classList.add('bg-blue-500');
    }
    
    notification.textContent = message;
    document.body.appendChild(notification);
    
    // 显示动画
    setTimeout(() => {
        notification.classList.remove('translate-x-full');
    }, 100);
    
    // 3秒后隐藏
    setTimeout(() => {
        notification.classList.add('translate-x-full');
        setTimeout(() => {
            document.body.removeChild(notification);
        }, 300);
    }, 3000);
}

// 启动每分钟自动刷新 - 已禁用云端数据库功能
function startAutoRefresh() {
    // 云端数据库功能已禁用，不启动自动刷新
    console.log('云端数据库功能已禁用，自动刷新功能已停用');
}

// 停止自动刷新 - 已禁用云端数据库功能
function stopAutoRefresh() {
    // 云端数据库功能已禁用，清除任何现有定时器
    if (autoRefreshTimer) {
        clearInterval(autoRefreshTimer);
        autoRefreshTimer = null;
    }
    console.log('云端数据库功能已禁用，自动刷新功能已停用');
}

// 基于最新开奖时间的140秒倒计时功能
function startCountdownFromTime(timeStr) {
    try {
        // 解析时间字符串 (格式: "2024-01-15 14:30:25")
        const lastDrawTime = new Date(timeStr);
        if (isNaN(lastDrawTime.getTime())) {
            console.error('无效的时间格式:', timeStr);
            // 如果时间格式无效，使用默认140秒倒计时
            startCountdown(140);
            return;
        }
        
        // 计算下次开奖时间 (当前开奖时间 + 140秒)
        const nextDrawTime = new Date(lastDrawTime.getTime() + 140 * 1000);
        const now = new Date();
        const timeDiff = nextDrawTime.getTime() - now.getTime();
        
        if (timeDiff <= 0) {
            // 如果计算出的时间已经过去，立即刷新数据
            console.log('开奖时间已过，云端数据库功能已禁用');
            // autoRefreshLatestData(); // 已禁用云端数据库功能
            return;
        }
        
        // 计算剩余秒数并启动倒计时
        const remainingSeconds = Math.floor(timeDiff / 1000);
        console.log(`根据开奖时间 ${timeStr}，${remainingSeconds} 秒后自动刷新数据`);
        startCountdown(remainingSeconds);
        
    } catch (error) {
        console.error('倒计时启动失败:', error);
        // 出错时使用默认140秒倒计时
        startCountdown(140);
    }
}

// 黄金切割页面事件处理
document.addEventListener('DOMContentLoaded', function() {
    // 输入数据计数
    const goldenInputData = document.getElementById('goldenInputData');
    const goldenInputCount = document.getElementById('goldenInputCount');
    
    if (goldenInputData && goldenInputCount) {
        goldenInputData.addEventListener('input', function() {
            const data = this.value.trim();
            if (!data) {
                goldenInputCount.classList.add('hidden');
                return;
            }
            
            // 解析输入数据
            const items = data.split(/[\n,;，]+/).map(s => s.trim()).filter(s => s);
            goldenInputCount.textContent = `共 ${items.length} 项`;
            goldenInputCount.classList.remove('hidden');
        });
    }
    
    // 模式切换按钮
    const modeUniformBtn = document.getElementById('modeUniformBtn');
    const modeStableBtn = document.getElementById('modeStableBtn');
    const modeDescription = document.getElementById('modeDescription');
    
    let currentMode = 'uniform'; // 默认均匀模式
    
    if (modeUniformBtn && modeStableBtn) {
        modeUniformBtn.addEventListener('click', function() {
            currentMode = 'uniform';
            modeUniformBtn.classList.add('active-mode');
            modeUniformBtn.classList.remove('inactive-mode');
            modeStableBtn.classList.add('inactive-mode');
            modeStableBtn.classList.remove('active-mode');
            modeDescription.textContent = '均匀模式：一次性分完就用，不保持历史分组';
        });
        
        modeStableBtn.addEventListener('click', function() {
            currentMode = 'stable';
            modeStableBtn.classList.add('active-mode');
            modeStableBtn.classList.remove('inactive-mode');
            modeUniformBtn.classList.add('inactive-mode');
            modeUniformBtn.classList.remove('active-mode');
            modeDescription.textContent = '稳定模式：维护长期分组，不想每次重新切割';
        });
    }
    
    // 分割按钮
    const goldenSplitBtn = document.getElementById('goldenSplitBtn');
    if (goldenSplitBtn) {
        goldenSplitBtn.addEventListener('click', function() {
            const inputData = document.getElementById('goldenInputData').value.trim();
            
            if (!inputData) {
                alert('请输入要分割的数据');
                return;
            }
            
            // 解析输入数据
            const items = parseInput(inputData);
            
            if (items.length === 0) {
                alert('没有有效的数据');
                return;
            }
            
            // 根据当前模式执行黄金切割
            const assignMode = currentMode === 'uniform' ? 'roundrobin' : 'hash';
            const groups = goldenSplit5in4(items, assignMode);
            
            // 验证结果
            const isValid = validate5in4(groups, items);
            
            // 重置所有复制按钮状态（新的切割开始）
            resetAllCopyButtons();
            
            // 渲染结果
            renderGoldenResults(groups, items, isValid);
            
            console.log('分割完成:', groups, '验证结果:', isValid);
        });
    }
    
    // 粘贴数据按钮
    const goldenPasteBtn = document.getElementById('goldenPasteBtn');
    if (goldenPasteBtn) {
        goldenPasteBtn.addEventListener('click', async function() {
            try {
                // 检查剪贴板API是否可用
                if (!navigator.clipboard || !navigator.clipboard.readText) {
                    // 降级到传统方法
                    const textarea = document.createElement('textarea');
                    document.body.appendChild(textarea);
                    textarea.focus();
                    document.execCommand('paste');
                    const text = textarea.value;
                    document.body.removeChild(textarea);
                    
                    if (text.trim()) {
                        document.getElementById('goldenInputData').value = text.trim();
                        // 触发输入事件以更新计数
                        const inputEvent = new Event('input', { bubbles: true });
                        document.getElementById('goldenInputData').dispatchEvent(inputEvent);
                    }
                    return;
                }
                
                // 尝试从剪贴板读取数据
                const text = await navigator.clipboard.readText();
                if (text.trim()) {
                    document.getElementById('goldenInputData').value = text.trim();
                    
                    // 触发输入事件以更新计数
                    const inputEvent = new Event('input', { bubbles: true });
                    document.getElementById('goldenInputData').dispatchEvent(inputEvent);
                } else {
                    alert('剪贴板为空');
                }
            } catch (err) {
                console.error('无法访问剪贴板:', err);
                // 提示用户使用快捷键粘贴
                alert('请使用 Ctrl+V (Windows) 或 Cmd+V (Mac) 手动粘贴数据到输入框');
            }
        });
    }
    
    // 清空按钮
    const goldenClearBtn = document.getElementById('goldenClearBtn');
    if (goldenClearBtn) {
        goldenClearBtn.addEventListener('click', function() {
            // 清空输入
            document.getElementById('goldenInputData').value = '';
            document.getElementById('goldenInputCount').classList.add('hidden');
            
            // 清空结果
            document.getElementById('goldenResults').innerHTML = '';
            document.getElementById('validationResults').classList.add('hidden');
            
            console.log('已清空所有数据');
        });
    }
    
});

// 页面完全加载后启动历史数据获取
window.addEventListener('load', function() {
    // 历史数据获取功能已禁用 - 防止页面卡死
    console.log('页面完全加载完成，历史数据获取功能已禁用');
    // setTimeout(() => {
    //     console.log('页面完全加载完成，启动历史数据获取功能...');
    //     startHistoryDataFetch();
    //     
    //     // 同时为验证计划页面启动数据获取
    //     console.log('为验证计划页面启动独立的数据获取机制...');
    //     startVerifyPlanDataFetch();
    // }, 1000);
});

// 验证计划数据存储（全局变量）
window.verifyPlanData = window.verifyPlanData || [];

// 验证状态管理器
window.VerificationStateManager = {
    isVerifying: false,
    lastVerificationTime: 0,
    verificationCooldown: 2000, // 2秒冷却时间
    
    canVerify: function() {
        const now = Date.now();
        return !this.isVerifying && (now - this.lastVerificationTime) > this.verificationCooldown;
    },
    
    startVerification: function() {
        this.isVerifying = true;
        console.log('🔄 开始验证流程');
    },
    
    endVerification: function() {
        this.isVerifying = false;
        this.lastVerificationTime = Date.now();
        console.log('✅ 验证流程结束');
    },
    
    reset: function() {
        this.isVerifying = false;
        this.lastVerificationTime = 0;
        console.log('🔄 重置验证状态');
    }
};

// 验证计划页面功能
// 计算下一期期号的函数（全局函数）
function calculateNextPeriod(currentPeriod) {
    if (!currentPeriod) return null;
    
    const periodStr = currentPeriod.toString();
    
    // 台湾PK10期号格式：11位数字，如20250922178
    // 前8位是日期相关(YYYYMMDD)，后3位是当日期数
    // 下一期期号就是当前最新期号+1
    if (periodStr.length === 11) {
        const prefix = periodStr.substring(0, 8); // YYYYMMDD
        const suffix = periodStr.substring(8); // 后3位期数
        const suffixNum = parseInt(suffix, 10);
        
        // 直接计算下一期期号：后3位+1
        const nextSuffix = (suffixNum + 1).toString().padStart(3, '0');
        return prefix + nextSuffix;
    }
    
    // 兼容其他格式：9位数字
    if (periodStr.length >= 9) {
        const prefix = periodStr.substring(0, periodStr.length - 3);
        const suffix = periodStr.substring(periodStr.length - 3);
        const suffixNum = parseInt(suffix, 10);
        const nextSuffix = (suffixNum + 1).toString().padStart(3, '0');
        return prefix + nextSuffix;
    }
    
    // 简单情况：直接+1
    return (parseInt(periodStr, 10) + 1).toString();
}

// 检查指定期号是否有开奖数据
function hasDrawnData(period) {
    const dataSource = window.r || window.historyData || [];
    return dataSource.some(item => item.period && item.period.toString() === period.toString());
}

// 初始化单期验证历史记录存储
if (!window.singlePeriodHistory) {
    window.singlePeriodHistory = [];
}

// 加载单期验证历史记录
function loadSinglePeriodHistory() {
    try {
        const saved = localStorage.getItem('singlePeriodHistory');
        if (saved) {
            window.singlePeriodHistory = JSON.parse(saved);
            console.log('单期验证：加载历史记录:', window.singlePeriodHistory.length, '条');
        } else {
            window.singlePeriodHistory = [];
        }
    } catch (e) {
        console.warn('单期验证：加载历史记录失败:', e);
        window.singlePeriodHistory = [];
    }
}

// 保存单期验证记录
function saveSinglePeriodRecord(period, periodData, validPlans) {
    if (!window.singlePeriodHistory) {
        window.singlePeriodHistory = [];
    }
    
    // 检查是否已存在该期号的记录
    const existingIndex = window.singlePeriodHistory.findIndex(record => record.period === period);
    
    if (existingIndex >= 0) {
        // 如果已存在，不重复保存
        console.log('单期验证：期号', period, '已存在验证记录，跳过保存');
        return;
    }
    
    // 创建验证记录
    const drawNumbers = periodData.data.slice(0, 5).map(n => parseInt(n));
    let hasWin = false;
    let winningPlans = [];
    
    // 检查每个验证计划
    for (const plan of validPlans) {
        const planNums = Array.isArray(plan.planNumbers) ? plan.planNumbers : [];
        let planHasWin = false;
        
        for (const numberStr of planNums) {
            let numbers;
            if (Array.isArray(numberStr)) {
                numbers = numberStr.map(n => parseInt(n));
            } else if (typeof numberStr === 'string') {
                const parts = numberStr.split(/[\s,]+/).filter(Boolean);
                numbers = parts.map(n => parseInt(n));
            } else {
                continue;
            }
            
            // 检查五星命中（五个位置完全匹配）
            if (numbers.length === 5 && numbers.every((n, idx) => !isNaN(n) && drawNumbers[idx] !== undefined && n === drawNumbers[idx])) {
                planHasWin = true;
                hasWin = true;
                break;
            }
        }
        
        if (planHasWin) {
            winningPlans.push(plan);
        }
    }
    
    const record = {
        period: period,
        drawNumbers: drawNumbers,
        hasWin: hasWin,
        winningPlans: winningPlans,
        totalPlans: validPlans.length,
        totalBets: validPlans.reduce((sum, plan) => sum + (plan.betCount || 0), 0),
        timestamp: new Date().toISOString(),
        validPlans: validPlans.map(plan => ({
            displayName: plan.displayName,
            betCount: plan.betCount,
            planNumbers: plan.planNumbers
        }))
    };
    
    // 添加新记录
    window.singlePeriodHistory.push(record);
    console.log('单期验证：保存新验证记录:', period);
    
    // 按期号降序排序（最新的在前）
    window.singlePeriodHistory.sort((a, b) => {
        return parseInt(b.period) - parseInt(a.period);
    });
    
    // 只保留最近20期记录
    if (window.singlePeriodHistory.length > 20) {
        window.singlePeriodHistory = window.singlePeriodHistory.slice(0, 20);
    }
    
    // 保存到本地存储
    try {
        localStorage.setItem('singlePeriodHistory', JSON.stringify(window.singlePeriodHistory));
    } catch (e) {
        console.warn('单期验证：保存历史记录到本地存储失败:', e);
    }
}

// 保存单个计划的验证记录
function saveSinglePeriodPlanRecord(period, periodData, plan) {
    if (!window.singlePeriodHistory) {
        window.singlePeriodHistory = [];
    }
    
    // 检查是否已存在该期号和计划的记录
    const existingIndex = window.singlePeriodHistory.findIndex(record => 
        record.period === period && 
        record.validPlans.some(vp => vp.planHash === plan.planHash || vp.displayName === plan.displayName)
    );
    
    if (existingIndex >= 0) {
        console.log('单期验证：期号', period, '计划', plan.displayName, '已存在验证记录，跳过保存');
        return;
    }
    
    // 创建验证记录
    const drawNumbers = periodData.data.slice(0, 5).map(n => parseInt(n));
    let planHasWin = false;
    
    // 检查该计划是否命中
    const planNums = Array.isArray(plan.planNumbers) ? plan.planNumbers : [];
    for (const numberStr of planNums) {
        let numbers;
        if (Array.isArray(numberStr)) {
            numbers = numberStr.map(n => parseInt(n));
        } else if (typeof numberStr === 'string') {
            const parts = numberStr.split(/[\s,]+/).filter(Boolean);
            numbers = parts.map(n => parseInt(n));
        } else {
            continue;
        }
        
        // 检查五星命中（五个位置完全匹配）
        if (numbers.length === 5 && numbers.every((n, idx) => !isNaN(n) && drawNumbers[idx] !== undefined && n === drawNumbers[idx])) {
            planHasWin = true;
            break;
        }
    }
    
    const record = {
        period: period,
        drawNumbers: drawNumbers,
        hasWin: planHasWin,
        winningPlans: planHasWin ? [plan] : [],
        totalPlans: 1,
        totalBets: plan.betCount || 0,
        timestamp: new Date().toISOString(),
        validPlans: [{
            displayName: plan.displayName,
            betCount: plan.betCount,
            planNumbers: plan.planNumbers,
            planHash: plan.planHash,
            generationConditions: plan.generationConditions
        }]
    };
    
    // 添加新记录
    window.singlePeriodHistory.push(record);
    console.log('单期验证：保存新验证记录:', period, plan.displayName);
    
    // 按期号降序排序（最新的在前）
    window.singlePeriodHistory.sort((a, b) => {
        return parseInt(b.period) - parseInt(a.period);
    });
    
    // 只保留最近50期记录
    if (window.singlePeriodHistory.length > 50) {
        window.singlePeriodHistory = window.singlePeriodHistory.slice(0, 50);
    }
    
    // 保存到本地存储
    try {
        localStorage.setItem('singlePeriodHistory', JSON.stringify(window.singlePeriodHistory));
    } catch (e) {
        console.warn('单期验证：保存历史记录到本地存储失败:', e);
    }
}

// 显示历史验证记录（不同期号的记录）
function displayHistoricalRecords(tableBody, currentPeriod) {
    if (!window.singlePeriodHistory || window.singlePeriodHistory.length === 0) {
        return;
    }
    
    // 过滤掉当前验证期号，显示最近10期的历史记录
    const historyRecords = window.singlePeriodHistory
        .filter(record => record.period !== currentPeriod)
        .slice(0, 10);
    
    for (const record of historyRecords) {
        const row = document.createElement('tr');
        row.className = 'bg-gray-100';
        
        // 期号列
        const periodCell = document.createElement('td');
        periodCell.className = 'border border-gray-300 px-3 py-2 text-left font-medium text-gray-600';
        periodCell.innerHTML = `${record.period} <span class="text-xs text-gray-500">(历史)</span>`;
        row.appendChild(periodCell);
        
        // 开奖号码列
        const numbersCell = document.createElement('td');
        numbersCell.className = 'border border-gray-300 px-3 py-2 text-left';
        numbersCell.innerHTML = `
            <div class="number-row font-mono text-gray-600">${record.drawNumbers.join(' ')}</div>
        `;
        row.appendChild(numbersCell);
        
        // 注数列
        const countCell = document.createElement('td');
        countCell.className = 'border border-gray-300 px-3 py-2 text-center text-gray-600';
        countCell.textContent = record.totalBets + '注';
        row.appendChild(countCell);
        
        // 状态列
        const statusCell = document.createElement('td');
        statusCell.className = 'border border-gray-300 px-3 py-2 text-center';
        
        if (record.hasWin) {
            statusCell.innerHTML = `<span class="text-green-600 font-bold">中</span>`;
        } else {
            statusCell.innerHTML = `<span class="text-red-600 font-bold">挂</span>`;
        }
        row.appendChild(statusCell);
        
        // 计划规则列
        const planCell = document.createElement('td');
        planCell.className = 'border border-gray-300 px-3 py-2 text-left text-gray-600';
        
        // 显示该记录的计划信息
        const plan = record.validPlans[0]; // 每个记录只包含一个计划
        if (plan) {
            const conditions = plan.generationConditions || {};
            const groups = Array.isArray(conditions.groups) ? conditions.groups : [];
            let ruleText = '';
            
            if (groups.length > 0) {
                // 收集所有选择的数字和胆码
                const allSelectedNumbers = [];
                const allSelectedDamas = [];
                
                groups.forEach(g => {
                    const numbers = Array.isArray(g.selectedNumbers) ? g.selectedNumbers : [];
                    const damas = Array.isArray(g.selectedDamas) ? g.selectedDamas : [];
                    
                    // 收集所有选择的数字（去重）
                    numbers.forEach(num => {
                        if (!allSelectedNumbers.includes(num)) {
                            allSelectedNumbers.push(num);
                        }
                    });
                    
                    // 收集所有胆码（去重）
                    damas.forEach(dama => {
                        if (!allSelectedDamas.includes(dama)) {
                            allSelectedDamas.push(dama);
                        }
                    });
                });
                
                // 构建显示文本
                const parts = [];
                
                // 显示选择的数字
                if (allSelectedNumbers.length > 0) {
                    allSelectedNumbers.sort((a, b) => parseInt(a) - parseInt(b));
                    parts.push(allSelectedNumbers.join(','));
                }
                
                // 显示胆码
                if (allSelectedDamas.length > 0) {
                    allSelectedDamas.sort((a, b) => parseInt(a) - parseInt(b));
                    parts.push(`中${allSelectedDamas.join(',')}胆`);
                }
                
                // 添加总容错信息
                const moduleToleranceMin = conditions.moduleToleranceMin || 0;
                const moduleToleranceMax = conditions.moduleToleranceMax || 0;
                if (moduleToleranceMin !== 0 || moduleToleranceMax !== 0) {
                    if (moduleToleranceMin === moduleToleranceMax) {
                        parts.push(`总容错${moduleToleranceMin}`);
                    } else {
                        parts.push(`总容错${moduleToleranceMin}-${moduleToleranceMax}`);
                    }
                }
                
                ruleText = parts.join(' ');
            } else {
                // 没有组信息时，尝试从其他字段获取信息
                const selectedNumbers = Array.isArray(conditions.selectedNumbers) ? conditions.selectedNumbers : [];
                if (selectedNumbers.length > 0) {
                    ruleText = `选号:${selectedNumbers.join(',')}`;
                }
            }
            
            // 如果没有规则信息，显示计划名称和注数
            if (!ruleText || ruleText.trim() === '') {
                ruleText = `${plan.displayName || '计划'} (${plan.betCount}注)`;
            }
            
            planCell.innerHTML = `<div class="text-sm">${ruleText}</div>`;
        } else {
            planCell.innerHTML = `<div class="text-sm text-gray-400">无计划信息</div>`;
        }
        
        row.appendChild(planCell);
        
        // 操作列 - 添加删除按钮（历史记录）
        const actionCell = document.createElement('td');
        actionCell.className = 'border border-gray-300 px-3 py-2 text-center';
        
        // 创建删除按钮
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'px-2 py-1 bg-red-500 text-white text-xs rounded hover:bg-red-600 transition-colors';
        deleteBtn.textContent = '删除';
        deleteBtn.title = '删除此历史记录';
        
        // 绑定删除事件，传递记录的期号
        deleteBtn.onclick = function() {
            deleteHistoricalRecord(record.period);
        };
        
        actionCell.appendChild(deleteBtn);
        row.appendChild(actionCell);
        
        tableBody.appendChild(row);
    }
}

// 旧的displayAllSinglePeriodRecords函数已移除，使用新的多期验证逻辑

// 单期验证表格更新函数（按计划独立目标期）
// 单期验证轮询定时器
window.singlePeriodPollingTimer = null;
window.singlePeriodTargetPeriod = null;

function updateSinglePeriodTable(pageSize = 20, currentPage = 1) {
    // 检查验证状态管理器
    if (!window.VerificationStateManager.canVerify()) {
        console.log('⏸️ 验证正在进行中或在冷却期，跳过本次验证');
        return;
    }
    
    // 开始验证流程
    window.VerificationStateManager.startVerification();
    
    const singlePeriodTableBody = document.getElementById('singlePeriodTableBody');
    if (!singlePeriodTableBody) {
        window.VerificationStateManager.endVerification();
        return;
    }

    // 获取验证计划
    const verifyPlans = window.verifyPlanData || [];
    const validPlans = verifyPlans.filter(plan => plan.betCount && plan.betCount > 0);

    // 清空表格
    singlePeriodTableBody.innerHTML = '';

    // 如果没有验证计划，显示提示信息
    if (validPlans.length === 0) {
        singlePeriodTableBody.innerHTML = `
            <tr>
                <td colspan="6" class="py-4 text-center text-gray-500">
                    暂无验证计划，请先在做号拼接页面生成验证计划
                </td>
            </tr>
        `;
        window.VerificationStateManager.endVerification();
        return;
    }

    // 性能优化：如果计划数量很多，实现分页显示
    const totalPlans = validPlans.length;
    if (totalPlans > pageSize) {
        console.log(`📊 检测到大量验证计划(${totalPlans}条)，启用分页显示优化`);
        
        // 初始化分页状态
        if (!window.singlePeriodPagination) {
            window.singlePeriodPagination = {
                currentPage: 1,
                pageSize: pageSize,
                totalPages: Math.ceil(totalPlans / pageSize)
            };
        }
        
        // 更新分页信息
        window.singlePeriodPagination.totalPages = Math.ceil(totalPlans / pageSize);
        window.singlePeriodPagination.currentPage = Math.min(currentPage, window.singlePeriodPagination.totalPages);
        
        // 计算当前页的数据范围
        const startIndex = (window.singlePeriodPagination.currentPage - 1) * pageSize;
        const endIndex = Math.min(startIndex + pageSize, totalPlans);
        const currentPagePlans = validPlans.slice(startIndex, endIndex);
        
        console.log(`📄 显示第 ${window.singlePeriodPagination.currentPage}/${window.singlePeriodPagination.totalPages} 页，共 ${currentPagePlans.length} 条记录`);
        
        // 显示分页信息
        this.showPaginationInfo(singlePeriodTableBody, window.singlePeriodPagination, totalPlans);
        
        // 处理当前页的计划
        this.processPlansPage(currentPagePlans, singlePeriodTableBody);
        
        // 显示分页控件
        this.showPaginationControls(singlePeriodTableBody, window.singlePeriodPagination);
        
        window.VerificationStateManager.endVerification();
        return;
    }

    // 检查数据源
    let dataSource = null;
    if (window.r && window.r.length > 0) {
        dataSource = window.r;
    } else if (window.historyData && window.historyData.length > 0) {
        dataSource = window.historyData;
    }

    if (!dataSource || dataSource.length === 0) {
        singlePeriodTableBody.innerHTML = `
            <tr>
                <td colspan="6" class="py-4 text-center text-gray-500">
                    暂无数据，请先在数据分析页面加载数据
                </td>
            </tr>
        `;
        window.VerificationStateManager.endVerification();
        return;
    }

    console.log('updateSinglePeriodTable: 开始使用多期验证逻辑，每个计划显示最近一期已开奖和下一期未开奖');
    
    // 按期号排序，最新的在前
    dataSource = dataSource.sort((a, b) => parseInt(b.period) - parseInt(a.period));
    
    // 获取最新期号，用于缓存验证
    const latestPeriod = dataSource.length > 0 ? dataSource[0].period : null;
    
    // 检查是否需要重新验证（数据源更新时）
    const needsRevalidation = !window.lastValidatedPeriod || window.lastValidatedPeriod !== latestPeriod;
    if (needsRevalidation) {
        console.log('检测到数据源更新，期号从', window.lastValidatedPeriod, '更新到', latestPeriod);
        window.lastValidatedPeriod = latestPeriod;
    }
    
    // 使用文档片段优化DOM操作
    const fragment = document.createDocumentFragment();
    
    // 对每个计划进行验证，每个计划验证2期后停止
    validPlans.forEach(plan => {
        if (!plan.planNumbers || plan.planNumbers.length === 0) return;
        
        // 如果计划已完成多期验证，跳过单期验证逻辑
        if (plan.isCompleted) {
            console.log('计划', plan.displayName || plan.planHash, '已完成多期验证，跳过单期验证');
            // 显示已完成状态的行
            const row = createSinglePeriodRowPending(null, plan, { period: plan.period || '已验证' });
            if (row) fragment.appendChild(row);
            return;
        }
        
        // 初始化验证状态
        if (!plan.singlePeriodVerificationResults) {
            plan.singlePeriodVerificationResults = [];
        }
        
        // 检查是否有缓存的验证结果且数据源未更新
        if (!needsRevalidation && plan.singlePeriodVerificationResults.length > 0) {
            console.log('计划', plan.displayName || plan.planHash, '使用缓存的验证结果，跳过重复验证');
            
            // 使用缓存结果显示
            if (plan.singlePeriodVerificationResults.length >= 2) {
                // 显示第二期验证结果
                const secondResult = plan.singlePeriodVerificationResults[1];
                if (secondResult) {
                    let row;
                    if (secondResult.hasDrawn) {
                        row = createSinglePeriodRow(null, plan, secondResult.periodData, secondResult.periodWin, secondResult.winningNumber, secondResult.drawNumbers);
                    } else {
                        row = createSinglePeriodRowPending(null, plan, secondResult.periodData);
                    }
                    if (row) fragment.appendChild(row);
                }
            } else if (plan.singlePeriodVerificationResults.length === 1) {
                // 只有第一期结果，显示下一期待验证
                const firstResult = plan.singlePeriodVerificationResults[0];
                const nextPeriodNumber = calculateNextPeriod(firstResult.periodData.period);
                const row = createSinglePeriodRowPending(null, plan, { period: nextPeriodNumber });
                if (row) fragment.appendChild(row);
            }
            return;
        }
        
        // 如果已经验证了2期，只显示第二期结果，不再更新
        if (plan.singlePeriodVerificationResults.length >= 2) {
            console.log('计划', plan.displayName || plan.planHash, '已完成2期验证，只显示第二期结果');
            
            // 只显示第二期验证结果（第一期在后台运行不显示）
            const secondResult = plan.singlePeriodVerificationResults[1];
            if (secondResult) {
                let row;
                if (secondResult.hasDrawn) {
                    // 第二期已开奖
                    row = createSinglePeriodRow(null, plan, secondResult.periodData, secondResult.periodWin, secondResult.winningNumber, secondResult.drawNumbers);
                } else {
                    // 第二期未开奖
                    row = createSinglePeriodRowPending(null, plan, secondResult.periodData);
                }
                if (row) fragment.appendChild(row);
            }
            return;
        }
        
        // 找到最近一期已开奖的数据
        const latestDrawnPeriod = dataSource.find(periodData => 
            periodData && periodData.data && periodData.data.length >= 5
        );
        
        if (latestDrawnPeriod) {
            // 检查是否已经验证过这一期
            const alreadyVerified = plan.singlePeriodVerificationResults.find(r => r.periodData.period === latestDrawnPeriod.period);
            
            if (!alreadyVerified) {
                // 验证最近一期已开奖的数据
                const drawNumbers = latestDrawnPeriod.data;
                let periodWin = false;
                let winningNumber = null;
                
                // 验证计划中的每注号码
                for (const numberStr of plan.planNumbers) {
                    const numbers = numberStr.split(' ').map(n => parseInt(n.trim()));
                    
                    // 根据计划的星级确定需要匹配的位数
                    const conditions = plan.generationConditions || {};
                    const moduleType = conditions.moduleType || '5星做号';
                    const starLevel = parseInt(moduleType.match(/(\d+)星/)?.[1]) || 5;
                    
                    // 检查是否为有效的号码
                    if (numbers.length === starLevel && numbers.every(n => !isNaN(n))) {
                        // 严格判定：前几位顺序完全一致才算中
                        const frontNumbers = drawNumbers.slice(0, starLevel);
                        const exactMatch = numbers.every((num, idx) => num === frontNumbers[idx]);
                        
                        if (exactMatch) {
                            periodWin = true;
                            winningNumber = numberStr;
                            break;
                        }
                    }
                }
                
                // 保存验证结果
                plan.singlePeriodVerificationResults.push({
                    periodData: latestDrawnPeriod,
                    hasDrawn: true,
                    periodWin: periodWin,
                    winningNumber: winningNumber,
                    drawNumbers: drawNumbers
                });
                
                console.log('计划', plan.displayName || plan.planHash, '验证第', plan.singlePeriodVerificationResults.length, '期:', latestDrawnPeriod.period, '结果:', periodWin ? '中' : '挂');
            }
            
            // 第一期验证在后台运行，不显示在界面上
            console.log('计划', plan.displayName || plan.planHash, '第一期验证在后台完成，不显示在界面');
        }
        
        // 如果还没验证满2期，显示下一期未开奖
        if (plan.singlePeriodVerificationResults.length < 2) {
            // 找到下一期未开奖的数据，如果没有则创建下一期
            let nextPeriod = dataSource.find(periodData => 
                periodData && (!periodData.data || periodData.data.length < 5)
            );
            
            // 如果没有找到未开奖期，创建下一期
            if (!nextPeriod && latestDrawnPeriod) {
                const nextPeriodNumber = calculateNextPeriod(latestDrawnPeriod.period);
                nextPeriod = {
                    period: nextPeriodNumber,
                    data: null // 未开奖
                };
            }
            
            if (nextPeriod) {
                // 检查下一期是否已开奖
                const nextPeriodDrawn = nextPeriod.data && nextPeriod.data.length >= 5;
                
                if (nextPeriodDrawn) {
                    // 下一期已开奖，进行验证并保存结果
                    const drawNumbers = nextPeriod.data;
                    let periodWin = false;
                    let winningNumber = null;
                    
                    // 验证计划中的每注号码
                    for (const numberStr of plan.planNumbers) {
                        const numbers = numberStr.split(' ').map(n => parseInt(n.trim()));
                        
                        // 根据计划的星级确定需要匹配的位数
                        const conditions = plan.generationConditions || {};
                        const moduleType = conditions.moduleType || '5星做号';
                        const starLevel = parseInt(moduleType.match(/(\d+)星/)?.[1]) || 5;
                        
                        // 检查是否为有效的号码
                        if (numbers.length === starLevel && numbers.every(n => !isNaN(n))) {
                            // 严格判定：前几位顺序完全一致才算中
                            const frontNumbers = drawNumbers.slice(0, starLevel);
                            const exactMatch = numbers.every((num, idx) => num === frontNumbers[idx]);
                            
                            if (exactMatch) {
                                periodWin = true;
                                winningNumber = numberStr;
                                break;
                            }
                        }
                    }
                    
                    // 保存第二期验证结果
                    plan.singlePeriodVerificationResults.push({
                        periodData: nextPeriod,
                        hasDrawn: true,
                        periodWin: periodWin,
                        winningNumber: winningNumber,
                        drawNumbers: drawNumbers
                    });
                    
                    console.log('计划', plan.displayName || plan.planHash, '验证第2期:', nextPeriod.period, '结果:', periodWin ? '中' : '挂', '验证完成');
                    
                    // 显示第二期已开奖的验证结果
                    const row = createSinglePeriodRow(null, plan, nextPeriod, periodWin, winningNumber, drawNumbers);
                    if (row) fragment.appendChild(row);
                } else {
                    // 第二期未开奖，显示待验证状态
                    const row = createSinglePeriodRowPending(null, plan, nextPeriod);
                    if (row) fragment.appendChild(row);
                }
            }
        }
    });

    // 一次性将所有行添加到表格中，优化DOM性能
    if (fragment.children.length > 0) {
        singlePeriodTableBody.appendChild(fragment);
    }

    // 更新单期验证控制信息
    updateSinglePeriodControls();
    
    // 保存验证结果到本地存储
    if (typeof window.PlanStorageManager !== 'undefined' && window.PlanStorageManager.saveToLocalStorage) {
        window.PlanStorageManager.saveToLocalStorage();
        console.log('💾 单期验证结果已保存到本地存储');
    }
    
    console.log('updateSinglePeriodTable: 表格更新完成，使用多期验证逻辑一期一排显示');
    
    // 结束验证流程
    window.VerificationStateManager.endVerification();
}

// 为每一期创建一行记录
function createSinglePeriodRow(tableBody, plan, periodData, periodWin, winningNumber, drawNumbers) {
    const row = document.createElement('tr');
    
    // 根据验证结果设置样式
    if (periodWin) {
        row.className = 'bg-green-50 border-l-4 border-green-500';
    } else {
        row.className = 'bg-red-50 border-l-4 border-red-500';
    }
    
    // 期号列
    const periodCell = document.createElement('td');
    periodCell.className = 'border border-gray-300 px-2 py-2 text-center font-medium';
    periodCell.style.width = '130px';
    periodCell.textContent = periodData.period;
    row.appendChild(periodCell);
    
    // 开奖号码列
    const numbersCell = document.createElement('td');
    numbersCell.className = 'border border-gray-300 px-3 py-2 text-center';
    numbersCell.style.width = '260px';
    numbersCell.innerHTML = `
        <div class="font-mono text-sm">${drawNumbers.join(' ')}</div>
    `;
    row.appendChild(numbersCell);
    
    // 注数列
    const countCell = document.createElement('td');
    countCell.className = 'border border-gray-300 px-3 py-2 text-center';
    countCell.style.width = '104px';
    countCell.textContent = plan.betCount + '注';
    row.appendChild(countCell);
    
    // 状态列
    const statusCell = document.createElement('td');
    statusCell.className = 'border border-gray-300 px-3 py-2 text-center';
    statusCell.style.width = '80px';
    if (periodWin) {
        statusCell.innerHTML = `<span class="text-green-600 font-bold">中</span>`;
    } else {
        statusCell.innerHTML = `<span class="text-red-600 font-bold">挂</span>`;
    }
    row.appendChild(statusCell);
    
    // 计划规则列
    const planCell = document.createElement('td');
    planCell.className = 'border border-gray-300 px-3 py-2 text-left';
    const conditions = plan.generationConditions || {};
    const groups = Array.isArray(conditions.groups) ? conditions.groups : [];
    let ruleText = '';
    
    if (groups.length > 0) {
        const conditionTexts = [];
        
        // 为每个条件组生成单独的文本
        groups.forEach((g, index) => {
            const numbers = Array.isArray(g.selectedNumbers) ? g.selectedNumbers : [];
            const damas = Array.isArray(g.selectedDamas) ? g.selectedDamas : [];
            
            if (numbers.length > 0 || damas.length > 0) {
                const sortedNumbers = [...numbers].sort((a, b) => parseInt(a) - parseInt(b));
                const sortedDamas = [...damas].sort((a, b) => parseInt(a) - parseInt(b));
                
                let conditionText = `${sortedNumbers.join(',')}`;
                if (sortedDamas.length > 0) {
                    conditionText += ` 中${sortedDamas.join(',')}胆`;
                }
                
                // 添加条件容错
                const toleranceMin = typeof g.toleranceMin === 'number' ? g.toleranceMin : 0;
                const toleranceMax = typeof g.toleranceMax === 'number' ? g.toleranceMax : 0;
                if (toleranceMin !== 0 || toleranceMax !== 0) {
                    if (toleranceMin === toleranceMax) {
                        conditionText += ` (容错${toleranceMin})`;
                    } else {
                        conditionText += ` (容错${toleranceMin}-${toleranceMax})`;
                    }
                }
                
                conditionTexts.push(conditionText);
            }
        });
        
        ruleText = conditionTexts.join(' ');
        
        // 添加总容错信息
        const moduleToleranceMin = typeof conditions.moduleToleranceMin === 'number' ? conditions.moduleToleranceMin : 0;
        const moduleToleranceMax = typeof conditions.moduleToleranceMax === 'number' ? conditions.moduleToleranceMax : 0;
        if (moduleToleranceMin !== 0 || moduleToleranceMax !== 0) {
            if (moduleToleranceMin === moduleToleranceMax) {
                ruleText += ` <strong>总容错: ${moduleToleranceMin}</strong>`;
            } else {
                ruleText += ` <strong>总容错: ${moduleToleranceMin}-${moduleToleranceMax}</strong>`;
            }
        }
    } else {
        ruleText = plan.displayName || plan.planHash || '未知计划';
    }
    
    planCell.innerHTML = ruleText;
    row.appendChild(planCell);
    
    // 操作列（删除）
    const actionCell = document.createElement('td');
    actionCell.className = 'border border-gray-300 px-3 py-2 text-center';
    actionCell.style.width = '104px';
    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'bg-red-500 text-white px-2 py-1 rounded hover:bg-red-600 text-xs';
    deleteBtn.textContent = '删除';
    deleteBtn.title = '删除此验证计划';
    deleteBtn.onclick = function() { deleteSinglePlan(plan.planHash, periodData.period); };
    actionCell.appendChild(deleteBtn);
    row.appendChild(actionCell);
    
    // 如果提供了tableBody，直接添加；否则返回行元素
    if (tableBody) {
        tableBody.appendChild(row);
    } else {
        return row;
    }
}

// 为未开奖期创建待验证记录
function createSinglePeriodRowPending(tableBody, plan, periodData) {
    const row = document.createElement('tr');
    
    // 设置待验证样式
    row.className = 'bg-blue-50 border-l-4 border-blue-500';
    
    // 期号列
    const periodCell = document.createElement('td');
    periodCell.className = 'border border-gray-300 px-2 py-2 text-center font-medium';
    periodCell.style.width = '130px';
    periodCell.textContent = periodData.period;
    row.appendChild(periodCell);
    
    // 开奖号码列
    const numbersCell = document.createElement('td');
    numbersCell.className = 'border border-gray-300 px-3 py-2 text-center';
    numbersCell.style.width = '260px';
    numbersCell.innerHTML = `
        <div class="text-gray-400">未开奖</div>
    `;
    row.appendChild(numbersCell);
    
    // 注数列
    const countCell = document.createElement('td');
    countCell.className = 'border border-gray-300 px-3 py-2 text-center';
    countCell.style.width = '104px';
    countCell.textContent = plan.betCount + '注';
    row.appendChild(countCell);
    
    // 状态列
    const statusCell = document.createElement('td');
    statusCell.className = 'border border-gray-300 px-3 py-2 text-center';
    statusCell.style.width = '80px';
    
    // 根据isCompleted字段显示正确的状态
    if (plan.isCompleted) {
        // 已完成验证，显示验证结果
        const result = plan.result || '已验证';
        if (result.includes('中')) {
            statusCell.innerHTML = `<span class="text-green-600 font-bold">${result}</span>`;
        } else if (result.includes('挂')) {
            statusCell.innerHTML = `<span class="text-red-600 font-bold">${result}</span>`;
        } else {
            statusCell.innerHTML = `<span class="text-gray-600 font-bold">${result}</span>`;
        }
    } else {
        // 未完成验证，显示待验证状态
        statusCell.innerHTML = `<span class="text-blue-600 font-bold">待验证</span>`;
    }
    row.appendChild(statusCell);
    
    // 计划规则列
    const planCell = document.createElement('td');
    planCell.className = 'border border-gray-300 px-3 py-2 text-left';
    const conditions = plan.generationConditions || {};
    const groups = Array.isArray(conditions.groups) ? conditions.groups : [];
    let ruleText = '';
    
    if (groups.length > 0) {
        const conditionTexts = [];
        
        // 为每个条件组生成单独的文本
        groups.forEach((g, index) => {
            const numbers = Array.isArray(g.selectedNumbers) ? g.selectedNumbers : [];
            const damas = Array.isArray(g.selectedDamas) ? g.selectedDamas : [];
            
            if (numbers.length > 0 || damas.length > 0) {
                const sortedNumbers = [...numbers].sort((a, b) => parseInt(a) - parseInt(b));
                const sortedDamas = [...damas].sort((a, b) => parseInt(a) - parseInt(b));
                
                let conditionText = `${sortedNumbers.join(',')}`;
                if (sortedDamas.length > 0) {
                    conditionText += ` 中${sortedDamas.join(',')}胆`;
                }
                
                // 添加条件容错
                const toleranceMin = typeof g.toleranceMin === 'number' ? g.toleranceMin : 0;
                const toleranceMax = typeof g.toleranceMax === 'number' ? g.toleranceMax : 0;
                if (toleranceMin !== 0 || toleranceMax !== 0) {
                    if (toleranceMin === toleranceMax) {
                        conditionText += ` (容错${toleranceMin})`;
                    } else {
                        conditionText += ` (容错${toleranceMin}-${toleranceMax})`;
                    }
                }
                
                conditionTexts.push(conditionText);
            }
        });
        
        ruleText = conditionTexts.join(' ');
        
        // 添加总容错信息
        const moduleToleranceMin = typeof conditions.moduleToleranceMin === 'number' ? conditions.moduleToleranceMin : 0;
        const moduleToleranceMax = typeof conditions.moduleToleranceMax === 'number' ? conditions.moduleToleranceMax : 0;
        if (moduleToleranceMin !== 0 || moduleToleranceMax !== 0) {
            if (moduleToleranceMin === moduleToleranceMax) {
                ruleText += ` <strong>总容错: ${moduleToleranceMin}</strong>`;
            } else {
                ruleText += ` <strong>总容错: ${moduleToleranceMin}-${moduleToleranceMax}</strong>`;
            }
        }
    } else {
        ruleText = plan.displayName || plan.planHash || '未知计划';
    }
    
    planCell.innerHTML = ruleText;
    row.appendChild(planCell);
    
    // 操作列（删除）
    const actionCell = document.createElement('td');
    actionCell.className = 'border border-gray-300 px-3 py-2 text-center';
    actionCell.style.width = '104px';
    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'bg-red-500 text-white px-2 py-1 rounded hover:bg-red-600 text-xs';
    deleteBtn.textContent = '删除';
    deleteBtn.title = '删除此验证计划';
    deleteBtn.onclick = function() { deleteSinglePlan(plan.planHash, periodData.period); };
    actionCell.appendChild(deleteBtn);
    row.appendChild(actionCell);
    
    // 如果提供了tableBody，直接添加；否则返回行元素
    if (tableBody) {
        tableBody.appendChild(row);
    } else {
        return row;
    }
}

// 移除单期验证轮询功能 - startSinglePeriodPolling函数已删除

// 移除单期验证主动检查功能 - checkSinglePeriodVerification函数已删除

// 移除单期验证轮询功能 - stopSinglePeriodPolling函数已删除

// 重置单期验证状态
function resetSinglePeriodVerification() {
    // 移除轮询相关调用
    singlePeriodTargetPeriod = null;
    console.log('🔄 重置单期验证状态');
}

// 保存单期验证结果（只处理匹配期号的计划）
// 移除单期验证结果保存功能 - saveSinglePeriodVerificationResults函数已删除

// 删除单个验证计划的函数
function deleteSinglePlan(planHash, currentPeriod) {
  if (!window.verifyPlanData || !Array.isArray(window.verifyPlanData)) {
    alert('验证计划数据不存在');
    return;
  }
  
  // 查找要删除的计划
  const planIndex = window.verifyPlanData.findIndex(plan => plan.planHash === planHash);
  
  if (planIndex === -1) {
    alert('未找到要删除的计划');
    return;
  }
  
  const plan = window.verifyPlanData[planIndex];
  const planName = plan.displayName || plan.planHash || '未知计划';
  
  // 移除确认对话框，直接删除
  // 从验证计划数组中删除
  window.verifyPlanData.splice(planIndex, 1);
  
  console.log(`🗑️ 删除了验证计划: ${planName}`);
  
  // 更新单期验证表格
  if (typeof updateSinglePeriodTable === 'function') {
    updateSinglePeriodTable();
  }
  
  // 移除删除成功的弹窗提示
}

// 分页辅助函数
function showPaginationInfo(currentPage, totalPages, totalPlans) {
    console.log(`📄 分页信息: 第${currentPage}页/共${totalPages}页，总计${totalPlans}个计划`);
}

function processPlansPage(plans, fragment) {
    // 获取数据源
    let dataSource = null;
    if (window.r && Array.isArray(window.r) && window.r.length > 0) {
        dataSource = window.r;
    } else if (window.historyData && Array.isArray(window.historyData) && window.historyData.length > 0) {
        dataSource = window.historyData;
    } else {
        console.warn('⚠️ 没有可用的数据源');
        return;
    }

    // 按期号排序，最新的在前
    dataSource = dataSource.sort((a, b) => parseInt(b.period) - parseInt(a.period));

    // 处理每个计划
    plans.forEach(plan => {
        if (!plan.planNumbers || plan.planNumbers.length === 0) return;

        // 如果计划已完成多期验证，跳过单期验证逻辑
        if (plan.isCompleted) {
            const row = createSinglePeriodRowPending(null, plan, { period: plan.period || '已验证' });
            if (row) fragment.appendChild(row);
            return;
        }

        // 初始化验证状态
        if (!plan.singlePeriodVerificationResults) {
            plan.singlePeriodVerificationResults = [];
        }

        // 找到最近一期已开奖的数据
        const latestDrawnPeriod = dataSource.find(periodData => 
            periodData && periodData.data && periodData.data.length >= 5
        );

        if (latestDrawnPeriod) {
            // 验证最近一期已开奖的数据
            const drawNumbers = latestDrawnPeriod.data;
            let periodWin = false;
            let winningNumber = null;

            // 验证计划中的每注号码
            for (const numberStr of plan.planNumbers) {
                const numbers = numberStr.split(' ').map(n => parseInt(n.trim()));
                
                // 根据计划的星级确定需要匹配的位数
                const conditions = plan.generationConditions || {};
                const moduleType = conditions.moduleType || '5星做号';
                const starLevel = parseInt(moduleType.match(/(\d+)星/)?.[1]) || 5;
                
                // 检查是否为有效的号码
                if (numbers.length === starLevel && numbers.every(n => !isNaN(n))) {
                    // 严格判定：前几位顺序完全一致才算中
                    const frontNumbers = drawNumbers.slice(0, starLevel);
                    const exactMatch = numbers.every((num, idx) => num === frontNumbers[idx]);
                    
                    if (exactMatch) {
                        periodWin = true;
                        winningNumber = numberStr;
                        break;
                    }
                }
            }

            // 创建表格行
            const row = createSinglePeriodRow(null, plan, latestDrawnPeriod, periodWin, winningNumber, drawNumbers);
            if (row) fragment.appendChild(row);
        }
    });
}

function showPaginationControls(currentPage, totalPages, pageSize) {
    const controlsContainer = document.getElementById('single-period-pagination-controls');
    if (!controlsContainer) {
        // 创建分页控件容器
        const container = document.createElement('div');
        container.id = 'single-period-pagination-controls';
        container.className = 'flex justify-center items-center space-x-2 mt-4';
        
        const tableContainer = document.querySelector('#single-period-table').parentNode;
        tableContainer.appendChild(container);
    }

    const container = document.getElementById('single-period-pagination-controls');
    container.innerHTML = '';

    if (totalPages <= 1) return;

    // 首页按钮
    if (currentPage > 1) {
        const firstBtn = document.createElement('button');
        firstBtn.className = 'px-3 py-1 bg-blue-500 text-white rounded hover:bg-blue-600';
        firstBtn.textContent = '首页';
        firstBtn.onclick = () => updateSinglePeriodTable(pageSize, 1);
        container.appendChild(firstBtn);
    }

    // 上一页按钮
    if (currentPage > 1) {
        const prevBtn = document.createElement('button');
        prevBtn.className = 'px-3 py-1 bg-blue-500 text-white rounded hover:bg-blue-600';
        prevBtn.textContent = '上一页';
        prevBtn.onclick = () => updateSinglePeriodTable(pageSize, currentPage - 1);
        container.appendChild(prevBtn);
    }

    // 页码信息
    const pageInfo = document.createElement('span');
    pageInfo.className = 'px-3 py-1 text-gray-700';
    pageInfo.textContent = `第 ${currentPage} 页 / 共 ${totalPages} 页`;
    container.appendChild(pageInfo);

    // 下一页按钮
    if (currentPage < totalPages) {
        const nextBtn = document.createElement('button');
        nextBtn.className = 'px-3 py-1 bg-blue-500 text-white rounded hover:bg-blue-600';
        nextBtn.textContent = '下一页';
        nextBtn.onclick = () => updateSinglePeriodTable(pageSize, currentPage + 1);
        container.appendChild(nextBtn);
    }

    // 末页按钮
    if (currentPage < totalPages) {
        const lastBtn = document.createElement('button');
        lastBtn.className = 'px-3 py-1 bg-blue-500 text-white rounded hover:bg-blue-600';
        lastBtn.textContent = '末页';
        lastBtn.onclick = () => updateSinglePeriodTable(pageSize, totalPages);
        container.appendChild(lastBtn);
    }
}



// 删除历史记录的函数
function deleteHistoricalRecord(recordId) {
  // 从本地存储中获取历史记录
  const historyKey = 'singlePeriodHistory';
  let history = [];
  try {
    const stored = localStorage.getItem(historyKey);
    if (stored) {
      history = JSON.parse(stored);
    }
  } catch (e) {
    console.error('读取历史记录失败:', e);
    return;
  }
  
  // 查找要删除的记录（使用period字段匹配）
  const recordIndex = history.findIndex(record => record.period === recordId);
  
  if (recordIndex === -1) {
    alert('未找到要删除的历史记录');
    return;
  }
  
  const record = history[recordIndex];
  const recordName = record.period || record.planName || record.id || '未知记录';
  
  if (confirm(`确定要删除历史记录"${recordName}"吗？`)) {
    // 从历史记录数组中删除
    history.splice(recordIndex, 1);
    
    // 更新本地存储
    try {
      localStorage.setItem(historyKey, JSON.stringify(history));
      console.log(`🗑️ 删除了历史记录: ${recordName}`);
      
      // 更新单期验证表格
      if (typeof updateSinglePeriodTable === 'function') {
        updateSinglePeriodTable();
      }
      
      alert(`已删除历史记录"${recordName}"`);
    } catch (e) {
      console.error('保存历史记录失败:', e);
      alert('删除失败，请重试');
    }
  }
}

// 单期验证控制函数
function updateSinglePeriodControls() {
    // 获取当前验证目标期号
    const targetPeriod = window.singleVerifyTargetPeriod;
    
    // 当前验证期号显示已移除，此函数保留用于其他控制逻辑
}





document.addEventListener('DOMContentLoaded', function() {
    
    // 获取页面元素
    const pasteAndVerifyBtn = document.getElementById('pasteAndVerifyBtn');
    const verifyPlanTableBody = document.getElementById('verifyPlanTableBody');
    const verifyDataCount = document.getElementById('verifyDataCount');
    const totalPeriods = document.getElementById('totalPeriods');
    const successCount = document.getElementById('successCount');
    const failCount = document.getElementById('failCount');
    
    // 验证模式切换相关元素
    const multiPeriodModeBtn = document.getElementById('multiPeriodModeBtn');
    const singlePeriodModeBtn = document.getElementById('singlePeriodModeBtn');
    const multiPeriodTable = document.getElementById('multiPeriodTable');
    const singlePeriodTable = document.getElementById('singlePeriodTable');
    
    // 当前验证模式状态
    let currentVerifyMode = 'single'; // 'multi' 或 'single'
    
    // 验证模式切换函数 - 移到全局作用域
    window.switchVerifyMode = function(mode, skipTableUpdate = false) {
        // 获取必要的元素
        const multiPeriodModeBtn = document.getElementById('multiPeriodModeBtn');
        const singlePeriodModeBtn = document.getElementById('singlePeriodModeBtn');
        const multiPeriodTable = document.getElementById('multiPeriodTable');
        const singlePeriodTable = document.getElementById('singlePeriodTable');
        const planHistoryControls = document.getElementById('planHistoryControls');
        
        window.currentVerifyMode = mode;
        
        if (mode === 'single') {
            // 切换到单期验证模式
            if (multiPeriodModeBtn) multiPeriodModeBtn.className = 'px-4 py-2 bg-gray-100 text-gray-700 text-sm font-medium transition-colors hover:bg-gray-200';
            if (singlePeriodModeBtn) singlePeriodModeBtn.className = 'px-4 py-2 bg-blue-500 text-white text-sm font-medium transition-colors hover:bg-blue-600';
            if (multiPeriodTable) multiPeriodTable.classList.add('hidden');
            if (singlePeriodTable) singlePeriodTable.classList.remove('hidden');
            
            // 显示计划验证历史管理控件
            if (planHistoryControls) {
                planHistoryControls.style.display = 'block';
                if (typeof updateHistoryCount === 'function') {
                    updateHistoryCount();
                }
            }
            
            // 只在没有目标期号时才重新计算，保持已有的验证状态
            if (!window.singleVerifyTargetPeriod) {
                console.log('单期验证：首次切换模式，将计算目标期号');
            } else {
                console.log('单期验证：保持现有目标期号:', window.singleVerifyTargetPeriod);
            }
            
            // 更新单期验证表格（除非跳过表格更新）
            if (!skipTableUpdate && typeof updateSinglePeriodTable === 'function') {
                updateSinglePeriodTable();
            }
        } else {
            // 切换到多期验证模式
            if (multiPeriodModeBtn) multiPeriodModeBtn.className = 'px-4 py-2 bg-blue-500 text-white text-sm font-medium transition-colors hover:bg-blue-600';
            if (singlePeriodModeBtn) singlePeriodModeBtn.className = 'px-4 py-2 bg-gray-100 text-gray-700 text-sm font-medium transition-colors hover:bg-gray-200';
            if (multiPeriodTable) multiPeriodTable.classList.remove('hidden');
            if (singlePeriodTable) singlePeriodTable.classList.add('hidden');
            
            // 隐藏计划验证历史管理控件
            if (planHistoryControls) {
                planHistoryControls.style.display = 'none';
            }
            
            // 更新多期验证表格
            if (typeof window.updateVerifyPlanTable === 'function') {
                window.updateVerifyPlanTable();
            }
        }
    };
    

    
    // 绑定切换按钮事件
    if (multiPeriodModeBtn) {
        multiPeriodModeBtn.addEventListener('click', () => window.switchVerifyMode('multi'));
    }
    
    if (singlePeriodModeBtn) {
        singlePeriodModeBtn.addEventListener('click', () => window.switchVerifyMode('single'));
    }
    
    // 切换到验证计划页面的函数
    window.showVerifyPlanPage = function() {
        // 禁用滚动监听，防止页面切换时跳动
        if (typeof disableScrollListener === 'function') {
            disableScrollListener();
        }
        
        // 获取页面元素
        const dataAnalysisPage = document.getElementById('dataAnalysisPage');
        const fiveStarPage = document.getElementById('fiveStarPage');
        const verifyPlanPage = document.getElementById('verifyPlanPage');
        const goldenRatioPage = document.getElementById('goldenRatioPage');
        const dataAnalysisBtn = document.getElementById('dataAnalysisBtn');
        const fiveStarBtn = document.getElementById('fiveStarBtn');
        const verifyPlanBtn = document.getElementById('verifyPlanBtn');
        const goldenRatioBtn = document.getElementById('goldenRatioBtn');
        
        // 获取当前显示的页面类型
        function getCurrentPageType() {
            if (dataAnalysisPage && !dataAnalysisPage.classList.contains('hidden')) return 'dataAnalysis';
            if (fiveStarPage && !fiveStarPage.classList.contains('hidden')) return 'fiveStar';
            if (verifyPlanPage && !verifyPlanPage.classList.contains('hidden')) return 'verifyPlan';
            if (goldenRatioPage && !goldenRatioPage.classList.contains('hidden')) return 'goldenRatio';
            return 'dataAnalysis'; // 默认
        }
        
        // 保存当前页面的滚动位置
        const currentPage = getCurrentPageType();
        if (typeof saveScrollPosition === 'function') {
            saveScrollPosition(currentPage);
        }
        
        // 切换页面
        if (dataAnalysisPage) dataAnalysisPage.classList.add('hidden');
        if (fiveStarPage) fiveStarPage.classList.add('hidden');
        if (verifyPlanPage) verifyPlanPage.classList.remove('hidden');
        if (goldenRatioPage) goldenRatioPage.classList.add('hidden');
        
        // 更新按钮状态
        if (verifyPlanBtn) {
            verifyPlanBtn.classList.add('bg-primary');
            verifyPlanBtn.classList.remove('bg-gray-600');
        }
        if (dataAnalysisBtn) {
            dataAnalysisBtn.classList.add('bg-gray-600');
            dataAnalysisBtn.classList.remove('bg-primary');
        }
        if (fiveStarBtn) {
            fiveStarBtn.classList.add('bg-gray-600');
            fiveStarBtn.classList.remove('bg-primary');
        }
        if (goldenRatioBtn) {
            goldenRatioBtn.classList.add('bg-gray-600');
            goldenRatioBtn.classList.remove('bg-primary');
        }
        
        // 恢复验证计划页面的滚动位置
        if (typeof restoreScrollPosition === 'function') {
            restoreScrollPosition('verifyPlan');
        }
        
        // 加载历史数据（如果还没有加载）
        if (!r || r.length === 0) {
            console.log('验证计划页面：开始加载历史数据');
            fetchHistoryData();
        }
        
        // 同步数据分析页面的数据并更新表格
        console.log('验证计划页面: 开始同步数据');
        if (typeof window.syncDataToVerifyPlan === 'function') {
            window.syncDataToVerifyPlan();
        }
        if (typeof window.updateVerifyPlanTable === 'function') {
            window.updateVerifyPlanTable();
        }
        console.log('验证计划页面: 数据同步完成');
        
        // 启动数据自动更新（每2秒）
        if (window.verifyPlanUpdateInterval) {
            clearInterval(window.verifyPlanUpdateInterval);
        }
        window.verifyPlanUpdateInterval = setInterval(() => {
            if (!verifyPlanPage.classList.contains('hidden')) {
                fetchApiData();
                // 同时更新单期验证表格，确保自动验证
                if (typeof window.updateSinglePeriodTable === 'function') {
                    window.updateSinglePeriodTable();
                }
            }
        }, 2000);
        
        console.log('验证计划页面已激活，数据更新已启动');
        
        // 初始化验证模式为单期验证
        if (typeof window.switchVerifyMode === 'function') {
            // 延迟执行以确保DOM元素完全加载，并添加重试机制
            const initializeVerifyMode = () => {
                const planHistoryControls = document.getElementById('planHistoryControls');
                if (planHistoryControls) {
                    window.switchVerifyMode('single');
                    console.log('✅ 验证模式初始化成功，历史管理控件已显示');
                } else {
                    // 如果元素还没有加载，再次延迟重试
                    setTimeout(initializeVerifyMode, 200);
                }
            };
            setTimeout(initializeVerifyMode, 300);
        }
    };
    

    

    

    
    // 粘贴并验证按钮事件
    if (pasteAndVerifyBtn) {
        pasteAndVerifyBtn.addEventListener('click', async function() {
            try {
                // 从剪贴板读取数据
                const clipboardText = await navigator.clipboard.readText();
                if (!clipboardText.trim()) {
                    alert('剪贴板为空，请先复制需要验证的数据');
                    return;
                }
                
                console.log('粘贴的数据:', clipboardText);
                
                // 解析粘贴的数据并进行批量验证
                await processPastedData(clipboardText);
                
            } catch (error) {
                console.error('读取剪贴板失败:', error);
                alert('读取剪贴板失败，请确保浏览器允许访问剪贴板');
            }
        });
    }
    

    
    // 处理粘贴的数据并进行批量验证
    async function processPastedData(clipboardText) {
        try {
            console.log('开始处理粘贴的数据:', clipboardText);
            
            // 检查是否有历史数据
            if (!r || r.length === 0) {
                alert('没有历史数据，请先在数据分析页面加载数据');
                return;
            }
            
            // 解析粘贴的数据
            // 首先检查是否是五星做号的格式（逗号分隔的多注，每注内部空格分隔）
            let validLines = [];
            
            // 如果包含逗号，可能是五星做号的多注格式
            if (clipboardText.includes(',')) {
                console.log('检测到逗号分隔格式，尝试解析五星做号数据');
                const parts = clipboardText.trim().split(',');
                
                for (let part of parts) {
                    part = part.trim();
                    if (!part) continue;
                    
                    // 检查是否是空格分隔的五星号码格式（如"01 02 03 04 05"）
                    if (part.includes(' ')) {
                        const numbers = part.split(/\s+/).map(n => parseInt(n.trim())).filter(n => !isNaN(n) && n >= 1 && n <= 10);
                        if (numbers.length === 5) { // 五星必须是5个数字
                            validLines.push(numbers.join(','));
                        }
                    }
                    // 也支持单个数字的逗号分隔格式
                    else {
                        const num = parseInt(part.trim());
                        if (!isNaN(num) && num >= 1 && num <= 10) {
                            // 这种情况下，需要收集5个数字组成一注
                            // 暂时先跳过，因为这种格式比较复杂
                        }
                    }
                }
            }
            
            // 如果上面没有解析出有效数据，尝试按行解析
            if (validLines.length === 0) {
                console.log('按行解析数据');
                const lines = clipboardText.trim().split('\n');
                
                for (let line of lines) {
                    line = line.trim();
                    if (!line) continue;
                    
                    // 尝试解析不同格式的数据
                    let numbers = [];
                    
                    // 格式1: 逗号分隔 "1,2,3,4,5"
                    if (line.includes(',')) {
                        numbers = line.split(',').map(n => parseInt(n.trim())).filter(n => !isNaN(n) && n >= 1 && n <= 10);
                    }
                    // 格式2: 空格分隔 "1 2 3 4 5" 或 "01 02 03 04 05"
                    else if (line.includes(' ')) {
                        numbers = line.split(/\s+/).map(n => parseInt(n.trim())).filter(n => !isNaN(n) && n >= 1 && n <= 10);
                    }
                    // 格式3: 制表符分隔
                    else if (line.includes('\t')) {
                        numbers = line.split('\t').map(n => parseInt(n.trim())).filter(n => !isNaN(n) && n >= 1 && n <= 10);
                    }
                    // 格式4: 单个数字或其他分隔符
                    else {
                        const matches = line.match(/\d+/g);
                        if (matches) {
                            numbers = matches.map(n => parseInt(n)).filter(n => n >= 1 && n <= 10);
                        }
                    }
                    
                    if (numbers.length > 0) {
                        validLines.push(numbers.join(','));
                    }
                }
            }
            
            if (validLines.length === 0) {
                alert('未能解析出有效的号码数据，请检查数据格式');
                return;
            }
            
            console.log('解析出的有效号码:', validLines);
            
            // 使用最新一期数据验证整个计划
            const latestPeriod = r[0]; // 最新一期
            const frontFive = latestPeriod.data.slice(0, 5);
            
            // 检查整个计划是否有任何一注命中（根据星级动态匹配）
            let isWin = false;
            for (const numberStr of validLines) {
                const numbers = numberStr.split(',').map(n => parseInt(n.trim()));
                // 根据号码长度确定星级，并进行相应的位置匹配
                const starLevel = numbers.length;
                if (starLevel >= 2 && starLevel <= 5) {
                    const isExactMatch = numbers.every((num, index) => num === frontFive[index]);
                    if (isExactMatch) {
                        isWin = true;
                        console.log(`${starLevel}星命中：号码 ${numbers.join(',')} 匹配开奖前${starLevel}位`);
                        break; // 只要有一注命中就停止检查
                    }
                }
            }
            
            // 创建单条验证记录
            const verifyRecord = {
                period: latestPeriod.period,
                planNumbers: validLines,
                betCount: validLines.length,
                result: isWin ? '中' : '挂',
                latestData: latestPeriod.data
            };
            
            // 将验证结果添加到验证计划数据
            window.verifyPlanData.unshift(verifyRecord);
            
            // 更新表格和统计
            updateVerifyPlanTable();
            updateStatistics();
            
            // 同时更新单期验证表格
            if (typeof updateSinglePeriodTable === 'function') {
                updateSinglePeriodTable();
            }
            
        } catch (error) {
            console.error('处理粘贴数据时出错:', error);
            alert('处理数据时出错: ' + error.message);
        }
    }
    
    // 同步数据分析页面的数据到验证计划页面
    window.syncDataToVerifyPlan = function() {
        console.log('开始同步数据到验证计划页面');
        
        // 确保验证计划数据已初始化
        if (!window.verifyPlanData) {
            window.verifyPlanData = [];
        }
        
        // 检查数据源：优先使用window.r（数据分析页面的主数据源），其次使用window.historyData
        let dataSource = null;
        if (window.r && window.r.length > 0) {
            dataSource = window.r;
            console.log('找到window.r数据，共', dataSource.length, '条记录');
        } else if (window.historyData && window.historyData.length > 0) {
            dataSource = window.historyData;
            console.log('找到historyData数据，共', dataSource.length, '条记录');
        }
        
        // 检查数据是否存在
        if (dataSource && dataSource.length > 0) {
            
            // 不再自动初始化默认的0注记录，只保留真实的验证计划数据
            // 验证计划数据只有在用户实际添加验证计划时才会创建
            
            // 如果验证计划数据已存在，只更新已存在期数的开奖数据
            if (window.verifyPlanData.length > 0) {
                dataSource.forEach(item => {
                    // 更新已存在期数的开奖数据（保留用户添加的验证号码）
                    const existingRecord = window.verifyPlanData.find(record => record.period === item.period);
                    if (existingRecord) {
                        existingRecord.latestData = item.data;
                    }
                });
                
                console.log('已同步开奖数据到验证计划:', window.verifyPlanData.length, '条记录');
            } else {
                console.log('验证计划数据为空，等待用户添加验证计划');
            }
            
            // 同步完成后立即更新表格
            updateVerifyPlanTable();
            
            // 移除单期验证主动检查逻辑
        } else {
            console.log('暂无数据源，尝试获取历史数据');
            // 如果没有数据，尝试获取历史数据
            if (typeof fetchHistoryData === 'function') {
                fetchHistoryData().then(result => {
                    if (result && result.success) {
                        console.log('历史数据获取成功，重新同步');
                        window.syncDataToVerifyPlan();
                    }
                }).catch(error => {
                    console.error('获取历史数据失败:', error);
                });
            }
        }
    };

    // 全局分页变量
    let currentPage = 1;
    let periodsPerPage = 15; // 默认15期
    let totalPages = 1;
    
    // 期数选择函数
    window.selectPeriods = function(periods) {
        periodsPerPage = periods;
        currentPage = 1;
        window.updateVerifyPlanTable();
        updatePaginationControls();
        updatePeriodButtonsActiveState();
    }
    
    // 自定义期数函数
    window.setCustomPeriods = function() {
        const input = document.getElementById('customPeriodsInput');
        const value = parseInt(input.value);
        if (value && value > 0 && value <= 1000) {
            periodsPerPage = value;
            currentPage = 1;
            window.updateVerifyPlanTable();
            updatePaginationControls();
            updatePeriodButtonsActiveState();
        } else {
            alert('请输入1-1000之间的有效数字');
        }
    }
    
    // 分页控制函数
    window.goToPage = function(page) {
        if (page >= 1 && page <= totalPages) {
            currentPage = page;
            window.updateVerifyPlanTable();
            updatePaginationControls();
        }
    }
    
    window.previousPage = function() {
        if (currentPage > 1) {
            currentPage--;
            window.updateVerifyPlanTable();
            updatePaginationControls();
        }
    }
    
    window.nextPage = function() {
        if (currentPage < totalPages) {
            currentPage++;
            window.updateVerifyPlanTable();
            updatePaginationControls();
        }
    }
    
    // 更新分页控件
    function updatePaginationControls() {
        const paginationInfo = document.getElementById('paginationInfo');
        const prevBtn = document.getElementById('prevPageBtn');
        const nextBtn = document.getElementById('nextPageBtn');
        
        if (paginationInfo) {
            paginationInfo.textContent = `第 ${currentPage} 页，共 ${totalPages} 页`;
        }
        
        if (prevBtn) {
            prevBtn.disabled = currentPage <= 1;
            prevBtn.className = currentPage <= 1 ? 
                'px-3 py-1 bg-gray-300 text-gray-500 rounded cursor-not-allowed' :
                'px-3 py-1 bg-blue-500 text-white rounded hover:bg-blue-600 cursor-pointer';
        }
        
        if (nextBtn) {
            nextBtn.disabled = currentPage >= totalPages;
            nextBtn.className = currentPage >= totalPages ? 
                'px-3 py-1 bg-gray-300 text-gray-500 rounded cursor-not-allowed' :
                'px-3 py-1 bg-blue-500 text-white rounded hover:bg-blue-600 cursor-pointer';
        }
        
        // 更新期数选择按钮状态
        updatePeriodButtonsActiveState();
    }

    // 高亮当前选中的期数按钮
    function updatePeriodButtonsActiveState() {
        const buttons = document.querySelectorAll('.periods-btn');
        buttons.forEach(btn => {
            const periods = parseInt(btn.dataset.periods);
            if (periods === periodsPerPage) {
                btn.className = 'periods-btn px-3 py-1 bg-blue-500 text-white text-sm rounded hover:bg-blue-600 transition-colors';
            } else {
                btn.className = 'periods-btn px-3 py-1 bg-gray-300 text-gray-700 text-sm rounded hover:bg-gray-400 transition-colors';
            }
        });
    }

    // 初始渲染后，同步一次按钮选中状态
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => updatePeriodButtonsActiveState());
    } else {
        updatePeriodButtonsActiveState();
    }
    
    // 更新验证计划表格 - 完全复制数据分析页面的L()函数逻辑
    window.updateVerifyPlanTable = async function() {
        console.log('=== updateVerifyPlanTable 被调用 ===');
        console.log('当前历史数据状态:', window.historyData ? window.historyData.length : 0, '条');
        console.log('当前r数据状态:', window.r ? window.r.length : 0, '条');
        console.log('当前验证记录状态:', window.verifyPlanData ? window.verifyPlanData.length : 0, '条');
        
        const verifyPlanTable = document.getElementById('verifyPlanTable');
        const verifyPlanTableBody = document.getElementById('verifyPlanTableBody');
        console.log('表格元素检查 - verifyPlanTable:', !!verifyPlanTable, 'verifyPlanTableBody:', !!verifyPlanTableBody);
        
        if (!verifyPlanTable || !verifyPlanTableBody) {
            console.log('验证计划表格元素不存在');
            return;
        }
        
        // 检查数据源：优先使用window.r（数据分析页面的主数据源），其次使用window.historyData
        let dataSource = null;
        if (window.r && window.r.length > 0) {
            dataSource = window.r;
            console.log('使用window.r数据源，长度:', dataSource.length);
        } else if (window.historyData && window.historyData.length > 0) {
            dataSource = window.historyData;
            console.log('使用window.historyData数据源，长度:', dataSource.length);
        }
        
        // 如果没有任何数据，尝试获取历史数据
        if (!dataSource || dataSource.length === 0) {
            console.log('验证计划页面：没有找到数据源，尝试获取历史数据');
            const thead = verifyPlanTable.querySelector('thead');
            if (thead) thead.innerHTML = '';
            verifyPlanTableBody.innerHTML = `
                <tr>
                    <td colspan="100" class="py-4 text-center text-gray-500">
                        正在加载数据...
                    </td>
                </tr>
            `;
            
            // 多重数据获取策略
            let dataObtained = false;
            
            // 策略1：尝试获取历史数据
            if (typeof fetchHistoryData === 'function') {
                try {
                    const result = await fetchHistoryData();
                    if (result && result.success && window.historyData && window.historyData.length > 0) {
                        console.log('验证计划页面：历史数据获取成功，重新渲染表格');
                        dataObtained = true;
                        window.updateVerifyPlanTable();
                        return;
                    }
                } catch (error) {
                    console.error('验证计划页面：获取历史数据失败:', error);
                }
            }
            
            // 策略2：尝试从API获取数据
            if (!dataObtained && typeof fetchApiData === 'function') {
                try {
                    console.log('验证计划页面：尝试从API获取数据');
                    await fetchApiData();
                    // 检查是否有数据
                    if ((window.historyData && window.historyData.length > 0) || (window.r && window.r.length > 0)) {
                        console.log('验证计划页面：API数据获取成功，重新渲染表格');
                        dataObtained = true;
                        window.updateVerifyPlanTable();
                        return;
                    }
                } catch (error) {
                    console.error('验证计划页面：API数据获取失败:', error);
                }
            }
            
            // 策略3：启动数据获取定时器
            if (!dataObtained) {
                console.log('验证计划页面：启动数据获取定时器');
                if (typeof startVerifyPlanDataFetch === 'function') {
                    startVerifyPlanDataFetch();
                }
                
                verifyPlanTableBody.innerHTML = `
                    <tr>
                        <td colspan="100" class="py-4 text-center text-gray-500">
                            正在获取数据，请稍候...<br>
                            <small class="text-xs">如果长时间无数据，请尝试刷新页面或在数据分析页面手动获取数据</small>
                        </td>
                    </tr>
                `;
            }
            return;
        }
        
        console.log('验证计划页面开始渲染表格，数据长度:', dataSource.length);
        
        // 复制L()函数的完整逻辑
        const thead = verifyPlanTable.querySelector('thead');
        const tbody = verifyPlanTableBody;
        
        // 清空表格
        if (thead) thead.innerHTML = '';
        tbody.innerHTML = '';
        
        // 计算分页
        const totalRecords = dataSource.length;
        totalPages = Math.ceil(totalRecords / periodsPerPage);
        
        // 确保当前页在有效范围内
        if (currentPage > totalPages) {
            currentPage = totalPages;
        }
        if (currentPage < 1) {
            currentPage = 1;
        }
        
        // 获取当前页数据
        const startIndex = (currentPage - 1) * periodsPerPage;
        const endIndex = Math.min(startIndex + periodsPerPage, totalRecords);
        const n = dataSource.slice(startIndex, endIndex);
        
        console.log(`验证计划页面: 显示第 ${currentPage} 页，共 ${totalPages} 页，当前页 ${n.length} 条记录`);
        
        // 确保数据格式正确
        if (!n || n.length === 0) {
            tbody.innerHTML = `
                <tr>
                    <td colspan="100" class="py-4 text-center text-gray-500">
                        数据为空
                    </td>
                </tr>
            `;
            updatePaginationControls();
            return;
        }
        
        // 创建表格数据结构（复制L()函数的逻辑）
        const s = n.map(t => ({rec: t, cells: {}}));
        
        // 生成新的表头结构
        const headerRow = document.createElement("tr");
        headerRow.className = "bg-gray-50 table-header-sticky";
        
        // 第一列：期号
        const periodHeader = document.createElement("th");
        periodHeader.className = "px-3 py-2 text-center sticky-col left-0 border-r border-gray-200 fixed-width-period sticky-bg-white";
        periodHeader.style.cssText = "position: sticky; top: 0; z-index: 1001;";
        periodHeader.innerHTML = '<div class="font-medium">期号</div>';
        headerRow.appendChild(periodHeader);
        
        // 第二列：开奖号码
        const dataHeader = document.createElement("th");
        dataHeader.className = "px-3 py-2 text-center sticky-col left-[120px] border-r border-gray-200 fixed-width-data sticky-bg-white";
        dataHeader.style.cssText = "position: sticky; top: 0; z-index: 1001;";
        dataHeader.innerHTML = '<div class="font-medium">开奖号码</div>';
        headerRow.appendChild(dataHeader);
        
        // 获取所有验证计划并为每个计划创建一列
        const allPlans = window.verifyPlanData || [];
        const uniquePlans = [];
        
        // 按照planHash来区分不同的验证计划，确保唯一性，只处理真实的验证计划（betCount > 0）
        allPlans.forEach(plan => {
            // 只处理真实的验证计划，过滤掉默认的0注记录
            if (plan.betCount && plan.betCount > 0) {
                const planHash = plan.planHash || plan.generationConditions?.planHash;
                
                // 如果没有planHash，使用计划内容生成唯一标识（不包含时间戳）
                let planKey;
                if (planHash) {
                    planKey = planHash;
                } else {
                    // 使用计划的核心内容生成唯一标识
                    const conditions = plan.generationConditions || {};
                    const contentKey = `${plan.betCount}注_${conditions.selectedNumbers?.sort().join(',') || ''}_${conditions.betMultiple || 1}_${conditions.periods || 1}`;
                    planKey = contentKey;
                }
                
                // 使用planKey确保计划的唯一性，避免重复列
                if (!uniquePlans.find(p => p.key === planKey)) {
                    uniquePlans.push({
                        key: planKey,
                        betCount: plan.betCount,
                        timestamp: plan.timestamp || plan.planId,
                        displayName: `${plan.betCount}注`,
                        planId: plan.planId,
                        planHash: planHash || planKey
                    });
                }
            }
        });
        
        // 创建验证计划列头
        if (uniquePlans.length > 0) {
            // 有验证计划时，为每个验证计划创建列头
            uniquePlans.forEach((plan, index) => {
                const planHeader = document.createElement("th");
                planHeader.className = "px-3 py-2 text-center border-r border-gray-200 plan-column";
                planHeader.dataset.planKey = plan.key;
                // 头部tooltip：根据计划找到对应验证记录并构建条件文本
                const headerVerifyRecord = (window.verifyPlanData || []).find(v => {
                    const vPlanHash = v.planHash || (v.generationConditions && v.generationConditions.planHash);
                    if (vPlanHash && plan.planHash && vPlanHash === plan.planHash) {
                        return true;
                    }
                    return v.betCount === plan.betCount && (plan.key.includes(v.timestamp || v.planId || ''));
                });
                const headerTextRaw = headerVerifyRecord ? buildConciseConditionText(headerVerifyRecord) : '未找到该计划的验证详情';
                const headerTextEscaped = headerTextRaw.replace(/'/g, "\\'").replace(/\n/g, '\\n');
                const headerTitleEscaped = headerTextRaw.replace(/'/g, "\\'").replace(/\n/g, ' ');
                planHeader.innerHTML = `<div class=\"font-medium cursor-help plan-header-trigger\" style=\"display:inline-block; white-space:nowrap;\" title=\"${headerTitleEscaped}\" onmouseenter=\"cancelHidePlanTooltip();showPlanTooltip(this, '${plan.key}', '${headerTextEscaped}');\" onmouseleave=\"scheduleHidePlanTooltip(100)\">${plan.displayName}</div>`;
                headerRow.appendChild(planHeader);
            });
        } else {
            // 没有验证计划时，添加空状态提示列
            const emptyStateHeader = document.createElement("th");
            emptyStateHeader.className = "px-3 py-2 text-center border-r border-gray-200 empty-state-column";
            emptyStateHeader.innerHTML = `<div class="font-medium text-gray-400">验证计划</div>`;
            headerRow.appendChild(emptyStateHeader);
        }
        
        if (thead) thead.appendChild(headerRow);
        
        // 渲染数据行（新的结构）
        s.forEach((item, index) => {
            const row = document.createElement("tr");
            row.className = index === 0 ? "bg-gray-100" : index === 1 ? "bg-gray-50" : "";
            
            // 期数列
            const periodCell = document.createElement("td");
            periodCell.className = `px-3 py-2 text-left sticky-col left-0 border-r border-gray-200 font-medium fixed-width-period ${index === 0 ? "sticky-bg-gray-100" : index === 1 ? "sticky-bg-gray-50" : "sticky-bg-white"}`;
            periodCell.textContent = item.rec.period;
            row.appendChild(periodCell);
            
            // 开奖号码列
            const dataCell = document.createElement("td");
            dataCell.className = `px-3 py-2 text-left sticky-col left-[120px] border-r border-gray-200 fixed-width-data ${index === 0 ? "sticky-bg-gray-100" : index === 1 ? "sticky-bg-gray-50" : "sticky-bg-white"}`;
            dataCell.innerHTML = `
                <div class="number-row">${item.rec.data.slice(0, 5).join(",")}</div>
                <div class="number-row">${item.rec.data.slice(5).join(",")}</div>
            `;
            row.appendChild(dataCell);
            
            // 创建验证计划数据列
            if (uniquePlans.length > 0) {
                // 有验证计划时，为每个验证计划创建数据列
                uniquePlans.forEach(plan => {
                    const planCell = document.createElement("td");
                    planCell.className = "px-3 py-2 text-center border-r border-gray-200 plan-data-cell";
                    planCell.dataset.planKey = plan.key;
                    
                    // 查找该计划的验证记录（全期验证结果）
                    const verifyRecord = window.verifyPlanData ? 
                        window.verifyPlanData.find(v => {
                            // 使用planHash进行精确匹配
                            const vPlanHash = v.planHash || v.generationConditions?.planHash;
                            if (vPlanHash && plan.planHash && vPlanHash === plan.planHash) {
                                return true;
                            }
                            
                            // 备用匹配：注数和时间戳
                            return v.betCount === plan.betCount && 
                                   plan.key.includes(v.timestamp || v.planId || '');
                        }) : null;
                    
                    let cellContent = '';
                    if (verifyRecord) {
                        // 动态判定当前行是否命中（基于当前显示期数的开奖号码）
                        const drawNumbers = Array.isArray(item.rec.data) ? item.rec.data.slice(0, 5).map(n => parseInt(n)) : [];
                        let isHit = false;
                        const planNums = Array.isArray(verifyRecord.planNumbers) ? verifyRecord.planNumbers : [];
                        for (const numberStr of planNums) {
                            let numbers;
                            if (Array.isArray(numberStr)) {
                                numbers = numberStr.map(n => parseInt(n));
                            } else if (typeof numberStr === 'string') {
                                const parts = numberStr.split(/[\s,]+/).filter(Boolean);
                                numbers = parts.map(n => parseInt(n));
                            } else {
                                continue;
                            }
                            if (numbers.length === 5 && numbers.every((n, idx) => !isNaN(n) && drawNumbers[idx] !== undefined && n === drawNumbers[idx])) {
                                isHit = true;
                                break;
                            }
                        }
                        
                        const cellResult = isHit ? '中' : '挂';
                        const resultClass = isHit ? 'text-green-600 font-bold' : 'text-red-600 font-bold';
                        
                        // 使用简洁文案，仅包含选号条件与容错（不拼接中奖号码）
                        let conditionText = buildConciseConditionText(verifyRecord);
                        
                        cellContent = `
                            <div class="relative plan-cell-container" data-plan-key="${plan.key}">
                                <div class="text-sm ${resultClass} plan-result">
                                    ${cellResult}
                                </div>
                            </div>
                        `;
                    } else {
                        // 没有验证记录时不显示任何内容
                        cellContent = '';
                    }
                    
                    planCell.innerHTML = cellContent;
                    row.appendChild(planCell);
                });
            } else {
                // 没有验证计划时，添加空状态提示单元格
                const emptyStateCell = document.createElement("td");
                emptyStateCell.className = "px-3 py-2 text-center border-r border-gray-200 empty-state-cell";
                emptyStateCell.innerHTML = `<div class="text-gray-400 text-sm">未添加计划</div>`;
                row.appendChild(emptyStateCell);
            }
            
            tbody.appendChild(row);
        });
        
        console.log('验证计划页面表格渲染完成，共', s.length, '行数据');
        updateStatistics();
        updatePaginationControls();
        
        // 同步更新单期验证表格
        if (typeof window.updateSinglePeriodTable === 'function') {
            console.log('多期验证更新完成，同步更新单期验证表格');
            window.updateSinglePeriodTable();
        }
    }
    
    // 构建计划条件文本（用于列头和单元格的tooltip）
    function buildConciseConditionText(verifyRecord) {
        const conditions = (verifyRecord && verifyRecord.generationConditions) ? verifyRecord.generationConditions : {};
        const groups = Array.isArray(conditions.groups) ? conditions.groups : [];

        // 优先使用组信息，仅显示实际记录的内容
        if (groups.length > 0) {
            const lines = groups
                .map(g => {
                    const numbers = Array.isArray(g.selectedNumbers) ? g.selectedNumbers : [];
                    const damas = Array.isArray(g.selectedDamas) ? g.selectedDamas : [];
                    const tmin = typeof g.toleranceMin === 'number' ? g.toleranceMin : 0;
                    const tmax = typeof g.toleranceMax === 'number' ? g.toleranceMax : 0;

                    const parts = [];
                    if (numbers.length) parts.push(numbers.join(','));
                    if (damas.length) parts.push(`中${damas.join(',')}胆`);
                    if ((tmin || tmax) && !(tmin === 0 && tmax === 0)) {
                        const maxVal = (typeof tmax === 'number' && tmax >= tmin) ? tmax : tmin;
                        parts.push(`容错${tmin}-${maxVal}`);
                    }
                    const text = parts.join('，');
                    return text;
                })
                .filter(line => line && line.trim().length > 0);
            if (lines.length > 0) return lines.join('\n');
        }

        // 没有组信息时，仅显示已记录的号码/模块容错，空则返回空字符串
        const selectedNumbers = Array.isArray(conditions.selectedNumbers) ? conditions.selectedNumbers : [];
        const moduleTolMin = (typeof conditions.moduleToleranceMin === 'number') ? conditions.moduleToleranceMin : 0;
        const moduleTolMax = (typeof conditions.moduleToleranceMax === 'number') ? conditions.moduleToleranceMax : 0;

        const parts = [];
        if (selectedNumbers.length) parts.push(selectedNumbers.join(','));
        if ((moduleTolMin || moduleTolMax) && !(moduleTolMin === 0 && moduleTolMax === 0)) {
            const maxVal = (typeof moduleTolMax === 'number' && moduleTolMax >= moduleTolMin) ? moduleTolMax : moduleTolMin;
            parts.push(`容错${moduleTolMin}-${maxVal}`);
        }
        return parts.join('，');
    }

    function buildPlanConditionText(verifyRecord) {
        const conditions = (verifyRecord && verifyRecord.generationConditions) ? verifyRecord.generationConditions : {};
        const selectedNumbers = Array.isArray(conditions.selectedNumbers) ? conditions.selectedNumbers : [];
        const betMultiple = (conditions && conditions.betMultiple) ? conditions.betMultiple : 1;
        const periods = (conditions && conditions.periods) ? conditions.periods : 1;
        const moduleType = (conditions && conditions.moduleType) ? conditions.moduleType : '五星做号';
        const generatedTime = conditions.generatedAt ? new Date(conditions.generatedAt).toLocaleString() : '未记录';
        const moduleTolMin = (conditions && typeof conditions.moduleToleranceMin === 'number') ? conditions.moduleToleranceMin : 0;
        const moduleTolMax = (conditions && typeof conditions.moduleToleranceMax === 'number') ? conditions.moduleToleranceMax : 0;
        const groups = Array.isArray(conditions.groups) ? conditions.groups : [];

        let groupsText = '';
        if (groups.length > 0) {
            groups.forEach((g, idx) => {
                const sn = Array.isArray(g.selectedNumbers) && g.selectedNumbers.length > 0 ? g.selectedNumbers.join(',') : '未选';
                const sd = Array.isArray(g.selectedDamas) && g.selectedDamas.length > 0 ? g.selectedDamas.join(',') : '未选';
                const tmin = (typeof g.toleranceMin === 'number') ? g.toleranceMin : 0;
                const tmax = (typeof g.toleranceMax === 'number') ? g.toleranceMax : 0;
                groupsText += `\n组${idx + 1}: 数字[${sn}] 胆码[${sd}] 容错${tmin}-${tmax}`;
            });
        } else {
            groupsText = '\n未记录组条件';
        }

        const verificationDetails = verifyRecord && verifyRecord.verificationDetails ? verifyRecord.verificationDetails : {};
        const totalWins = verificationDetails.totalWins || 0;
        const totalPeriods = verificationDetails.totalPeriods || 0;
        const winRate = verificationDetails.winRate || '0%';
        const numbersText = selectedNumbers.length > 0 ? selectedNumbers.join(', ') : '未记录';

        const text = `📊 ${moduleType}\n\n🔧 模块容错: ${moduleTolMin}-${moduleTolMax}\n🧩 条件组:${groupsText}\n\n🔢 选择号码: ${numbersText}\n📈 投注倍数: ${betMultiple}倍\n📅 投注期数: ${periods}期\n⏰ 生成时间: ${generatedTime}\n\n📈 全期验证结果:\n🎯 总中奖: ${totalWins}/${totalPeriods}期\n📊 中奖率: ${winRate}`;
        return text;
    }

    // 显示计划悬停提示
    function showPlanTooltip(element, planKey, conditionText) {
        // 移除现有的提示框
        hidePlanTooltip();
        
        const tooltip = document.createElement('div');
        tooltip.id = 'planTooltip';
        tooltip.className = 'absolute bg-gray-800 text-white text-xs rounded-lg z-50 shadow-lg';
        tooltip.style.cssText = `
            position: fixed;
            background: linear-gradient(135deg, #1f2937 0%, #374151 100%);
            color: white;
            font-size: 13px;
            border-radius: 10px;
            padding: 10px 12px; /* 稍小的内边距以更贴合文字 */
            z-index: 10000;
            box-shadow: 0 8px 25px rgba(0,0,0,0.4);
            max-width: 280px;
            border: 1px solid rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            line-height: 1.35; /* 稍紧凑的行高 */
            pointer-events: auto;
            cursor: default;
            max-height: 50vh; /* 动态高度，视口一半为上限 */
            overflow: auto; /* 超出时滚动 */
        `;
        
        // 设置提示内容
        const decodedText = conditionText.replace(/\\n/g, '\n').replace(/\\'/g, "'");
        // 构建内容：条件仅显示已记录项；删除按钮无“✕”，并使按钮高度略大于文字
        tooltip.innerHTML = `
            <div style="margin-bottom: 8px; pointer-events: none; white-space: pre-line;">${decodedText}</div>
            <div style="text-align: center; margin-top: 8px;">
                <button onclick="deletePlanColumn('${planKey}')"
                        style="background:#ef4444;color:#fff;border:none;border-radius:6px;padding:6px 10px;cursor:pointer;font-size:12px;line-height:1.2;min-height:24px;pointer-events:auto;display:inline-flex;align-items:center;justify-content:center;"
                        onmouseover="this.style.background='#dc2626'"
                        onmouseout="this.style.background='#ef4444'">
                    删除此列
                </button>
            </div>
        `;
        // 悬停控制：进入弹窗取消隐藏，离开弹窗延迟隐藏
        tooltip.addEventListener('mouseenter', cancelHidePlanTooltip, { passive: true });
        tooltip.addEventListener('mouseleave', () => scheduleHidePlanTooltip(100), { passive: true });
        
        document.body.appendChild(tooltip);
        
        // 计算位置
        setTimeout(() => {
            const rect = element.getBoundingClientRect();
            const tooltipRect = tooltip.getBoundingClientRect();
            
            let left = rect.left + (rect.width / 2) - (tooltipRect.width / 2);
            let top = rect.top - tooltipRect.height - 8;
            
            // 边界检查
            if (left < 10) left = 10;
            if (left + tooltipRect.width > window.innerWidth - 10) {
                left = window.innerWidth - tooltipRect.width - 10;
            }
            if (top < 10) {
                top = rect.bottom + 8;
            }
            
            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
        }, 0);
    }
    
    // 隐藏计划悬停提示
    function hidePlanTooltip() {
        const tooltip = document.getElementById('planTooltip');
        if (tooltip) {
            tooltip.remove();
        }
    }

    // 将 tooltip 相关函数暴露到全局，修复 ReferenceError
    window.showPlanTooltip = showPlanTooltip;
    window.hidePlanTooltip = hidePlanTooltip;
    window.deletePlanColumn = deletePlanColumn;
    window.scheduleHidePlanTooltip = scheduleHidePlanTooltip;
    window.cancelHidePlanTooltip = cancelHidePlanTooltip;
    
    // Tooltip 延迟隐藏控制，避免从表头到弹窗的移动过程中被立即关闭
    window._planTooltipHideTimer = null;
    function scheduleHidePlanTooltip(delay = 220) {
        clearTimeout(window._planTooltipHideTimer);
        window._planTooltipHideTimer = setTimeout(() => {
            window._planTooltipHideTimer = null;
            hidePlanTooltip();
        }, delay);
    }
    function cancelHidePlanTooltip() {
        clearTimeout(window._planTooltipHideTimer);
        window._planTooltipHideTimer = null;
    }

    // 添加全局鼠标移动监听：未在表头、单元格或弹窗上时，延迟隐藏；否则取消隐藏
    document.addEventListener('mousemove', function(e) {
        const tooltip = document.getElementById('planTooltip');
        if (tooltip) {
            const tooltipRect = tooltip.getBoundingClientRect();
            const isOverTooltip = e.clientX >= tooltipRect.left && e.clientX <= tooltipRect.right &&
                                 e.clientY >= tooltipRect.top && e.clientY <= tooltipRect.bottom;
            
            const planCell = e.target.closest('.plan-cell-container');
            const headerTrigger = e.target.closest('.plan-header-trigger');
            if (!planCell && !headerTrigger && !isOverTooltip) {
                scheduleHidePlanTooltip(100);
            } else {
                cancelHidePlanTooltip();
            }
        }
    });
    
    // 删除验证计划列
    function deletePlanColumn(planKey) {
        // 先隐藏提示框
        hidePlanTooltip();
        
        // 移除确认对话框，直接删除
        
        console.log('删除验证计划列:', planKey);
        
        // 从验证计划数据中删除对应的记录
        if (window.verifyPlanData) {
            const originalLength = window.verifyPlanData.length;
            
            // 判断是否为旧格式键（形如 "N注_timestamp"）
            const looksLikeLegacyKey = typeof planKey === 'string' && planKey.includes('注_');
            
            // 目标计划ID（用于同步删除存储）
            let targetPlanIds = [];
            
            if (!looksLikeLegacyKey) {
                // 新逻辑：优先使用 planHash 精确匹配
                const keyHash = planKey;
                const matchByKey = (rec) => {
                    const vHash = rec.planHash || (rec.generationConditions && rec.generationConditions.planHash);
                    if (vHash && keyHash && vHash === keyHash) return true;
                    // 当没有 planHash 时，按内容键匹配
                    const conditions = rec.generationConditions || {};
                    const numbers = Array.isArray(conditions.selectedNumbers) ? [...conditions.selectedNumbers].sort().join(',') : '';
                    const betMultiple = conditions.betMultiple || 1;
                    const periods = conditions.periods || 1;
                    const contentKey = `${rec.betCount}注_${numbers}_${betMultiple}_${periods}`;
                    return keyHash === contentKey;
                };
                
                const toDelete = window.verifyPlanData.filter(matchByKey);
                targetPlanIds = toDelete.map(r => r.planId).filter(Boolean);
                
                // 过滤掉匹配的记录
                window.verifyPlanData = window.verifyPlanData.filter(rec => !matchByKey(rec));
            } else {
                // 兼容旧逻辑：betCount + 时间戳匹配
                const planInfo = planKey.split('注_');
                const betCount = parseInt(planInfo[0], 10);
                const timestampPart = planInfo[1];
                
                window.verifyPlanData = window.verifyPlanData.filter(rec => {
                    const planTimestamp = rec.timestamp || rec.planId || '';
                    const isTarget = rec.betCount === betCount && 
                        (timestampPart === planTimestamp.toString() || 
                         planKey.includes(planTimestamp.toString()));
                    if (isTarget && rec.planId) {
                        targetPlanIds.push(rec.planId);
                    }
                    return !isTarget;
                });
            }
            
            const deletedCount = originalLength - window.verifyPlanData.length;
            
            if (deletedCount > 0) {
                // 同步删除本地存储中的计划
                if (window.PlanStorageManager && typeof window.PlanStorageManager.deletePlan === 'function' && targetPlanIds.length > 0) {
                    targetPlanIds.forEach(pid => {
                        try {
                            window.PlanStorageManager.deletePlan(pid);
                        } catch (err) {
                            console.warn('删除本地存储计划失败:', pid, err);
                        }
                    });
                }
                
                console.log(`✅ 删除成功: ${originalLength} -> ${window.verifyPlanData.length} 条记录`);
                
                // 显示删除成功提示
                const notification = document.createElement('div');
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: #4CAF50;
                    color: white;
                    padding: 10px 20px;
                    border-radius: 5px;
                    z-index: 10000;
                    font-size: 14px;
                    box-shadow: 0 2px 10px rgba(0,0,0,0.2);
                `;
                notification.textContent = '计划删除成功';
                document.body.appendChild(notification);
                
                setTimeout(() => {
                    if (document.body.contains(notification)) {
                        document.body.removeChild(notification);
                    }
                }, 2000);
            } else {
                console.error('❌ 未找到需要删除的计划，planKey:', planKey);
                alert('未找到需要删除的计划，请重试');
                return;
            }
        }
        
        // 重新渲染表格
        window.updateVerifyPlanTable();
        
        // 更新统计信息
        updateStatistics();
    }
    
    // 更新统计信息（基于当前可见期数与页面上显示的计划结果）
    function updateStatistics() {
        // 顶部“共 X 条记录”保留为当前计划总数（记录数）
        const totalPlanRecords = Array.isArray(window.verifyPlanData)
            ? window.verifyPlanData.filter(item => item && item.betCount > 0).length
            : 0;
        if (verifyDataCount) verifyDataCount.textContent = `共 ${totalPlanRecords} 条记录`;

        const tbody = document.getElementById('verifyPlanTableBody');
        if (!tbody) {
            if (totalPeriods) totalPeriods.textContent = 0;
            if (successCount) successCount.textContent = 0;
            if (failCount) failCount.textContent = 0;
            return;
        }

        // 当前可见期数：表体中期号列数量
        const periodCells = tbody.querySelectorAll('td.fixed-width-period');
        const visiblePeriods = periodCells ? periodCells.length : 0;

        // 命中/未中：统计当前页渲染出来的 .plan-result 文本
        let success = 0;
        let fail = 0;
        const resultNodes = tbody.querySelectorAll('.plan-result');
        resultNodes.forEach(node => {
            const txt = (node.textContent || '').trim();
            if (txt === '中') success++;
            else if (txt === '挂') fail++;
        });

        if (totalPeriods) totalPeriods.textContent = visiblePeriods;
        if (successCount) successCount.textContent = success;
        if (failCount) failCount.textContent = fail;
    }
    
    // 页面加载时执行初始数据同步和表格初始化
    async function initVerifyPlanPage() {
        console.log('=== 初始化验证计划页面 ===');
        console.log('初始化前数据状态:');
        console.log('- window.historyData:', window.historyData ? window.historyData.length : 0, '条');
        console.log('- window.r:', window.r ? window.r.length : 0, '条');
        console.log('- window.verifyPlanData:', window.verifyPlanData ? window.verifyPlanData.length : 0, '条');
        
        // 先尝试同步数据
        if (typeof window.syncDataToVerifyPlan === 'function') {
            console.log('调用syncDataToVerifyPlan函数');
            window.syncDataToVerifyPlan();
        } else {
            console.log('syncDataToVerifyPlan函数不存在');
        }
        
        // 然后更新表格和统计信息
        await window.updateVerifyPlanTable();
        updateStatistics();
        updatePaginationControls();
        
        // 如果仍然没有数据，启动数据获取
        if ((!window.historyData || window.historyData.length === 0) && 
            (!window.r || window.r.length === 0)) {
            console.log('验证计划页面：没有找到数据，启动历史数据获取');
            
            // 多重获取策略
            let dataObtained = false;
            
            // 策略1：获取历史数据
            if (typeof fetchHistoryData === 'function') {
                try {
                    const result = await fetchHistoryData();
                    if (result && result.success) {
                        console.log('验证计划页面：历史数据获取成功，重新初始化页面');
                        window.syncDataToVerifyPlan();
                        await updateVerifyPlanTable();
                        updateStatistics();
                        dataObtained = true;
                    }
                } catch (error) {
                    console.error('验证计划页面：获取历史数据失败:', error);
                }
            }
            
            // 策略2：如果历史数据获取失败，尝试API数据
            if (!dataObtained && typeof fetchApiData === 'function') {
                try {
                    console.log('验证计划页面：尝试获取API数据');
                    await fetchApiData();
                    if ((window.historyData && window.historyData.length > 0) || (window.r && window.r.length > 0)) {
                        console.log('验证计划页面：API数据获取成功');
                        window.syncDataToVerifyPlan();
                        await updateVerifyPlanTable();
                        updateStatistics();
                        dataObtained = true;
                    }
                } catch (error) {
                    console.error('验证计划页面：API数据获取失败:', error);
                }
            }
            
            // 策略3：启动定时数据获取
            if (!dataObtained && typeof startVerifyPlanDataFetch === 'function') {
                console.log('验证计划页面：启动定时数据获取');
                startVerifyPlanDataFetch();
            }
        }
    }
    
    // 执行初始化
    initVerifyPlanPage();
    
    // 初始化期数选择按钮状态
    setTimeout(() => {
        updatePaginationControls();
    }, 500);
    
    // 添加实时更新机制
    let verifyPlanUpdateInterval;
    function startVerifyPlanRealTimeUpdate() {
        // 清除之前的定时器
        if (verifyPlanUpdateInterval) {
            clearInterval(verifyPlanUpdateInterval);
        }
        
        // 每30秒检查一次是否需要更新表格
        verifyPlanUpdateInterval = setInterval(() => {
            if (window.verifyPlanData && window.verifyPlanData.length > 0) {
                // 检查是否有新的开奖数据需要更新验证结果
                let needUpdate = false;
                window.verifyPlanData.forEach(plan => {
                    if (!plan.result && window.historyData) {
                        const periodData = window.historyData.find(h => h.period === plan.period);
                        if (periodData && periodData.data && periodData.data.length >= 10) {
                            needUpdate = true;
                        }
                    }
                });
                
                if (needUpdate) {
                    console.log('检测到新的开奖数据，更新验证计划表格');
                    window.updateVerifyPlanTable();
                }
            }
        }, 30000); // 30秒检查一次
    }
    
    function stopVerifyPlanRealTimeUpdate() {
        if (verifyPlanUpdateInterval) {
            clearInterval(verifyPlanUpdateInterval);
            verifyPlanUpdateInterval = null;
        }
    }
    
    // 启动实时更新
    startVerifyPlanRealTimeUpdate();
    
    // 页面隐藏时停止更新，显示时重新启动
    document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
            stopVerifyPlanRealTimeUpdate();
        } else {
            startVerifyPlanRealTimeUpdate();
        }
    });
    
    // 监听页面显示事件，确保切换到验证计划页面时数据是最新的
    const verifyPlanPage = document.getElementById('verifyPlanPage');
    if (verifyPlanPage) {
        const observer = new MutationObserver(function(mutations) {
            mutations.forEach(function(mutation) {
                if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                    if (!verifyPlanPage.classList.contains('hidden')) {
                        console.log('验证计划页面显示，刷新数据');
                        setTimeout(() => {
                            initVerifyPlanPage();
                        }, 100);
                    }
                }
            });
        });
        observer.observe(verifyPlanPage, { attributes: true });
    }

    // 交集拼接功能
    function initIntersectionCutPage() {
        // 初始化功能切换
        initFunctionSwitch();
        
        // 初始化容错按钮
        initToleranceButtons();
        

        
        // 绑定粘贴按钮事件
        document.querySelectorAll('.paste-btn').forEach(btn => {
            btn.addEventListener('click', async function() {
                const moduleId = this.getAttribute('data-module');
                const textarea = document.querySelector(`.module-textarea[data-module="${moduleId}"]`);
                
                try {
                    const text = await navigator.clipboard.readText();
                    textarea.value = text;
                    updateModuleCount(moduleId);
                } catch (err) {
                    console.error('粘贴失败:', err);
                    alert('粘贴失败，请手动输入');
                }
            });
        });

        // 绑定清除按钮事件
        document.querySelectorAll('.clear-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                const moduleId = this.getAttribute('data-module');
                const textarea = document.querySelector(`.module-textarea[data-module="${moduleId}"]`);
                textarea.value = '';
                updateModuleCount(moduleId);
            });
        });

        // 移除输入框实时监听，注数只在点击做号时更新
        // document.querySelectorAll('.module-textarea').forEach(textarea => {
        //     textarea.addEventListener('input', function() {
        //         const moduleId = this.getAttribute('data-module');
        //         updateModuleCount(moduleId);
        //     });
        // });

        // 绑定做号按钮事件
        const generateBtn = document.getElementById('generateIntersectionBtn');
        if (generateBtn) {
            generateBtn.addEventListener('click', generateIntersection);
        }

        // 绑定复制结果按钮事件
        const copyResultBtn = document.getElementById('copyResultBtn');
        if (copyResultBtn) {
            copyResultBtn.addEventListener('click', copyResult);
        }
        
        // 初始化时更新总计数
        updateTotalCount();
    }

    // 初始化功能切换
    function initFunctionSwitch() {
        const intersectionBtn = document.getElementById('intersectionModeBtn');
        const intersectionContent = document.getElementById('intersectionContent');

        if (intersectionBtn && intersectionContent) {
            intersectionBtn.addEventListener('click', function() {
                // 切换到号码交集
                intersectionBtn.classList.add('active');
                intersectionContent.classList.remove('hidden');
            });
        }
    }

    // 初始化容错按钮
    function initToleranceButtons() {
        let selectedTolerance = 0;
        
        document.querySelectorAll('.tolerance-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                const tolerance = parseInt(this.getAttribute('data-tolerance'));
                
                // 移除所有按钮的active状态
                document.querySelectorAll('.tolerance-btn').forEach(b => b.classList.remove('active'));
                
                if (selectedTolerance === tolerance) {
                    // 如果点击的是已选中的按钮，则取消选择
                    selectedTolerance = 0;
                } else {
                    // 选择新的容错值
                    selectedTolerance = tolerance;
                    this.classList.add('active');
                }
            });
        });
    }

    // 更新模块注数统计
    function updateModuleCount(moduleId) {
        const textarea = document.querySelector(`.module-textarea[data-module="${moduleId}"]`);
        const countElement = document.querySelector(`.module-count[data-module="${moduleId}"]`);
        
        if (textarea && countElement) {
            const content = textarea.value.trim();
            if (content) {
                // 计算实际的号码数量
                let totalNumbers = 0;
                const lines = content.split('\n').filter(line => line.trim());
                
                lines.forEach(line => {
                    // 解析每行的号码，支持逗号分隔
                    const numbers = line.split(',').map(n => n.trim()).filter(n => n);
                    totalNumbers += numbers.length;
                });
                
                countElement.textContent = `${totalNumbers}注`;
            } else {
                countElement.textContent = '0注';
            }
        }
        
        // 更新全局总计数
        updateTotalCount();
    }

    // 更新全局总计数
    function updateTotalCount() {
        const resultCount = document.getElementById('resultCount');
        if (!resultCount) return;
        
        let totalNumbers = 0;
        
        // 统计所有模块的号码数量
        for (let i = 1; i <= 8; i++) {
            const textarea = document.querySelector(`.module-textarea[data-module="${i}"]`);
            if (textarea && textarea.value.trim()) {
                const content = textarea.value.trim();
                const lines = content.split('\n').filter(line => line.trim());
                
                lines.forEach(line => {
                    // 解析每行的号码，支持逗号分隔
                    const numbers = line.split(',').map(n => n.trim()).filter(n => n);
                    totalNumbers += numbers.length;
                });
            }
        }
        
        resultCount.textContent = `共${totalNumbers}注`;
    }

    // 生成交集
    function generateIntersection() {
        // 在做号时更新所有模块的注数
        for (let i = 1; i <= 8; i++) {
            updateModuleCount(i);
        }
        
        const modules = [];
        
        // 收集所有模块的数据
        for (let i = 1; i <= 8; i++) {
            const textarea = document.querySelector(`.module-textarea[data-module="${i}"]`);
            if (textarea && textarea.value.trim()) {
                const lines = textarea.value.trim().split('\n').filter(line => line.trim());
                const moduleNumbers = [];
                
                lines.forEach(line => {
                    // 解析每行的号码，支持逗号分隔
                    const numbers = line.split(',').map(n => n.trim()).filter(n => n);
                    moduleNumbers.push(...numbers);
                });
                
                if (moduleNumbers.length > 0) {
                    // 去重
                    const uniqueNumbers = [...new Set(moduleNumbers)];
                    modules.push(uniqueNumbers);
                }
            }
        }

        if (modules.length === 0) {
            alert('请至少在一个模块中输入数据');
            return;
        }

        if (modules.length === 1) {
            // 只有一个模块时，直接显示该模块的数据
            displayResult(modules[0]);
            return;
        }

        // 获取选中的容错值
        const selectedToleranceBtn = document.querySelector('.tolerance-btn.active');
        const toleranceValue = selectedToleranceBtn ? parseInt(selectedToleranceBtn.getAttribute('data-tolerance')) : 0;

        let result = [];

        if (toleranceValue === 0) {
            // 严格交集：必须在所有模块中都出现
            result = modules[0];
            for (let i = 1; i < modules.length; i++) {
                result = result.filter(num => modules[i].includes(num));
            }
        } else {
            // 容错交集：允许在指定数量的模块中缺失
            const allNumbers = [...new Set(modules.flat())];
            
            allNumbers.forEach(num => {
                let appearCount = 0;
                modules.forEach(module => {
                    if (module.includes(num)) {
                        appearCount++;
                    }
                });
                
                // 如果缺失的模块数量不超过容错值，则包含该号码
                const missingCount = modules.length - appearCount;
                if (missingCount <= toleranceValue) {
                    result.push(num);
                }
            });
        }

        displayResult(result);
    }

    // 显示结果
    function displayResult(numbers) {
        // 排序结果
        numbers.sort((a, b) => {
            const numA = parseInt(a);
            const numB = parseInt(b);
            return numA - numB;
        });

        // 显示结果
        const resultDisplay = document.getElementById('resultDisplay');
        const resultCount = document.getElementById('resultCount');
        
        if (resultDisplay && resultCount) {
            // 保存完整数据到data属性，用于复制
            resultDisplay.setAttribute('data-full-result', numbers.join(','));
            
            // 只显示前500注
            const displayNumbers = numbers.slice(0, 500);
            const displayText = displayNumbers.join(',');
            
            // 如果超过500注，添加省略提示
            if (numbers.length > 500) {
                resultDisplay.value = displayText + '...（显示前500注，点击复制可复制全部）';
            } else {
                resultDisplay.value = displayText;
            }
            
            resultCount.textContent = `共${numbers.length}注`;
        }
    }

    // 复制结果
    async function copyResult() {
        const resultDisplay = document.getElementById('resultDisplay');
        if (resultDisplay && resultDisplay.value) {
            try {
                // 优先从data-full-result属性获取完整数据，如果没有则使用显示的内容
                const fullResult = resultDisplay.getAttribute('data-full-result');
                const textToCopy = fullResult || resultDisplay.value;
                
                await navigator.clipboard.writeText(textToCopy);
                
                // 显示复制成功反馈
                const copyBtn = document.getElementById('copyResultBtn');
                const originalText = copyBtn.textContent;
                copyBtn.textContent = '已复制';
                copyBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                copyBtn.classList.add('bg-gray-500');
                
                setTimeout(() => {
                    copyBtn.textContent = originalText;
                    copyBtn.classList.remove('bg-gray-500');
                    copyBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                }, 1000);
            } catch (err) {
                console.error('复制失败:', err);
                alert('复制失败，请手动复制');
            }
        } else {
            alert('没有结果可复制');
        }
    }


    
    // 生成拼接结果 - 已移到全局作用域
    
// 第一组重复函数定义已删除
// generateIntersectionCombinations函数已移至文件后面


    
// 其他重复函数定义已删除，保留在文件后面的版本

// 重复函数定义已删除，保留在文件后面的版本

// 重复函数定义已删除，保留在文件后面的版本
    
// 重复函数定义已删除，保留在文件后面的版本
    
// 重复函数定义已删除，保留在文件后面的版本
            
// 重复函数定义已删除，保留在文件后面的版本
        
        // 选择前 starLevel 个“非空位置”用于生成排列，避免空位置被截取导致少注
// 重复函数定义已删除，保留在文件后面的版本
        // 重复函数定义已删除，保留在文件后面的版本
        
// 重复函数定义已删除，保留在文件后面的版本
// 重复函数定义已删除，保留在文件后面的版本

// 使用做号模块结果进行筛选：
// 要求：对每个已产出结果的模块，存在至少一条结果，使得其选中位置上的数字与拼接组合对应位置相同
function filterByFiveStarModules(combos, starLevel) {
        if (!Array.isArray(combos) || combos.length === 0) return combos;
        if (!window.moduleStates || Object.keys(window.moduleStates).length === 0) return combos;
        
        // 收集每个模块的约束集合（数组），每个约束是 Map<position(1-based), numberString>
        const modulesConstraints = [];
        Object.keys(window.moduleStates).forEach(key => {
            const ms = window.moduleStates[key];
            if (!ms || !Array.isArray(ms.results) || ms.results.length === 0) return;
            
            // 选中位置（若未选，则默认1..ms.starLevel）
            let positions = Array.isArray(ms.selectedPositions) && ms.selectedPositions.length > 0
                ? ms.selectedPositions.slice()
                : Array.from({ length: ms.starLevel || 0 }, (_, i) => i + 1);
            
            // 仅保留不超过当前拼接星级的有效位置
            positions = positions.filter(p => p >= 1 && p <= starLevel);
            if (positions.length === 0) return;
            
            const constraintList = [];
            for (const line of ms.results) {
                if (typeof line !== 'string') continue;
                const parts = line.split(/\s+/).map(s => s.trim()).filter(Boolean);
                // 只处理与位置数相同的行
                if (parts.length < positions.length) continue;
                const map = new Map();
                for (let idx = 0; idx < positions.length; idx++) {
                    const pos = positions[idx];
                    const num = (parts[idx] || '').padStart(2, '0');
                    if (!/^\d+$/.test(num)) { map.clear(); break; }
                    map.set(pos, num);
                }
                if (map.size === positions.length) constraintList.push(map);
            }
            if (constraintList.length > 0) modulesConstraints.push(constraintList);
        });
        
        if (modulesConstraints.length === 0) return combos;
        
        // 过滤：每个模块需至少匹配一条约束
        return combos.filter(str => {
            const arr = str.split(',').map(s => s.trim());
            if (arr.length !== starLevel) return false;
            
            // 检查所有模块
            for (const constraintList of modulesConstraints) {
                let moduleMatched = false;
                for (const m of constraintList) {
                    let ok = true;
                    for (const [pos, num] of m.entries()) {
                        const idx = pos - 1;
                        if (idx < 0 || idx >= arr.length || arr[idx] !== num) { ok = false; break; }
                    }
                    if (ok) { moduleMatched = true; break; }
                }
                if (!moduleMatched) return false;
            }
            return true;
        });
    }


    // 初始化交集拼接页面
    initIntersectionCutPage();
    
    // 历史记录数量更新函数
    function updateHistoryCount() {
        const historyCount = document.getElementById('historyCount');
        if (historyCount && window.verifyPlanData) {
            historyCount.textContent = `已保存 ${window.verifyPlanData.length} 条记录`;
        }
    }
    
    // 历史管理按钮事件监听器
    const exportHistoryBtn = document.getElementById('exportHistoryBtn');
    const importHistoryBtn = document.getElementById('importHistoryBtn');
    const clearHistoryBtn = document.getElementById('clearHistoryBtn');
    const importFileInput = document.getElementById('importFileInput');
    
    if (exportHistoryBtn) {
        exportHistoryBtn.addEventListener('click', function() {
            if (window.PlanStorageManager && typeof window.PlanStorageManager.exportToFile === 'function') {
                window.PlanStorageManager.exportToFile();
            } else {
                alert('导出功能不可用');
            }
        });
    }
    
    if (importHistoryBtn) {
        importHistoryBtn.addEventListener('click', function() {
            if (importFileInput) {
                importFileInput.click();
            }
        });
    }
    
    if (importFileInput) {
        importFileInput.addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (file && window.PlanStorageManager && typeof window.PlanStorageManager.importFromFile === 'function') {
                window.PlanStorageManager.importFromFile(file);
                // 重置文件输入，允许重复选择同一文件
                event.target.value = '';
            }
        });
    }
    
    if (clearHistoryBtn) {
        clearHistoryBtn.addEventListener('click', function() {
            if (confirm('确定要清空所有计划验证历史吗？此操作不可恢复。')) {
                if (window.PlanStorageManager && typeof window.PlanStorageManager.clearAllPlans === 'function') {
                    window.PlanStorageManager.clearAllPlans();
                    updateHistoryCount();
                    alert('计划验证历史已清空');
                } else {
                    alert('清空功能不可用');
                }
            }
        });
    }
    
    // 页面加载时更新历史记录数量
    updateHistoryCount();
    
    // 添加测试数据功能（仅用于本地测试）
    window.addTestData = function() {
        const currentDate = new Date();
        const dateStr = currentDate.getFullYear().toString() + 
                       (currentDate.getMonth() + 1).toString().padStart(2, '0') + 
                       currentDate.getDate().toString().padStart(2, '0');
        
        // 生成测试数据
        const testData = [];
        for (let i = 178; i >= 170; i--) {
            const period = dateStr + i.toString().padStart(3, '0');
            const numbers = [];
            for (let j = 0; j < 10; j++) {
                numbers.push(Math.floor(Math.random() * 10) + 1);
            }
            testData.push({
                period: period,
                data: numbers,
                input: numbers.join(',')
            });
            d.add(period);
        }
        
        // 添加到r数组
        r.unshift(...testData);
        window.r = r;
        
        console.log('测试数据已添加，当前数据长度:', r.length);
        console.log('最新期号:', r[0].period);
        
        // 更新显示
        document.getElementById('periodCount').textContent = r.length;
        L();
        
        // 如果在单期验证模式，更新表格
        const singlePeriodTable = document.getElementById('singlePeriodTable');
        if (singlePeriodTable && !singlePeriodTable.classList.contains('hidden')) {
            updateSinglePeriodTable();
        }
        
        alert('测试数据已添加！最新期号: ' + r[0].period);
    };
});



// 生成交集拼接组合
function generateIntersectionCombinations(modules, targetStarLevel) {
    if (modules.length < 1) {
        alert('拼接需要至少1个做号模块');
        return [];
    }
    
    // 如果只有一个模块，处理该模块的结果
    if (modules.length === 1) {
        const singleModule = modules[0];
        const results = [];
        const allNumbers = ['01', '02', '03', '04', '05', '06', '07', '08', '09', '10'];
        
        for (const result of singleModule.results) {
            // result 是一个对象，包含位置到数字的映射
            const baseCombination = { ...result };
            
            // 找出已使用的数字
            const usedNumbers = new Set(Object.values(baseCombination));
            
            // 找出空位置（需要补充的位置）
            const emptyPositions = [];
            for (let i = 1; i <= targetStarLevel; i++) {
                if (!baseCombination[i]) {
                    emptyPositions.push(i);
                }
            }
            
            if (emptyPositions.length === 0) {
                // 没有空位置，直接输出
                const finalResult = [];
                for (let i = 1; i <= targetStarLevel; i++) {
                    finalResult.push(baseCombination[i] || '00');
                }
                if (finalResult.length === targetStarLevel) {
                    results.push(finalResult.join(' '));
                }
            } else {
                // 有空位置，用剩余数字补充
                const availableNumbers = allNumbers.filter(num => !usedNumbers.has(num));
                
                // 为空位置生成所有可能的排列
                const emptyPermutations = generatePermutationsWithLength(availableNumbers, emptyPositions.length);
                
                for (const perm of emptyPermutations) {
                    const finalResult = [];
                    for (let i = 1; i <= targetStarLevel; i++) {
                        if (baseCombination[i]) {
                            finalResult.push(baseCombination[i]);
                        } else {
                            const emptyIndex = emptyPositions.indexOf(i);
                            finalResult.push(perm[emptyIndex] || '00');
                        }
                    }
                    if (finalResult.length === targetStarLevel) {
                        results.push(finalResult.join(' '));
                    }
                }
            }
        }
        
        // 去重并排序
        const uniqueResults = [...new Set(results)];
        return uniqueResults.sort();
    }
    
    const finalCombinations = [];
    const allNumbers = ['01', '02', '03', '04', '05', '06', '07', '08', '09', '10'];
    
    // 按星级排序模块，从小到大
    modules.sort((a, b) => a.starLevel - b.starLevel);
    
    const firstModule = modules[0];  // 星级较小的模块
    const secondModule = modules[1]; // 星级较大的模块
    
    // 找出重叠位置（交集位置）
    const overlapPositions = firstModule.positions.filter(pos => 
        secondModule.positions.includes(pos)
    );
    
    if (overlapPositions.length === 0) {
        alert('两个模块没有重叠位置，无法进行交集拼接');
        return [];
    }
    
    // 遍历第一个模块的每一注
    for (const firstResult of firstModule.results) {
        // 在第二个模块中找到重叠位置匹配的注
        for (const secondResult of secondModule.results) {
            // 检查重叠位置是否匹配
            let isMatch = true;
            for (const pos of overlapPositions) {
                if (firstResult[pos] !== secondResult[pos]) {
                    isMatch = false;
                    break;
                }
            }
            
            if (isMatch) {
                // 构建基础组合（合并两个模块的结果）
                const baseCombination = {};
                
                // 添加第一个模块的位置
                for (const pos of firstModule.positions) {
                    baseCombination[pos] = firstResult[pos];
                }
                
                // 添加第二个模块的位置（非重叠部分）
                for (const pos of secondModule.positions) {
                    if (!overlapPositions.includes(pos)) {
                        baseCombination[pos] = secondResult[pos];
                    }
                }
                
                // 找出已使用的数字
                const usedNumbers = new Set(Object.values(baseCombination));
                
                // 找出空位置（需要补充的位置）
                const emptyPositions = [];
                for (let i = 1; i <= targetStarLevel; i++) {
                    if (!baseCombination[i]) {
                        emptyPositions.push(i);
                    }
                }
                
                if (emptyPositions.length === 0) {
                    // 没有空位置，直接输出
                    const result = [];
                    for (let i = 1; i <= targetStarLevel; i++) {
                        result.push(baseCombination[i] || '00');
                    }
                    // 确保输出的是5个数字的号码
                    if (result.length === targetStarLevel) {
                        finalCombinations.push(result.join(' '));
                    }
                } else {
                    // 有空位置，用剩余数字补充
                    const availableNumbers = allNumbers.filter(num => !usedNumbers.has(num));
                    
                    // 为空位置生成所有可能的排列
                    const emptyPermutations = generatePermutationsWithLength(availableNumbers, emptyPositions.length);
                    
                    for (const perm of emptyPermutations) {
                        const result = [];
                        for (let i = 1; i <= targetStarLevel; i++) {
                            if (baseCombination[i]) {
                                result.push(baseCombination[i]);
                            } else {
                                const emptyIndex = emptyPositions.indexOf(i);
                                result.push(perm[emptyIndex] || '00');
                            }
                        }
                        // 确保输出的是5个数字的号码
                        if (result.length === targetStarLevel) {
                            finalCombinations.push(result.join(' '));
                        }
                    }
                }
            }
        }
    }
    
    // 去重并排序
    return [...new Set(finalCombinations)].sort();
}




</script>
</body>
</html>
